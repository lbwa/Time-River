<!doctype html><html data-n-head="lang" data-n-head-ssr lang="zh"><meta data-n-head="true" content="IE=edge,chrome=1" http-equiv='"X-UA-Compatible'><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" name="viewport"><meta data-n-head="true" content="bowen blog, bowen 博客, vuejs, reactjs, ssr, 前端开发, 前端 , web开发, nodejs, github" name="keywords"><meta data-n-head="true" content="一个分享代码经历的地方" name="description" data-hid="description"><meta data-n-head="true" content="yes" name="apple-mobile-web-app-capable"><meta data-n-head="true" content="black" name="apple-mobile-web-app-status-bar-style"><meta data-n-head="true" content="yes" name="mobile-web-app-capable" data-hid="mobile-web-app-capable"><meta data-n-head="true" content="Bowen Blog" name="apple-mobile-web-app-title" data-hid="apple-mobile-web-app-title"><meta data-n-head="true" content="Bowen" name="author" data-hid="author"><meta data-n-head="true" content="#24292e" name="theme-color" data-hid="theme-color"><meta data-n-head="true" content="website" name="og:type" data-hid="og:type" property="og:type"><meta data-n-head="true" content="Bowen Blog" name="og:title" data-hid="og:title" property="og:title"><meta data-n-head="true" content="A place which is used to share programming experiences" name="og:description" data-hid="og:description" property="og:description"><title data-n-head="true">理解 this 的指向 | Bowen Blog</title><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="/_nuxt/manifest.2108b1d4.json" rel="manifest" data-n-head="true"><link href="/_nuxt/icons/icon_64.e20A200w20w.png" rel="shortcut icon" data-n-head="true"><link href="/_nuxt/icons/icon_512.e20A200w20w.png" rel="apple-touch-icon" data-n-head="true" sizes="512x512"><link href="https://set.sh/blog/writings/keyword-this/" rel="alternate" data-n-head="true" hreflang="zh"><link href="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js" rel="preload" as="script"><link href="/_nuxt/vendor.13de21511613edf061b2.js" rel="preload" as="script"><link href="/_nuxt/app.5a4fa6b8fcf73db97515.js" rel="preload" as="script"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="preload" as="style"><link href="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js" rel="preload" as="script"><link href="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/tags/_id/index.edb9dbabb1b9c2ef81f2.js" rel="prefetch"><link href="/_nuxt/pages/index.1d0ac68e309be0e86168.js" rel="prefetch"><link href="/_nuxt/pages/blog/tags/index.2659d358b69abdfd34bf.js" rel="prefetch"><link href="/_nuxt/pages/blog/projects/index.3ff8e031c3cb4f25eaed.js" rel="prefetch"><link href="/_nuxt/pages/blog/writings/index.b016af22016e152b7231.js" rel="prefetch"><link href="/_nuxt/layouts/home.dd55e95df1c2109ebde6.js" rel="prefetch"><link href="/_nuxt/layouts/default.89ffa224d3d7769e4fbb.js" rel="prefetch"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="stylesheet"><body data-n-head=""><div id="__nuxt" data-server-rendered="true"><div class="nuxt-progress" style="width:0%;height:2px;background-color:#3eaf7c;opacity:0"></div><div id="__layout"><section class="blog sf__parent__clearfix" data-v-cac63c14><header class="header __position components-animation" data-v-13c46026 data-v-cac63c14><nav class="mobile-navigator" data-v-13c46026 data-v-d4cae7a6><label class="label-line" data-v-d4cae7a6><span class="__position label-line line-top" data-v-d4cae7a6><span class="__position line-crust line-crust-top" data-v-d4cae7a6></span></span><span class="__position label-line line-bottom" data-v-d4cae7a6><span class="__position line-crust line-crust-bottom" data-v-d4cae7a6></span></span></label></nav><nav class="navigator __position grid" data-v-13c46026 role="navigation"><a href="/" class="navigator-link hover-animation grid-cell" data-v-13c46026>HOME</a><a href="/blog/writings/" class="navigator-link hover-animation grid-cell" data-v-13c46026>WRITINGS</a><a href="/blog/projects/" class="navigator-link hover-animation grid-cell" data-v-13c46026>PROJECTS</a><a href="/blog/tags/" class="navigator-link hover-animation grid-cell" data-v-13c46026>TAGS</a><a href="https://github.com/lbwa" class="navigator-link hover-animation grid-cell" data-v-13c46026 rel="noopener" target="_blank">GITHUB</a></nav><div class="background-helper __position" data-v-13c46026></div></header><main class="articles-container wrapper sf__reference__layout" data-v-cac63c14 role="main"><article class="articles-main"><div class="article-header"><h1 class="article-title">理解 this 的指向</h1><span class="article-author">Bowen</span><span class="article-date">2018 FEB 06</span><div class="article-tags"><a href="/blog/tags/前端开发" class="article-tag">前端开发</a><a href="/blog/tags/javascript" class="article-tag">JavaScript</a></div></div><div class="article-content"><blockquote><p>The abstract operation ResolveThisBinding determines the binding of the keyword this using the LexicalEnvironment of the running execution context.</blockquote><p>JS 中的 <code>ResolveThisBinding</code> 操作将会绑定 <a href="https://www.ecma-international.org/ecma-262/#sec-resolvethisbinding" rel="noopener noreferrer" target="_blank">this<outboundlink></a>关键字为当前执行上下文的词法作用环境。<h2 id="es5中this的值"><a href="#es5中this的值" class="header-anchor" aria-hidden="true">#</a> ES5中this的值</h2><h3 id="定义：this，指函数的调用上下文。"><a href="#定义：this，指函数的调用上下文。" class="header-anchor" aria-hidden="true">#</a> 定义：this，指函数的调用上下文。</h3><p>在函数没有被调用的时候是无法确定函数中的this值的指向，只有当函数调用时才能确定函数中this值的指向。<p>当函数被调用时，理解this值的指向有以下四种情况（函数中存在this）：<p><strong>情况一</strong>：函数没有被上一级对象调用时，那么他函数体内的this值指向window。<p><strong>注</strong>：在严格模式中默认的this值不是window，而是undefined。<pre class="language-js" v-pre><code><span class="token keyword">let</span> <span class="token function-variable function">num</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
   a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// window</span>
</code></pre><p>在上面的函数中，定义了一个函数num，在调用函数时，实际上是调用的window的属性num。<p><strong>情况二</strong>：函数被上一级（一个）对象调用时，那么该this值指向的是调用的对象，即指向上一级对象。<pre class="language-js" v-pre><code><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
  fn<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
num<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// num</span>
</code></pre><p>在上面的代码中，fn只被对象num包围，在调用fn时，this指向调用fn的上一级对象，也就是对象num。<p><strong>情况三</strong>：函数外有多个对象包围时，尽管函数是被最外层的对象调用，那么函数中的this值只指向上一级对象。<pre class="language-js" v-pre><code><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
  b<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    fn<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
num<span class="token punctuation">.</span>b<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 对象b</span>
</code></pre><p>由上可知，函数fn被对象b包围，而b又是对象num的属性之一，尽管是最外层对象num调用了函数fn（执行了这个调用行为的开端），而函数fn中的this值只会指向离他最近的上一级对象，也就是对象b。<p><strong>情况四：先赋值，后执行</strong><pre class="language-js" v-pre><code><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token punctuation">{</span>
  a<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
  b<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    fn<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> digit <span class="token operator">=</span> num<span class="token punctuation">.</span>b<span class="token punctuation">.</span>fn
<span class="token function">digit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// window   与情况三的差别在于，先赋值，后调用</span>
</code></pre><p>this值始终指向最后调用它的对象，且只在调用函数时才能确定this的指向。这里首先是把num.b.fn函数赋值给digit，虽然fn是被对象b所引用，但并没有直接执行函数，而执行digit时才确定了this的指向，window调用了digit，所以指向window。<pre class="language-js" v-pre><code><span class="token keyword">var</span> length <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  length<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span>
  method<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 10</span>
    arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 2</span>
    fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token comment">// 5</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>在上面的示例中，<code>obj.method(fn, 1);</code>执行的本质是<code>fn();</code> <code>arguments[0]();</code> <code>fn.call(obj, 12);</code>这三句。先理解三个语句，因为单线程的缘故，所以是在method中给栈添加任务执行三个函数，此时，method任务执行完成，下一个任务执行调用fn，此时，没有显示的指定的对象调用fn，故fn中的this指向window，所以结果为10。下个任务<code>arguments[0]()</code>; 表示调用method的参数对象arguments的第一项并执行，此时，arguments对象（只是类数组，并非Array实例）开始调用它的第一项，即fn，此时，fn有显示的调用对象，即arguments对象，此时，fn中的this指向arguments对象，因为arguments对象有两项，故返回2。第三句，显示的指明this指向obj对象，故返回obj.length，即5。<p><strong>结论：</strong><ol><li><p>（个人理解）在函数a内执行函数b时，确切来说<strong>真正调用执行b的还是window对象</strong>，此时函数b内的this是指向window对象，函数a的作用是<strong>告知引擎添加一个执行b的任务</strong>。<li><p>当函数c是arguments对像的第 i 项时，<code>arguments[i]()</code>中的this指向的是arguments对象。</ol><p><strong>补充：</strong><p>在<code>《JavaScript语言精粹》修订版</code>P28中，对于没有显式的调用对象的函数调用，该被调用的函数内的this指向全局对象。作者认为这是JavaScript设计上的一个“错误”。<p>作者认为此时的函数调用中的this应该指向外部函数的this变量。其中当函数A内调用函数B时，首先执行函数A的语句，当执行到调用函数B语句时，暂停函数A内的语句执行，将控制权转交给函数B，先执行完函数B，然后再继续执行函数A（<code>《JavaScript语言精粹》修订版</code>P27）。<p><strong>构造函数中的this</strong><pre class="language-js" v-pre><code><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> <span class="token string">"Jack"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Jack</span>
</code></pre><p>根据官方文档<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" rel="noopener noreferrer" target="_blank">new运算符<outboundlink></a>中Description第2点的解释，使用new运算符调用构造函数时，构造函数中的this会指向实例化的对象。<p>实践也可证明：<pre class="language-js" v-pre><code><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span>  <span class="token string">'Jack'</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Foo {name:'Jack'}</span>
</code></pre><p>此时控制台返回对象Foo {name:'Jack'} 2次，一个是 console.log(this); 的返回值，一个是实例化的返回值，即 this 在实例化时指向了实例化的对象（或者理解为new运算符将构造函数中的this值绑定到实例化对象上）。<p><strong>结论</strong>：函数体中的this始终指向最后调用它的那个对象。在构造函数中，this指向实例化的对象。<h3 id="实例化时，构造函数的this是如何绑定到实例化对象的呢？"><a href="#实例化时，构造函数的this是如何绑定到实例化对象的呢？" class="header-anchor" aria-hidden="true">#</a> 实例化时，构造函数的this是如何绑定到实例化对象的呢？</h3><ul><li>据<code>《JavaScript高级程序设计》第三版</code>P145，解释如下：</ul><p>创建新实例时，必须使用new运算符，创建会经历以下四个阶段：<ol><li><p>创建一个新对象；<li><p>将构造函数和的作用域赋给新对象（因为这个新对象调用了构造函数，所以this就指向了这个新对象）；<li><p>执行构造函数中的代码（目的是为了给这个新对象添加属性）；<li><p>返回新对象。</ol><ul><li>据<code>《JavaScript语言精粹》修订版</code>P47，使用new操作符去调用一个函数时，函数的执行方式将被修改，可将new操作符理解为一个方法，则有:</ul><p>Note:<ol><li><p>下文Function.method(name,fn)表示给Function函数添加一个new的方法（method为书中自定义函数，并非JavaScript原生函数，表示给调用的对象添加一个名为name的方法（fn））<li><p>代码中的注释讨论的this是构造函数调用new这个方法时的this。</ol><p>代码如下：<pre class="language-js" v-pre><code>Function<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token string">'new'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 创建一个新对象（对象that）， that和构造函数共用同一个对象</span>
  <span class="token comment">// this 指向（与new连用的）构造函数，Object.create()创建一个以参数为原型对象的对象</span>
  <span class="token keyword">var</span> that <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 调用构造器函数，绑定 -this- 到新对象（指that）上</span>
  <span class="token comment">// 此处存在apply方法，this 指向（与new连用的）构造函数，则以下语句表示，that调用以</span>
  <span class="token comment">// arguments对象为参数对象的构造函数（指定构造函数中的this值为that），目的是给that</span>
  <span class="token comment">// 添加属性（或方法）</span>
  <span class="token comment">// 此处根据构造函数的函数体，函数体内可能有（或没有）return语句，则other可能是对象、</span>
  <span class="token comment">// 基本类型值、undefined、null</span>
  <span class="token keyword">var</span> other <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>that<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>

  <span class="token comment">// 如果它返回的不一个对象，就返回该(that)新对象，即优先返回构造函数中return语句返回</span>
  <span class="token comment">// 的对象，若return返回的不是对象，则忽视return返回值</span>
  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> other <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&&</span> other<span class="token punctuation">)</span> <span class="token operator">||</span> that<span class="token punctuation">;</span>    <span class="token comment">// 1.3解释</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>在以上代码中，that是一个中间对象，that的作用是执行Function构造函数，并将指向构造函数原型的指针复制给other（实例化对象）。<p>回到之前的代码：<pre class="language-js" v-pre><code><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> <span class="token string">"Jack"</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Jack</span>

</code></pre><p>由两本文献可知，实例化过程中，经历了以下过程：<p>（由<code>var a = new Fn();</code>可知变量a复制了指向Fn()实例对象的指针，以下就以变量a指代Fn的实例。）<ol><li><p>创建了一个新对象a（指向构建函数的原型对象），此时对象为空；<li><p>复制构造函数的作用域给新对象a；<li><p>然后执行构造函数，这是为了给新对象添加属性（因为在构造函数Fn中直接将属性赋给了this对象），那么是如何添加的呢？此时因为是新对象a调用了构造函数，所以构造函数内的this指向了新对象a，此时新对象a就获得了Fn的属性user；<li><p>返回新对象a。</ol><p>以上过程展示了在构造函数实例化的过程中，this的值是如何绑定在实例化的对象上的。<h3 id="在有-return-语句中的函数中-this-的值"><a href="#在有-return-语句中的函数中-this-的值" class="header-anchor" aria-hidden="true">#</a> 在有 return 语句中的函数中 this 的值</h3><p>(据1.2创建实例经历的四个阶段，可得当存在变量a等于{ user:"Jack"}时，可认为构造函数的this指向构造函数的实例。)<p>当函数的return语句返回一个对象时：<pre class="language-js" v-pre><code><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> <span class="token string">"Jack"</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回的不是Fn的实例</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undedined</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {} 此时a并没有继承Fn的user属性，可见Fn函数内this并未指向a</span>
</code></pre><p>当函数的return语句返回一个基本类型值时<pre class="language-js" v-pre><code><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> <span class="token string">"Jack"</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Jack"</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {user: "Jack"} 此时a继承Fn的user属性，可见Fn函数内this指向a</span>
</code></pre><p>当函数的return语句返回null时<pre class="language-js" v-pre><code><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> <span class="token string">"Jack"</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// null是特殊对象值，但此时this仍指向构造函数实例a</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Jack"</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//  {user: "Jack"} 此时a继承Fn的user属性，可见Fn函数内this指向a</span>
</code></pre><p><strong>结论</strong>：构造函数本身也是函数，所以可以设置return语句的返回值，那么当函数的return语句返回一个对象时，this会指向这个return语句返回的对象，不会指向函数的实例。当return语句返回一个基本类型值（或null）时，会忽略这个基本类型值，指向函数的实例。<h2 id="箭头函数（es6）中的-this-值"><a href="#箭头函数（es6）中的-this-值" class="header-anchor" aria-hidden="true">#</a> 箭头函数（ES6）中的 this 值</h2><p>箭头函数可以让this绑定定义时所在的作用域，而不是指向运行时所在的作用域。<pre class="language-js" v-pre><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'id:'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>

<span class="token keyword">var</span> id <span class="token operator">=</span> <span class="token number">21</span><span class="token punctuation">;</span>

foo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// id: 42</span>
</code></pre><p>在以上示例中，setTimeout参数中是一个箭头函数，定义生效时就是函数生成时，而真正的执行在100毫秒（因为JavaScript是单线程，所以在执行完foo后，由全局对象调用执行setTimeout参数中的函数）之后。若是普通函数的话，因为是全局对象调用，所以此时的this值指向window，foo.call({ id: 42 }); 返回21。在示例中，因为是箭头函数，所以this值在定义时就已经确定，总是指向定义生效时所在的对象，这里是{id:42}，所以返回 42。<p><strong>推广：箭头函数可以让this指向固定化，这种特性很有利于封装回调函数</strong>。<p>一次在实践单例的过程中遇到的问题：<p>简化代码如下：<pre class="language-js" v-pre><code><span class="token keyword">let</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">111</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        a<span class="token punctuation">:</span> a<span class="token punctuation">,</span>
        fn<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// window对象</span>
          <span class="token comment">// 在某个环境中读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代</span>
          <span class="token comment">// 表是什么。若找到，搜索停止。若没有，则该变量未声明</span>
          <span class="token comment">// fn中对变量a的赋值本质是，向上在作用域链中搜索，找到位于foo中的变量a，并在</span>
          <span class="token comment">// fn中对foo的变量a进行赋值</span>
          a <span class="token operator">=</span> <span class="token number">222</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        num<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo对象</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 222</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> ins <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ins<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ins<span class="token punctuation">.</span><span class="token function">num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>在以上箭头函数fn中，this指向函数定义时的外部环境。<p>实际上在箭头函数中，自身并没有this对象，它所使用的this是外层代码块的this。实际上箭头函数可以起到绑定this值的作用。<p><strong>推广：在箭头函数中，不存在真正属于他自己的this、arguments对象，因为不存在自己的this，所以不能使用call()、apply()、bind()方法修改箭头函数中的this值。</strong><p>若要让num方法中的this指向foo，就使用原有的function声明代替箭头函数。这样在调用num方法时，最后调用该方法的对象是foo，所以此时的num方法中的this指向foo。<pre class="language-js" v-pre><code><span class="token keyword">let</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">111</span><span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span>
        a<span class="token punctuation">:</span> a<span class="token punctuation">,</span>
        fn<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// window对象</span>
          a <span class="token operator">=</span> <span class="token number">222</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        num<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo对象</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 222</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> ins <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ins<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
ins<span class="token punctuation">.</span><span class="token function">num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><p>另外，<strong>要将作用域中的变量和对象的属性和区分开，作用域只与函数定义时的位置有关，与运行过程无关</strong>。在 num 方法中要输出变量 <code>a</code>，则先在当前 <code>num</code> 方法中寻找变量 <code>a</code>，若没有找到则沿着作用域链向上搜索变量 <code>a</code>，则在 foo 的活动对象中找到变量 <code>a</code>，然后返回输出变量 <code>a</code>。要注意的一个细节是，<code>a:111</code> 是 <code>foo</code> 的属性，不是变量，不要弄混淆了。</div></article><button data-v-e85d20b2 data-v-e85d20b2 class="floating-btn __position" style="display:none"><svg class="icon-rocket" data-v-e85d20b2 viewBox="0 0 512 512"><path d="M256 421.6c-18.1 0-33.2-6.8-42.9-10.9-5.4-2.3-11.3 1.8-10.9 7.6l3.5 51c.2 3.1 3.8 4.7 6.3 2.8l14.5-11c1.8-1.4 4.5-.9 5.7 1l20.5 32.1c1.5 2.4 5.1 2.4 6.6 0l20.5-32.1c1.2-1.9 3.9-2.4 5.7-1l14.5 11c2.5 1.9 6.1.3 6.3-2.8l3.5-51c.4-5.8-5.5-10-10.9-7.6-9.8 4.1-24.8 10.9-42.9 10.9z" data-v-e85d20b2></path><path d="M397.7 293.1l-48-49.1c0-158-93.2-228-93.2-228s-94.1 70-94.1 228l-48 49.1c-1.8 1.8-2.6 4.5-2.2 7.1L130.6 412c.9 5.7 7.1 8.5 11.8 5.4l67.1-45.4s20.7 20 47.1 20c26.4 0 46.1-20 46.1-20l67.1 45.4c4.6 3.1 10.8.3 11.8-5.4l18.5-111.9c.2-2.6-.6-5.2-2.4-7zM256.5 192c-17 0-30.7-14.3-30.7-32s13.8-32 30.7-32c17 0 30.7 14.3 30.7 32s-13.7 32-30.7 32z" data-v-e85d20b2></path></svg></button></main><footer class="blog-footer sf__main__layout grid col grid-jc-center" data-v-1044ad0a data-v-cac63c14><div class="footer-info" data-v-1044ad0a>Copyright © 2018 <a href="https://github.com/lbwa" class="author" rel="noopener" target="_blank" data-v-1044ad0a>Bowen</a></div></footer><section class="loading-wrapper grid col grid-center grid-jc-center" data-v-cac63c14 style="display:none"><div class="loading"><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div></div><a class="loading-tips">Loading</a></section></section></div></div><script type="text/javascript">window.__NUXT__={layout:"blog",data:[{menu:[{errno:0,to:"writings/dom-location",title:"获取 Element 在 document 中的位置信息",author:"Bowen",date:"2018 SEP 01",tags:["前端开发","CSS"]},{errno:0,to:"writings/spa-and-mpa",title:"SPA 与 MPA 的比较与优化",author:"Bowen",date:"2018 AUG 04",tags:["前端开发","SPA","MPA","skeleton"]},{errno:0,to:"writings/async-function-in-js",title:"Event loops 中的 AsyncFunction",author:"Bowen",date:"2018 JUL 26",tags:["JavaScript","async","事件循环"]},{errno:0,to:"writings/pwa-fundamentals",title:"PWA 基础",author:"Bowen",date:"2018 JUL 07",tags:["前端开发","PWA"]},{errno:0,to:"writings/js-design-pattern",title:"JS 设计模式",author:"Bowen",date:"2018 JUN 12",tags:["前端开发","设计模式"]},{errno:0,to:"writings/http-request",title:"HTTP 协议请求首部",author:"Bowen",date:"2018 JUN 08",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-response",title:"HTTP 协议响应首部",author:"Bowen",date:"2018 JUN 07",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-protocol",title:"HTTP 协议",author:"Bowen",date:"2018 JUN 06",tags:["前端开发","网络请求"]},{errno:0,to:"writings/execution-context",title:"JS 执行上下文",author:"Bowen",date:"2018 MAY 07",tags:["前端开发","JavaScript","执行上下文"]},{errno:0,to:"writings/vue-lifecycle-and-slots",title:"对 Vue 插槽和生命周期的一点思考",author:"Bowen",date:"2018 APR 24",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/learning-vue-unit-test",title:"总结如何进行单元测试",author:"Bowen",date:"2018 APR 21",tags:["前端开发","Vue.js","应用测试"]},{errno:0,to:"writings/cross-domain-solution",title:"客户端跨域解决方案",author:"Bowen",date:"2018 APR 19",tags:["前端开发","网络请求"]},{errno:0,to:"writings/css-bfc",title:"探究 BFC 以及闭合浮动原理",author:"Bowen",date:"2018 MAR 29",tags:["前端开发","CSS"]},{errno:0,to:"writings/vue.js-reusability-and-composition",title:"学习 Vue.js 可复用性和组合",author:"Bowen",date:"2018 MAR 12",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/event-loop",title:"解析 event loops",author:"Bowen",date:"2018 MAR 08",tags:["前端开发","JavaScript","事件循环"]},{errno:0,to:"writings/learning-vuex",title:"学习 vuex 基础",author:"Bowen",date:"2018 MAR 06",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/compare-commonjs-with-esm",title:"比较 CommonJS 与 ES6 Module 语法",author:"Bowen",date:"2018 FEB 27",tags:["前端开发","JavaScript","模块"]},{errno:0,to:"writings/learning-vuejs-essentials",title:"学习 Vue.js 基础",author:"Bowen",date:"2018 FEB 24",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/keyword-this",title:"理解 this 的指向",author:"Bowen",date:"2018 FEB 06",tags:["前端开发","JavaScript"]}]},{title:"理解 this 的指向",date:"2018 FEB 06",author:"Bowen",tags:["前端开发","JavaScript"],content:'<blockquote>\n<p>The abstract operation ResolveThisBinding determines the binding of the keyword this using the LexicalEnvironment of the running execution context.</p>\n</blockquote>\n<p>JS 中的 <code>ResolveThisBinding</code> 操作将会绑定 <a href="https://www.ecma-international.org/ecma-262/#sec-resolvethisbinding" target="_blank" rel="noopener noreferrer">this<OutboundLink/></a> 关键字为当前执行上下文的词法作用环境。</p>\n<h2 id="es5中this的值"><a class="header-anchor" href="#es5中this的值" aria-hidden="true">#</a> ES5中this的值</h2>\n<h3 id="定义：this，指函数的调用上下文。"><a class="header-anchor" href="#定义：this，指函数的调用上下文。" aria-hidden="true">#</a> 定义：this，指函数的调用上下文。</h3>\n<p>在函数没有被调用的时候是无法确定函数中的this值的指向，只有当函数调用时才能确定函数中this值的指向。</p>\n<p>当函数被调用时，理解this值的指向有以下四种情况（函数中存在this）：</p>\n<p><strong>情况一</strong>：函数没有被上一级对象调用时，那么他函数体内的this值指向window。</p>\n<p><strong>注</strong>：在严格模式中默认的this值不是window，而是undefined。</p>\n<pre v-pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">num</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n   a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>\n   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token function">num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// window</span>\n</code></pre>\n<p>在上面的函数中，定义了一个函数num，在调用函数时，实际上是调用的window的属性num。</p>\n<p><strong>情况二</strong>：函数被上一级（一个）对象调用时，那么该this值指向的是调用的对象，即指向上一级对象。</p>\n<pre v-pre class="language-js"><code><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token punctuation">{</span>\n  a<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>\n  fn<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nnum<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// num</span>\n</code></pre>\n<p>在上面的代码中，fn只被对象num包围，在调用fn时，this指向调用fn的上一级对象，也就是对象num。</p>\n<p><strong>情况三</strong>：函数外有多个对象包围时，尽管函数是被最外层的对象调用，那么函数中的this值只指向上一级对象。</p>\n<pre v-pre class="language-js"><code><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token punctuation">{</span>\n  a<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>\n  b<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    fn<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nnum<span class="token punctuation">.</span>b<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 对象b</span>\n</code></pre>\n<p>由上可知，函数fn被对象b包围，而b又是对象num的属性之一，尽管是最外层对象num调用了函数fn（执行了这个调用行为的开端），而函数fn中的this值只会指向离他最近的上一级对象，也就是对象b。</p>\n<p><strong>情况四：先赋值，后执行</strong></p>\n<pre v-pre class="language-js"><code><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token punctuation">{</span>\n  a<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>\n  b<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    fn<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> digit <span class="token operator">=</span> num<span class="token punctuation">.</span>b<span class="token punctuation">.</span>fn\n<span class="token function">digit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// window   与情况三的差别在于，先赋值，后调用</span>\n</code></pre>\n<p>this值始终指向最后调用它的对象，且只在调用函数时才能确定this的指向。这里首先是把num.b.fn函数赋值给digit，虽然fn是被对象b所引用，但并没有直接执行函数，而执行digit时才确定了this的指向，window调用了digit，所以指向window。</p>\n<pre v-pre class="language-js"><code><span class="token keyword">var</span> length <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>\n<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>length<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>\n  length<span class="token punctuation">:</span> <span class="token number">5</span><span class="token punctuation">,</span>\n  method<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>fn<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 10</span>\n    arguments<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 2</span>\n    fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">)</span> <span class="token comment">// 5</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\nobj<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n<p>在上面的示例中，<code>obj.method(fn, 1);</code>执行的本质是<code>fn();</code> <code>arguments[0]();</code> <code>fn.call(obj, 12);</code>这三句。先理解三个语句，因为单线程的缘故，所以是在method中给栈添加任务执行三个函数，此时，method任务执行完成，下一个任务执行调用fn，此时，没有显示的指定的对象调用fn，故fn中的this指向window，所以结果为10。下个任务<code>arguments[0]()</code>; 表示调用method的参数对象arguments的第一项并执行，此时，arguments对象（只是类数组，并非Array实例）开始调用它的第一项，即fn，此时，fn有显示的调用对象，即arguments对象，此时，fn中的this指向arguments对象，因为arguments对象有两项，故返回2。第三句，显示的指明this指向obj对象，故返回obj.length，即5。</p>\n<p><strong>结论：</strong></p>\n<ol>\n<li>\n<p>（个人理解）在函数a内执行函数b时，确切来说<strong>真正调用执行b的还是window对象</strong>，此时函数b内的this是指向window对象，函数a的作用是<strong>告知引擎添加一个执行b的任务</strong>。</p>\n</li>\n<li>\n<p>当函数c是arguments对像的第 i 项时，<code>arguments[i]()</code>中的this指向的是arguments对象。</p>\n</li>\n</ol>\n<p><strong>补充：</strong></p>\n<p>在<code>《JavaScript语言精粹》修订版</code>P28中，对于没有显式的调用对象的函数调用，该被调用的函数内的this指向全局对象。作者认为这是JavaScript设计上的一个“错误”。</p>\n<p>作者认为此时的函数调用中的this应该指向外部函数的this变量。其中当函数A内调用函数B时，首先执行函数A的语句，当执行到调用函数B语句时，暂停函数A内的语句执行，将控制权转交给函数B，先执行完函数B，然后再继续执行函数A（<code>《JavaScript语言精粹》修订版</code>P27）。</p>\n<p><strong>构造函数中的this</strong></p>\n<pre v-pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> <span class="token string">"Jack"</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Jack</span>\n</code></pre>\n<p>根据官方文档<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new" target="_blank" rel="noopener noreferrer">new运算符<OutboundLink/></a>中Description第2点的解释，使用new运算符调用构造函数时，构造函数中的this会指向实例化的对象。</p>\n<p>实践也可证明：</p>\n<pre v-pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span>  <span class="token string">\'Jack\'</span><span class="token punctuation">;</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Foo {name:\'Jack\'}</span>\n</code></pre>\n<p>此时控制台返回对象Foo {name:\'Jack\'} 2次，一个是 console.log(this); 的返回值，一个是实例化的返回值，即 this 在实例化时指向了实例化的对象（或者理解为new运算符将构造函数中的this值绑定到实例化对象上）。</p>\n<p><strong>结论</strong>：函数体中的this始终指向最后调用它的那个对象。在构造函数中，this指向实例化的对象。</p>\n<h3 id="实例化时，构造函数的this是如何绑定到实例化对象的呢？"><a class="header-anchor" href="#实例化时，构造函数的this是如何绑定到实例化对象的呢？" aria-hidden="true">#</a> 实例化时，构造函数的this是如何绑定到实例化对象的呢？</h3>\n<ul>\n<li>据<code>《JavaScript高级程序设计》第三版</code>P145，解释如下：</li>\n</ul>\n<p>创建新实例时，必须使用new运算符，创建会经历以下四个阶段：</p>\n<ol>\n<li>\n<p>创建一个新对象；</p>\n</li>\n<li>\n<p>将构造函数和的作用域赋给新对象（因为这个新对象调用了构造函数，所以this就指向了这个新对象）；</p>\n</li>\n<li>\n<p>执行构造函数中的代码（目的是为了给这个新对象添加属性）；</p>\n</li>\n<li>\n<p>返回新对象。</p>\n</li>\n</ol>\n<ul>\n<li>据<code>《JavaScript语言精粹》修订版</code>P47，使用new操作符去调用一个函数时，函数的执行方式将被修改，可将new操作符理解为一个方法，则有:</li>\n</ul>\n<p>Note:</p>\n<ol>\n<li>\n<p>下文Function.method(name,fn)表示给Function函数添加一个new的方法（method为书中自定义函数，并非JavaScript原生函数，表示给调用的对象添加一个名为name的方法（fn））</p>\n</li>\n<li>\n<p>代码中的注释讨论的this是构造函数调用new这个方法时的this。</p>\n</li>\n</ol>\n<p>代码如下：</p>\n<pre v-pre class="language-js"><code>Function<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token string">\'new\'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 创建一个新对象（对象that）， that和构造函数共用同一个对象</span>\n  <span class="token comment">// this 指向（与new连用的）构造函数，Object.create()创建一个以参数为原型对象的对象</span>\n  <span class="token keyword">var</span> that <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// 调用构造器函数，绑定 -this- 到新对象（指that）上</span>\n  <span class="token comment">// 此处存在apply方法，this 指向（与new连用的）构造函数，则以下语句表示，that调用以</span>\n  <span class="token comment">// arguments对象为参数对象的构造函数（指定构造函数中的this值为that），目的是给that</span>\n  <span class="token comment">// 添加属性（或方法）</span>\n  <span class="token comment">// 此处根据构造函数的函数体，函数体内可能有（或没有）return语句，则other可能是对象、</span>\n  <span class="token comment">// 基本类型值、undefined、null</span>\n  <span class="token keyword">var</span> other <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>that<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>\n\n  <span class="token comment">// 如果它返回的不一个对象，就返回该(that)新对象，即优先返回构造函数中return语句返回</span>\n  <span class="token comment">// 的对象，若return返回的不是对象，则忽视return返回值</span>\n  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> other <span class="token operator">===</span> <span class="token string">\'object\'</span> <span class="token operator">&amp;&amp;</span> other<span class="token punctuation">)</span> <span class="token operator">||</span> that<span class="token punctuation">;</span>    <span class="token comment">// 1.3解释</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>在以上代码中，that是一个中间对象，that的作用是执行Function构造函数，并将指向构造函数原型的指针复制给other（实例化对象）。</p>\n<p>回到之前的代码：</p>\n<pre v-pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> <span class="token string">"Jack"</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Jack</span>\n\n</code></pre>\n<p>由两本文献可知，实例化过程中，经历了以下过程：</p>\n<p>（由<code>var a = new Fn();</code>可知变量a复制了指向Fn()实例对象的指针，以下就以变量a指代Fn的实例。）</p>\n<ol>\n<li>\n<p>创建了一个新对象a（指向构建函数的原型对象），此时对象为空；</p>\n</li>\n<li>\n<p>复制构造函数的作用域给新对象a；</p>\n</li>\n<li>\n<p>然后执行构造函数，这是为了给新对象添加属性（因为在构造函数Fn中直接将属性赋给了this对象），那么是如何添加的呢？此时因为是新对象a调用了构造函数，所以构造函数内的this指向了新对象a，此时新对象a就获得了Fn的属性user；</p>\n</li>\n<li>\n<p>返回新对象a。</p>\n</li>\n</ol>\n<p>以上过程展示了在构造函数实例化的过程中，this的值是如何绑定在实例化的对象上的。</p>\n<h3 id="在有-return-语句中的函数中-this-的值"><a class="header-anchor" href="#在有-return-语句中的函数中-this-的值" aria-hidden="true">#</a> 在有 return 语句中的函数中 this 的值</h3>\n<p>(据1.2创建实例经历的四个阶段，可得当存在变量a等于{ user:&quot;Jack&quot;}时，可认为构造函数的this指向构造函数的实例。)</p>\n<p>当函数的return语句返回一个对象时：</p>\n<pre v-pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> <span class="token string">"Jack"</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 返回的不是Fn的实例</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// undedined</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {} 此时a并没有继承Fn的user属性，可见Fn函数内this并未指向a</span>\n</code></pre>\n<p>当函数的return语句返回一个基本类型值时</p>\n<pre v-pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> <span class="token string">"Jack"</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Jack"</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// {user: "Jack"} 此时a继承Fn的user属性，可见Fn函数内this指向a</span>\n</code></pre>\n<p>当函数的return语句返回null时</p>\n<pre v-pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span>user <span class="token operator">=</span> <span class="token string">"Jack"</span><span class="token punctuation">;</span>\n    <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// null是特殊对象值，但此时this仍指向构造函数实例a</span>\n<span class="token punctuation">}</span>\n<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// "Jack"</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//  {user: "Jack"} 此时a继承Fn的user属性，可见Fn函数内this指向a</span>\n</code></pre>\n<p><strong>结论</strong>：构造函数本身也是函数，所以可以设置return语句的返回值，那么当函数的return语句返回一个对象时，this会指向这个return语句返回的对象，不会指向函数的实例。当return语句返回一个基本类型值（或null）时，会忽略这个基本类型值，指向函数的实例。</p>\n<h2 id="箭头函数（es6）中的-this-值"><a class="header-anchor" href="#箭头函数（es6）中的-this-值" aria-hidden="true">#</a> 箭头函数（ES6）中的 this 值</h2>\n<p>箭头函数可以让this绑定定义时所在的作用域，而不是指向运行时所在的作用域。</p>\n<pre v-pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'id:\'</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>\n\n<span class="token keyword">var</span> id <span class="token operator">=</span> <span class="token number">21</span><span class="token punctuation">;</span>\n\nfoo<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">{</span> id<span class="token punctuation">:</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// id: 42</span>\n</code></pre>\n<p>在以上示例中，setTimeout参数中是一个箭头函数，定义生效时就是函数生成时，而真正的执行在100毫秒（因为JavaScript是单线程，所以在执行完foo后，由全局对象调用执行setTimeout参数中的函数）之后。若是普通函数的话，因为是全局对象调用，所以此时的this值指向window，foo.call({ id: 42 }); 返回21。在示例中，因为是箭头函数，所以this值在定义时就已经确定，总是指向定义生效时所在的对象，这里是{id:42}，所以返回 42。</p>\n<p><strong>推广：箭头函数可以让this指向固定化，这种特性很有利于封装回调函数</strong>。</p>\n<p>一次在实践单例的过程中遇到的问题：</p>\n<p>简化代码如下：</p>\n<pre v-pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">111</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> <span class="token punctuation">{</span>\n        a<span class="token punctuation">:</span> a<span class="token punctuation">,</span>\n        fn<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// window对象</span>\n          <span class="token comment">// 在某个环境中读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代</span>\n          <span class="token comment">// 表是什么。若找到，搜索停止。若没有，则该变量未声明</span>\n          <span class="token comment">// fn中对变量a的赋值本质是，向上在作用域链中搜索，找到位于foo中的变量a，并在</span>\n          <span class="token comment">// fn中对foo的变量a进行赋值</span>\n          a <span class="token operator">=</span> <span class="token number">222</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n        num<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo对象</span>\n          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 222</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> ins <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nins<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nins<span class="token punctuation">.</span><span class="token function">num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n<p>在以上箭头函数fn中，this指向函数定义时的外部环境。</p>\n<p>实际上在箭头函数中，自身并没有this对象，它所使用的this是外层代码块的this。实际上箭头函数可以起到绑定this值的作用。</p>\n<p><strong>推广：在箭头函数中，不存在真正属于他自己的this、arguments对象，因为不存在自己的this，所以不能使用call()、apply()、bind()方法修改箭头函数中的this值。</strong></p>\n<p>若要让num方法中的this指向foo，就使用原有的function声明代替箭头函数。这样在调用num方法时，最后调用该方法的对象是foo，所以此时的num方法中的this指向foo。</p>\n<pre v-pre class="language-js"><code><span class="token keyword">let</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">111</span><span class="token punctuation">;</span>\n      <span class="token keyword">return</span> <span class="token punctuation">{</span>\n        a<span class="token punctuation">:</span> a<span class="token punctuation">,</span>\n        fn<span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// window对象</span>\n          a <span class="token operator">=</span> <span class="token number">222</span><span class="token punctuation">;</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span>\n        num<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// foo对象</span>\n          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 222</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span><span class="token punctuation">;</span>\n<span class="token keyword">let</span> ins <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nins<span class="token punctuation">.</span><span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\nins<span class="token punctuation">.</span><span class="token function">num</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n</code></pre>\n<p>另外，<strong>要将作用域中的变量和对象的属性和区分开，作用域只与函数定义时的位置有关，与运行过程无关</strong>。在 num 方法中要输出变量 <code>a</code>，则先在当前 <code>num</code> 方法中寻找变量 <code>a</code>，若没有找到则沿着作用域链向上搜索变量 <code>a</code>，则在 foo 的活动对象中找到变量 <code>a</code>，然后返回输出变量 <code>a</code>。要注意的一个细节是，<code>a:111</code> 是 <code>foo</code> 的属性，不是变量，不要弄混淆了。</p>\n'}],error:null,serverRendered:!0}</script><script defer src="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js"></script><script defer src="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js"></script><script defer src="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js"></script><script defer src="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js"></script><script defer src="/_nuxt/vendor.13de21511613edf061b2.js"></script><script defer src="/_nuxt/app.5a4fa6b8fcf73db97515.js"></script>