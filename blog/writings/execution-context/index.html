<!doctype html><html data-n-head="lang" data-n-head-ssr lang="zh"><meta data-n-head="true" content="IE=edge,chrome=1" http-equiv='"X-UA-Compatible'><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" name="viewport"><meta data-n-head="true" content="bowen blog, bowen 博客, vuejs, reactjs, ssr, 前端开发, 前端 , web开发, nodejs, github" name="keywords"><meta data-n-head="true" content="一个分享代码经历的地方" name="description" data-hid="description"><meta data-n-head="true" content="yes" name="apple-mobile-web-app-capable"><meta data-n-head="true" content="black" name="apple-mobile-web-app-status-bar-style"><meta data-n-head="true" content="yes" name="mobile-web-app-capable" data-hid="mobile-web-app-capable"><meta data-n-head="true" content="Bowen Blog" name="apple-mobile-web-app-title" data-hid="apple-mobile-web-app-title"><meta data-n-head="true" content="Bowen" name="author" data-hid="author"><meta data-n-head="true" content="#24292e" name="theme-color" data-hid="theme-color"><meta data-n-head="true" content="website" name="og:type" data-hid="og:type" property="og:type"><meta data-n-head="true" content="Bowen Blog" name="og:title" data-hid="og:title" property="og:title"><meta data-n-head="true" content="A place which is used to share programming experiences" name="og:description" data-hid="og:description" property="og:description"><title data-n-head="true">JS 执行上下文 | Bowen Blog</title><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="/_nuxt/manifest.2108b1d4.json" rel="manifest" data-n-head="true"><link href="/_nuxt/icons/icon_64.e20A200w20w.png" rel="shortcut icon" data-n-head="true"><link href="/_nuxt/icons/icon_512.e20A200w20w.png" rel="apple-touch-icon" data-n-head="true" sizes="512x512"><link href="https://set.sh/blog/writings/execution-context/" rel="alternate" data-n-head="true" hreflang="zh"><link href="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js" rel="preload" as="script"><link href="/_nuxt/vendor.13de21511613edf061b2.js" rel="preload" as="script"><link href="/_nuxt/app.5a4fa6b8fcf73db97515.js" rel="preload" as="script"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="preload" as="style"><link href="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js" rel="preload" as="script"><link href="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/tags/_id/index.edb9dbabb1b9c2ef81f2.js" rel="prefetch"><link href="/_nuxt/pages/index.1d0ac68e309be0e86168.js" rel="prefetch"><link href="/_nuxt/pages/blog/tags/index.2659d358b69abdfd34bf.js" rel="prefetch"><link href="/_nuxt/pages/blog/projects/index.3ff8e031c3cb4f25eaed.js" rel="prefetch"><link href="/_nuxt/pages/blog/writings/index.b016af22016e152b7231.js" rel="prefetch"><link href="/_nuxt/layouts/home.dd55e95df1c2109ebde6.js" rel="prefetch"><link href="/_nuxt/layouts/default.89ffa224d3d7769e4fbb.js" rel="prefetch"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="stylesheet"><body data-n-head=""><div id="__nuxt" data-server-rendered="true"><div class="nuxt-progress" style="width:0%;height:2px;background-color:#3eaf7c;opacity:0"></div><div id="__layout"><section class="blog sf__parent__clearfix" data-v-cac63c14><header class="header __position components-animation" data-v-13c46026 data-v-cac63c14><nav class="mobile-navigator" data-v-13c46026 data-v-d4cae7a6><label class="label-line" data-v-d4cae7a6><span class="__position label-line line-top" data-v-d4cae7a6><span class="__position line-crust line-crust-top" data-v-d4cae7a6></span></span><span class="__position label-line line-bottom" data-v-d4cae7a6><span class="__position line-crust line-crust-bottom" data-v-d4cae7a6></span></span></label></nav><nav class="navigator __position grid" data-v-13c46026 role="navigation"><a href="/" class="navigator-link hover-animation grid-cell" data-v-13c46026>HOME</a><a href="/blog/writings/" class="navigator-link hover-animation grid-cell" data-v-13c46026>WRITINGS</a><a href="/blog/projects/" class="navigator-link hover-animation grid-cell" data-v-13c46026>PROJECTS</a><a href="/blog/tags/" class="navigator-link hover-animation grid-cell" data-v-13c46026>TAGS</a><a href="https://github.com/lbwa" class="navigator-link hover-animation grid-cell" data-v-13c46026 rel="noopener" target="_blank">GITHUB</a></nav><div class="background-helper __position" data-v-13c46026></div></header><main class="articles-container wrapper sf__reference__layout" data-v-cac63c14 role="main"><article class="articles-main"><div class="article-header"><h1 class="article-title">JS 执行上下文</h1><span class="article-author">Bowen</span><span class="article-date">2018 MAY 07</span><div class="article-tags"><a href="/blog/tags/前端开发" class="article-tag">前端开发</a><a href="/blog/tags/javascript" class="article-tag">JavaScript</a><a href="/blog/tags/执行上下文" class="article-tag">执行上下文</a></div></div><div class="article-content"><p>本文主要讲述在事件循环中，每一个宏任务或每一个微任务是如何被具体执行的。即被推入执行上下文栈（<code>execution context stack</code>，亦称调用栈 <code>call stack</code>）的代码是如何被具体执行的。<h2 id="执行上下文定义"><a href="#执行上下文定义" class="header-anchor" aria-hidden="true">#</a> 执行上下文定义</h2><p>执行上下文（<code>execution context</code>（<a href="https://www.ecma-international.org/ecma-262/#sec-execution-contexts" rel="noopener noreferrer" target="_blank">ECMAScript<outboundlink></a>））用于<strong>追踪代码的执行</strong>。在任何时候在一个客户端中<strong>最多</strong>只存在一个当前<strong>正在执行</strong>代码的执行上下文，并且被称作客户端的 <strong>当前执行上下文</strong>（<code>running execution context</code>）。<h2 id="执行上下文栈（亦称调用栈）定义"><a href="#执行上下文栈（亦称调用栈）定义" class="header-anchor" aria-hidden="true">#</a> 执行上下文栈（亦称调用栈）定义</h2><p>执行上下文栈（<code>execution context stack</code>，亦称调用栈 <code>call stack</code>）用于追踪执行上下文。当前执行上下文总是执行上下文栈中最上层的那一个执行上下文。<p>注：<ul><li><p>执行上下文栈即是执行上下文的<strong>容器</strong>。<p><img alt="execution-context" src="https://assets.set.sh/2018/180507-execution-context/execution-context.svg"></ul><h2 id="running-execution-context-的更替"><a href="#running-execution-context-的更替" class="header-anchor" aria-hidden="true">#</a> Running execution context 的更替</h2><p>（<a href="https://www.ecma-international.org/ecma-262/#sec-execution-contexts" rel="noopener noreferrer" target="_blank">来源<outboundlink></a>）<blockquote><p>A new execution context is created whenever control is transferred from the executable code associated with the currently running execution context to executable code that is not associated with that execution context.The newly created execution context is pushed onto the stack and becomes the running execution context.</blockquote><p>（<a href="https://www.ecma-international.org/ecma-262/#table-22" rel="noopener noreferrer" target="_blank">来源<outboundlink></a>）<blockquote><p>Once the running execution context has been suspended a different execution context may become the running execution context and commence evaluating its code. At some later time a suspended execution context may again become the running execution context and continue evaluating its code at the point where it had previously been suspended.</blockquote><ol><li><p>从当前运行的执行上下文相关联的可执行代码转移控制权（<code>control</code>，可理解为执行权）到与该执行上下文不相关的可执行代码时，就会创建新的执行上下文。<ul><li>可理解为在一个函数中调用另一个函数时，就会创建一个新的执行上下文。</ul><li><p>新的执行上下文将会<strong>代替</strong>之前的执行上下文成为当前执行的执行上下文（<code>running execution context</code>）并推入执行上下文栈中（<code>execution context stack</code>）。<li><p>之前的执行上下文将会进入<code>冻结</code>状态（<code>suspended</code>）（<a href="https://www.ecma-international.org/ecma-262/#table-22" rel="noopener noreferrer" target="_blank">来源<outboundlink></a>），并等待新的执行上下文执行完成。待新的执行上下文执行完成将会恢复之前的执行上下文的执行。</ol><p>以上可以解释 <code>JavaScript 语言精粹</code> P27中，作者介绍到，在一个函数（称为 a）中调用一个函数（称为 b）时，a 会暂停执行，进入 <code>冻结</code> 状态，并将当前执行权转移给函数 b。待 b 执行完成后，执行权由 b 回到 a，这样 a 得以继续恢复执行接下来的代码。</div></article><button data-v-e85d20b2 data-v-e85d20b2 class="floating-btn __position" style="display:none"><svg class="icon-rocket" data-v-e85d20b2 viewBox="0 0 512 512"><path d="M256 421.6c-18.1 0-33.2-6.8-42.9-10.9-5.4-2.3-11.3 1.8-10.9 7.6l3.5 51c.2 3.1 3.8 4.7 6.3 2.8l14.5-11c1.8-1.4 4.5-.9 5.7 1l20.5 32.1c1.5 2.4 5.1 2.4 6.6 0l20.5-32.1c1.2-1.9 3.9-2.4 5.7-1l14.5 11c2.5 1.9 6.1.3 6.3-2.8l3.5-51c.4-5.8-5.5-10-10.9-7.6-9.8 4.1-24.8 10.9-42.9 10.9z" data-v-e85d20b2></path><path d="M397.7 293.1l-48-49.1c0-158-93.2-228-93.2-228s-94.1 70-94.1 228l-48 49.1c-1.8 1.8-2.6 4.5-2.2 7.1L130.6 412c.9 5.7 7.1 8.5 11.8 5.4l67.1-45.4s20.7 20 47.1 20c26.4 0 46.1-20 46.1-20l67.1 45.4c4.6 3.1 10.8.3 11.8-5.4l18.5-111.9c.2-2.6-.6-5.2-2.4-7zM256.5 192c-17 0-30.7-14.3-30.7-32s13.8-32 30.7-32c17 0 30.7 14.3 30.7 32s-13.7 32-30.7 32z" data-v-e85d20b2></path></svg></button></main><footer class="blog-footer sf__main__layout grid col grid-jc-center" data-v-1044ad0a data-v-cac63c14><div class="footer-info" data-v-1044ad0a>Copyright © 2018 <a href="https://github.com/lbwa" class="author" rel="noopener" target="_blank" data-v-1044ad0a>Bowen</a></div></footer><section class="loading-wrapper grid col grid-center grid-jc-center" data-v-cac63c14 style="display:none"><div class="loading"><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div></div><a class="loading-tips">Loading</a></section></section></div></div><script type="text/javascript">window.__NUXT__={layout:"blog",data:[{menu:[{errno:0,to:"writings/dom-location",title:"获取 Element 在 document 中的位置信息",author:"Bowen",date:"2018 SEP 01",tags:["前端开发","CSS"]},{errno:0,to:"writings/spa-and-mpa",title:"SPA 与 MPA 的比较与优化",author:"Bowen",date:"2018 AUG 04",tags:["前端开发","SPA","MPA","skeleton"]},{errno:0,to:"writings/async-function-in-js",title:"Event loops 中的 AsyncFunction",author:"Bowen",date:"2018 JUL 26",tags:["JavaScript","async","事件循环"]},{errno:0,to:"writings/pwa-fundamentals",title:"PWA 基础",author:"Bowen",date:"2018 JUL 07",tags:["前端开发","PWA"]},{errno:0,to:"writings/js-design-pattern",title:"JS 设计模式",author:"Bowen",date:"2018 JUN 12",tags:["前端开发","设计模式"]},{errno:0,to:"writings/http-request",title:"HTTP 协议请求首部",author:"Bowen",date:"2018 JUN 08",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-response",title:"HTTP 协议响应首部",author:"Bowen",date:"2018 JUN 07",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-protocol",title:"HTTP 协议",author:"Bowen",date:"2018 JUN 06",tags:["前端开发","网络请求"]},{errno:0,to:"writings/execution-context",title:"JS 执行上下文",author:"Bowen",date:"2018 MAY 07",tags:["前端开发","JavaScript","执行上下文"]},{errno:0,to:"writings/vue-lifecycle-and-slots",title:"对 Vue 插槽和生命周期的一点思考",author:"Bowen",date:"2018 APR 24",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/learning-vue-unit-test",title:"总结如何进行单元测试",author:"Bowen",date:"2018 APR 21",tags:["前端开发","Vue.js","应用测试"]},{errno:0,to:"writings/cross-domain-solution",title:"客户端跨域解决方案",author:"Bowen",date:"2018 APR 19",tags:["前端开发","网络请求"]},{errno:0,to:"writings/css-bfc",title:"探究 BFC 以及闭合浮动原理",author:"Bowen",date:"2018 MAR 29",tags:["前端开发","CSS"]},{errno:0,to:"writings/vue.js-reusability-and-composition",title:"学习 Vue.js 可复用性和组合",author:"Bowen",date:"2018 MAR 12",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/event-loop",title:"解析 event loops",author:"Bowen",date:"2018 MAR 08",tags:["前端开发","JavaScript","事件循环"]},{errno:0,to:"writings/learning-vuex",title:"学习 vuex 基础",author:"Bowen",date:"2018 MAR 06",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/compare-commonjs-with-esm",title:"比较 CommonJS 与 ES6 Module 语法",author:"Bowen",date:"2018 FEB 27",tags:["前端开发","JavaScript","模块"]},{errno:0,to:"writings/learning-vuejs-essentials",title:"学习 Vue.js 基础",author:"Bowen",date:"2018 FEB 24",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/keyword-this",title:"理解 this 的指向",author:"Bowen",date:"2018 FEB 06",tags:["前端开发","JavaScript"]}]},{title:"JS 执行上下文",date:"2018 MAY 07",author:"Bowen",tags:["前端开发","JavaScript","执行上下文"],content:'<p>本文主要讲述在事件循环中，每一个宏任务或每一个微任务是如何被具体执行的。即被推入执行上下文栈（<code>execution context stack</code>，亦称调用栈 <code>call stack</code>）的代码是如何被具体执行的。</p>\n<h2 id="执行上下文定义"><a class="header-anchor" href="#执行上下文定义" aria-hidden="true">#</a> 执行上下文定义</h2>\n<p>执行上下文（<code>execution context</code>（<a href="https://www.ecma-international.org/ecma-262/#sec-execution-contexts" target="_blank" rel="noopener noreferrer">ECMAScript<OutboundLink/></a>））用于<strong>追踪代码的执行</strong>。在任何时候在一个客户端中<strong>最多</strong>只存在一个当前<strong>正在执行</strong>代码的执行上下文，并且被称作客户端的 <strong>当前执行上下文</strong>（<code>running execution context</code>）。</p>\n<h2 id="执行上下文栈（亦称调用栈）定义"><a class="header-anchor" href="#执行上下文栈（亦称调用栈）定义" aria-hidden="true">#</a> 执行上下文栈（亦称调用栈）定义</h2>\n<p>执行上下文栈（<code>execution context stack</code>，亦称调用栈 <code>call stack</code>）用于追踪执行上下文。当前执行上下文总是执行上下文栈中最上层的那一个执行上下文。</p>\n<p>注：</p>\n<ul>\n<li>\n<p>执行上下文栈即是执行上下文的<strong>容器</strong>。</p>\n<p><img src="https://assets.set.sh/2018/180507-execution-context/execution-context.svg" alt="execution-context"></p>\n</li>\n</ul>\n<h2 id="running-execution-context-的更替"><a class="header-anchor" href="#running-execution-context-的更替" aria-hidden="true">#</a> Running execution context 的更替</h2>\n<p>（<a href="https://www.ecma-international.org/ecma-262/#sec-execution-contexts" target="_blank" rel="noopener noreferrer">来源<OutboundLink/></a>）</p>\n<blockquote>\n<p>A new execution context is created whenever control is transferred from the executable code associated with the currently running execution context to executable code that is not associated with that execution context.The newly created execution context is pushed onto the stack and becomes the running execution context.</p>\n</blockquote>\n<p>（<a href="https://www.ecma-international.org/ecma-262/#table-22" target="_blank" rel="noopener noreferrer">来源<OutboundLink/></a>）</p>\n<blockquote>\n<p>Once the running execution context has been suspended a different execution context may become the running execution context and commence evaluating its code. At some later time a suspended execution context may again become the running execution context and continue evaluating its code at the point where it had previously been suspended.</p>\n</blockquote>\n<ol>\n<li>\n<p>从当前运行的执行上下文相关联的可执行代码转移控制权（<code>control</code>，可理解为执行权）到与该执行上下文不相关的可执行代码时，就会创建新的执行上下文。</p>\n<ul>\n<li>可理解为在一个函数中调用另一个函数时，就会创建一个新的执行上下文。</li>\n</ul>\n</li>\n<li>\n<p>新的执行上下文将会<strong>代替</strong>之前的执行上下文成为当前执行的执行上下文（<code>running execution context</code>）并推入执行上下文栈中（<code>execution context stack</code>）。</p>\n</li>\n<li>\n<p>之前的执行上下文将会进入<code>冻结</code>状态（<code>suspended</code>）（<a href="https://www.ecma-international.org/ecma-262/#table-22" target="_blank" rel="noopener noreferrer">来源<OutboundLink/></a>），并等待新的执行上下文执行完成。待新的执行上下文执行完成将会恢复之前的执行上下文的执行。</p>\n</li>\n</ol>\n<p>以上可以解释 <code>JavaScript 语言精粹</code> P27中，作者介绍到，在一个函数（称为 a）中调用一个函数（称为 b）时，a 会暂停执行，进入 <code>冻结</code> 状态，并将当前执行权转移给函数 b。待 b 执行完成后，执行权由 b 回到 a，这样 a 得以继续恢复执行接下来的代码。</p>\n'}],error:null,serverRendered:!0}</script><script defer src="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js"></script><script defer src="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js"></script><script defer src="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js"></script><script defer src="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js"></script><script defer src="/_nuxt/vendor.13de21511613edf061b2.js"></script><script defer src="/_nuxt/app.5a4fa6b8fcf73db97515.js"></script>