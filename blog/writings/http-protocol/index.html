<!doctype html><html data-n-head="lang" data-n-head-ssr lang="zh"><meta data-n-head="true" content="IE=edge,chrome=1" http-equiv='"X-UA-Compatible'><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" name="viewport"><meta data-n-head="true" content="bowen blog, bowen 博客, vuejs, reactjs, ssr, 前端开发, 前端 , web开发, nodejs, github" name="keywords"><meta data-n-head="true" content="一个分享代码经历的地方" name="description" data-hid="description"><meta data-n-head="true" content="yes" name="apple-mobile-web-app-capable"><meta data-n-head="true" content="black" name="apple-mobile-web-app-status-bar-style"><meta data-n-head="true" content="yes" name="mobile-web-app-capable" data-hid="mobile-web-app-capable"><meta data-n-head="true" content="Bowen Blog" name="apple-mobile-web-app-title" data-hid="apple-mobile-web-app-title"><meta data-n-head="true" content="Bowen" name="author" data-hid="author"><meta data-n-head="true" content="#24292e" name="theme-color" data-hid="theme-color"><meta data-n-head="true" content="website" name="og:type" data-hid="og:type" property="og:type"><meta data-n-head="true" content="Bowen Blog" name="og:title" data-hid="og:title" property="og:title"><meta data-n-head="true" content="A place which is used to share programming experiences" name="og:description" data-hid="og:description" property="og:description"><title data-n-head="true">HTTP 协议 | Bowen Blog</title><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="/_nuxt/manifest.2108b1d4.json" rel="manifest" data-n-head="true"><link href="/_nuxt/icons/icon_64.e20A200w20w.png" rel="shortcut icon" data-n-head="true"><link href="/_nuxt/icons/icon_512.e20A200w20w.png" rel="apple-touch-icon" data-n-head="true" sizes="512x512"><link href="https://set.sh/blog/writings/http-protocol/" rel="alternate" data-n-head="true" hreflang="zh"><link href="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js" rel="preload" as="script"><link href="/_nuxt/vendor.13de21511613edf061b2.js" rel="preload" as="script"><link href="/_nuxt/app.5a4fa6b8fcf73db97515.js" rel="preload" as="script"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="preload" as="style"><link href="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js" rel="preload" as="script"><link href="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/tags/_id/index.edb9dbabb1b9c2ef81f2.js" rel="prefetch"><link href="/_nuxt/pages/index.1d0ac68e309be0e86168.js" rel="prefetch"><link href="/_nuxt/pages/blog/tags/index.2659d358b69abdfd34bf.js" rel="prefetch"><link href="/_nuxt/pages/blog/projects/index.3ff8e031c3cb4f25eaed.js" rel="prefetch"><link href="/_nuxt/pages/blog/writings/index.b016af22016e152b7231.js" rel="prefetch"><link href="/_nuxt/layouts/home.dd55e95df1c2109ebde6.js" rel="prefetch"><link href="/_nuxt/layouts/default.89ffa224d3d7769e4fbb.js" rel="prefetch"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="stylesheet"><body data-n-head=""><div id="__nuxt" data-server-rendered="true"><div class="nuxt-progress" style="width:0%;height:2px;background-color:#3eaf7c;opacity:0"></div><div id="__layout"><section class="blog sf__parent__clearfix" data-v-cac63c14><header class="header __position components-animation" data-v-13c46026 data-v-cac63c14><nav class="mobile-navigator" data-v-13c46026 data-v-d4cae7a6><label class="label-line" data-v-d4cae7a6><span class="__position label-line line-top" data-v-d4cae7a6><span class="__position line-crust line-crust-top" data-v-d4cae7a6></span></span><span class="__position label-line line-bottom" data-v-d4cae7a6><span class="__position line-crust line-crust-bottom" data-v-d4cae7a6></span></span></label></nav><nav class="navigator __position grid" data-v-13c46026 role="navigation"><a href="/" class="navigator-link hover-animation grid-cell" data-v-13c46026>HOME</a><a href="/blog/writings/" class="navigator-link hover-animation grid-cell" data-v-13c46026>WRITINGS</a><a href="/blog/projects/" class="navigator-link hover-animation grid-cell" data-v-13c46026>PROJECTS</a><a href="/blog/tags/" class="navigator-link hover-animation grid-cell" data-v-13c46026>TAGS</a><a href="https://github.com/lbwa" class="navigator-link hover-animation grid-cell" data-v-13c46026 rel="noopener" target="_blank">GITHUB</a></nav><div class="background-helper __position" data-v-13c46026></div></header><main class="articles-container wrapper sf__reference__layout" data-v-cac63c14 role="main"><article class="articles-main"><div class="article-header"><h1 class="article-title">HTTP 协议</h1><span class="article-author">Bowen</span><span class="article-date">2018 JUN 06</span><div class="article-tags"><a href="/blog/tags/前端开发" class="article-tag">前端开发</a><a href="/blog/tags/网络请求" class="article-tag">网络请求</a></div></div><div class="article-content"><h2 id="http-三次握手"><a href="#http-三次握手" class="header-anchor" aria-hidden="true">#</a> HTTP 三次握手</h2><p><code>HTTP</code> 自身没有和 <code>server</code> 端通信传输的功能，<code>HTTP</code> 本身只能发起和响应请求，并不传输请求。他是通过创建的 <code>TCP connection</code>（作为传输请求的通道）来实现数据传递功能。所有的 <code>HTTP</code> 请求创建时，都会创建一个 <code>TCP</code> 通道用于数据传输。<p><img alt="http-tcp" src="https://assets.set.sh/2018/180606-http-protocol/http-tcp.svg"><ul><li><p><code>HTTP 1.0</code> 时，在 <code>HTTP</code> 请求创建时，同样会创建一个 <code>TCP</code> 通道用于传输数据。在服务端响应请求后，<code>TCP</code> 通道就会关闭（非常驻）。<li><p><code>HTTP 1.1</code> 时，可 <em><strong>额外声明</strong></em> 让服务端响应请求后，<code>TCP</code> 仍保持通道开启（常驻状态）。此举用于避免多次请求时，不必要的 <code>三次握手</code> 性能开销。<ul><li>现阶段使用最为广泛的 <code>HTTP</code> 协议版本。</ul><li><p><code>HTTP 2</code> 可并发请求，那么在保持 <code>TCP</code> 通道开启时，相同用户多次对同一服务器的并发请求可共用一个 <code>TCP</code> 通道。<ul><li><code>HTTP 2</code> 正在逐步推广中。</ul></ul><h3 id="三次握手"><a href="#三次握手" class="header-anchor" aria-hidden="true">#</a> 三次握手</h3><p>在 <code>HTTP</code> 通过 <code>TCP</code> 执行正式的请求之前，有 3 次预先请求发生在 <code>client</code> 和 <code>server</code> 端之间。<ol><li><p><code>client</code> 创建一个预请求以告知 <code>server</code>：<code>client</code> 即将发起一个正式 <code>TCP</code> 连接。此次请求包含标志位（<code>SYN=1,Seq=X</code>）。<li><p><code>server</code> 响应 1 中的预请求，开启相应 <code>TCP</code> 端口，并返回一个响应数据包（<code>SYN=1, ACK=X+1, Seq=Y</code>）给 <code>client</code>。<ul><li><p>此次 <code>server</code> 返回数据表示 <code>server</code> 不仅能够正常接受 <code>client</code> 的请求，而且已开启相应端口准备接收即将到来的正式 <code>TCP</code> 连接。<li><p>此时 <code>server</code> 端的 <code>TCP</code> 端口将保持开启至响应 <code>client</code> 请求（<code>client</code> 已正常接收的请求或关闭当前 <code>TCP</code> 连接的请求）。</ul><li><p><code>client</code> 在收到 <code>server</code> 端返回的允许创建 <code>TCP</code> 连接的请求之后，向 <code>server</code> 发送已正常接收到 2 中的响应数据的请求（<code>ACK=Y+1, Seq=Z</code>）。<ul><li>此次请求表示 <code>client</code> 能够正常接受 <code>server</code> 的响应数据。</ul></ol><p>此时，完成 <code>三次握手</code> 预请求，创建正式的 <code>TCP</code> 请求。<h3 id="三次握手的意义"><a href="#三次握手的意义" class="header-anchor" aria-hidden="true">#</a> 三次握手的意义</h3><ol><li><p>若没有三次握手，直接请求，那么在 <code>server</code> 返回数据时，<code>server</code> 并不知道 <code>client</code> 是否能够正确的接受到请求，是否过程中有数据丢失，那么 <code>server</code> 就可能在错误的时机仍然保持 <code>TCP</code> 连接端口来等待 <code>client</code> 确认数据已接受的请求或关闭当前 <code>TCP</code> 连接的请求，这样将带来一系列不必要的 <code>server</code> 性能开销。在 <code>client</code> 等待时间内没有正确接收请求时，<code>client</code> 就会关闭 <code>TCP</code> 连接。那么此时 <code>server</code> 也就没有必要为为无用的数据连接继续保持开启相应 <code>TCP</code> 连接端口。<li><p>在有了三次握手的策略后，在正式请求之前，就可以确保当前 <code>TCP</code> 通道是可用的，及时发现当前 <code>TCP</code> 的网络问题。避免因网络问题导致的无用的数据传输带来的 <code>server</code> 端口常驻的性能开销。</ol><h2 id="uri-url-urn"><a href="#uri-url-urn" class="header-anchor" aria-hidden="true">#</a> URI/URL/URN</h2><p><code>URI</code>: Uniform Resource Identifier 统一资源标志符<ul><li><p>用于唯一标识互联网中的信息资源<li><p>包含 <code>URL</code> 和 <code>URN</code></ul><p><code>URL</code>: Uniform Resource Locator 统一资源定位器<ul><li><p>格式如下：<p><code>protocol://user:pass@host.com:80/path?query=string#hash</code><ul><li><p><code>protocol</code> 协议。如 <code>https</code>、<code>http</code>、<code>ftp</code> 等。<li><p><code>user:pass</code> 用户验证。因暴露用户账号密码不安全，故不推荐使用。<li><p><code>host</code> 主机名。<li><p><code>80</code> 主机端口，默认为 <code>80</code>。每个物理主机端口都存放着不同的 web 服务。<li><p><code>path</code> 路由。<ol><li><p><code>/</code> 表示当前 <code>web</code> 服务的根目录，而不是主机的根目录。<li><p><code>path</code> 路径默认情况下为 <code>web</code> 服务器下数据存放的路径。当数据库独立时，那么 <code>path</code> 仅表示数据的 <em><strong>存放地址</strong></em>，并不能表示该数据在服务器磁盘上的路径。<li><p>故推荐在程序内部鉴别数据，而不是通过 URL 鉴别数据。</ol><li><p><code>query=string</code> 查询参数。常用于向 <code>server</code> 端传参。<li><p><code>hash</code> 哈希值。定位某个资源的某一片段。如文章的锚点。</ul></ul><p><code>URN</code>: Uniform Resource Name （永久）统一资源定位符<ul><li>用于永久性在网络中标识出资源，因限制过多，已逐渐被 <code>URI</code> 取代。（<a href="https://en.wikipedia.org/wiki/Uniform_Resource_Name" rel="noopener noreferrer" target="_blank">extension<outboundlink></a>）</ul><h2 id="http-报文"><a href="#http-报文" class="header-anchor" aria-hidden="true">#</a> HTTP 报文</h2><p><code>HTTP</code> 报文没有强约束，可自定义报文内容。<p><img alt="http-bw" src="https://assets.set.sh/2018/180606-http-protocol/http-bw.svg"><h2 id="http-方法"><a href="#http-方法" class="header-anchor" aria-hidden="true">#</a> HTTP 方法</h2><ul><li><p>用来定义对于资源的操作<ul><li><p>常用方法有 <code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>。另外还有 <code>HEAD</code>、<code>OPTIONS</code>、<code>PATCH</code> 方法。<li><p>应该从开发人员的使用方式来定义各自方法的语义。</ul></ul><h2 id="http-code"><a href="#http-code" class="header-anchor" aria-hidden="true">#</a> HTTP code</h2><ul><li><p>定义服务器对请求的处理结果。<ul><li><p>2XX - Success - 表示成功处理请求。如 200。<li><p>3XX - Redirection - 需要重定向，浏览器直接跳转。<li><p>4XX - Client Error - 客户端请求错误。<li><p>5XX - Server Error - 服务端响应错误。</ul><li><p>推荐 <code>server</code> 端正确配置 HTTP code，使得 HTTP code 语义化。好的 <code>HTTP</code> 服务应该可以通过 HTTP code 来判断请求结果。而不是只有 <code>200</code> 或 <code>500</code>。</ul><p>拓展：<a href="http://tool.oschina.net/commons?type=5" rel="noopener noreferrer" target="_blank">code 码参考<outboundlink></a><h2 id="http-客户端"><a href="#http-客户端" class="header-anchor" aria-hidden="true">#</a> HTTP 客户端</h2><p>能够发起 HTTP 请求，并能够接收返回数据的客户端都可称为 HTTP 客户端。如 <code>curl</code>、<code>XMLHttpRequest</code>、浏览器等。<p>除了在浏览器中可以观察 HTTP 请求的细节外，亦可使用 <code>curl</code> 命令行工具来观察。<pre class="language-powershell" v-pre><code><span class="token comment"># -v 表示显示报文信息</span>
curl <span class="token operator">-</span>v www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com
</code></pre><p>返回数据如下：<pre class="language-powershell" v-pre><code><span class="token operator">*</span> Rebuilt URL to: www<span class="token punctuation">.</span>google<span class="token punctuation">.</span>com<span class="token operator">/</span>
  <span class="token operator">%</span> Total    <span class="token operator">%</span> Received <span class="token operator">%</span> Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  0     0    0     0    0     0      0      0 <span class="token operator">--</span>:<span class="token operator">--</span>:<span class="token operator">--</span> <span class="token operator">--</span>:<span class="token operator">--</span>:<span class="token operator">--</span> <span class="token operator">--</span>:<span class="token operator">--</span>:<span class="token operator">--</span>     0<span class="token operator">*</span>
  Trying 172<span class="token punctuation">.</span>217<span class="token punctuation">.</span>10<span class="token punctuation">.</span>132<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token operator">*</span> TCP_NODELAY <span class="token function">set</span>
<span class="token operator">*</span> Connected to www<span class="token punctuation">.</span>google<span class="token punctuation">.</span>com <span class="token punctuation">(</span>172<span class="token punctuation">.</span>217<span class="token punctuation">.</span>10<span class="token punctuation">.</span>132<span class="token punctuation">)</span> port 80 <span class="token punctuation">(</span><span class="token comment">#0)</span>
<span class="token comment"># 请求报文</span>
  <span class="token comment"># 起始行</span>
> GET <span class="token operator">/</span> HTTP<span class="token operator">/</span>1<span class="token punctuation">.</span>1
  <span class="token comment"># 首部</span>
> Host: www<span class="token punctuation">.</span>google<span class="token punctuation">.</span>com
> User<span class="token operator">-</span>Agent: curl<span class="token operator">/</span>7<span class="token punctuation">.</span>57<span class="token punctuation">.</span>0
> Accept: <span class="token operator">*</span>/<span class="token operator">*</span>
> <span class="token comment"># 此处有一空行</span>
<span class="token comment"># 响应报文</span>
  <span class="token comment"># 起始行</span>
&lt; HTTP<span class="token operator">/</span>1<span class="token punctuation">.</span>1 200 OK
  <span class="token comment"># 首部</span>
&lt; Date: Thu<span class="token punctuation">,</span> 07 Jun 2018 14:28:45 GMT
&lt; Expires: <span class="token operator">-</span>1
&lt; Cache<span class="token operator">-</span>Control: private<span class="token punctuation">,</span> max<span class="token operator">-</span>age=0
&lt; Content<span class="token operator">-</span><span class="token function">Type</span>: text<span class="token operator">/</span>html<span class="token punctuation">;</span> charset=ISO<span class="token operator">-</span>8859<span class="token operator">-</span>1
<span class="token comment"># 省略一些信息</span>
<span class="token comment"># ...</span>
&lt; Transfer<span class="token operator">-</span>Encoding: chunked
&lt;
<span class="token punctuation">{</span> <span class="token punctuation">[</span>759 bytes <span class="token keyword">data</span><span class="token punctuation">]</span>
100  3555    0  3555    0     0   3555      0 <span class="token operator">--</span>:<span class="token operator">--</span>:<span class="token operator">--</span>  0:00:01 <span class="token operator">--</span>:<span class="token operator">--</span>:<span class="token operator">--</span>  1834
<span class="token comment"># 以下是响应报文的主体内容区域</span>
<span class="token comment"># ...</span>
&lt;<span class="token operator">!</span>doctype html>&lt;html
</code></pre><h2 id="http-首部"><a href="#http-首部" class="header-anchor" aria-hidden="true">#</a> HTTP 首部</h2><p>在实现 <code>HTTP</code> 协议过程中，一系列功能都是通过配置相应的 <code>HTTP</code> 首部来实现的。<p>👉<a href="/blog/writings/http-response/">HTTP 响应首部</a><p>👉<a href="/blog/writings/http-request/">HTTP 请求首部</a><h2 id="实战"><a href="#实战" class="header-anchor" aria-hidden="true">#</a> 实战</h2><p>（以 <code>Nginx</code> 为例）<p><code>Nginx</code>（<a href="https://nginx.org/en/" rel="noopener noreferrer" target="_blank">官网<outboundlink></a>）纯粹地实现 <code>HTTP</code> 协议，其中并不包含业务逻辑，正因如此它的 <em><strong>可拓展性强</strong></em>。<h3 id="api"><a href="#api" class="header-anchor" aria-hidden="true">#</a> API</h3><ul><li><code>Nginx</code> API</ul><p>API 文档：<a href="http://nginx.org/en/docs/windows.html" rel="noopener noreferrer" target="_blank">API Docs<outboundlink></a><p>命令行参数：<a href="http://nginx.org/en/docs/switches.html" rel="noopener noreferrer" target="_blank">Command-line parameters<outboundlink></a><pre class="language-powershell" v-pre><code><span class="token comment"># -c file 使用一个指定的配置文件代替默认配置文件，默认值为 nginx/nginx.conf</span>

<span class="token comment"># 启动服务</span>
<span class="token function">start</span> nginx <span class="token punctuation">[</span><span class="token operator">-</span>c confFile<span class="token punctuation">]</span> <span class="token comment"># 推荐，但配置文件出错时，无提示信息</span>
<span class="token comment"># 或者</span>
<span class="token punctuation">.</span><span class="token operator">/</span>nginx <span class="token punctuation">[</span><span class="token operator">-</span>c confFile<span class="token punctuation">]</span> <span class="token comment"># 会占用当前窗口，但配置文件从出错时，有提示信息</span>

<span class="token comment"># -s signal 发送一个 signal 到 nginx 主进程</span>
<span class="token comment"># signal 值为 stop, quit, reload, reopen 之一</span>

<span class="token comment"># 重启服务</span>
<span class="token punctuation">.</span><span class="token operator">/</span>nginx <span class="token operator">-</span>s reload

<span class="token comment"># 退出服务</span>
<span class="token punctuation">.</span><span class="token operator">/</span>nginx <span class="token operator">-</span>s stop <span class="token comment"># 立即停止服务，可能不会保存相关信息</span>
<span class="token punctuation">.</span><span class="token operator">/</span>nginx <span class="token operator">-</span>s quit <span class="token comment"># 有序地停止服务，并保存相关信息</span>

<span class="token comment"># -g directives 发送一个全局配置指令</span>
<span class="token comment"># HUP 指令，使用新的配置文件启动进程，之后平缓停止原有进程，即平滑重启</span>

<span class="token comment"># 平滑重启</span>
<span class="token punctuation">.</span><span class="token operator">/</span>nginx <span class="token operator">-</span>g HUP <span class="token punctuation">[</span><span class="token operator">-</span>c newConfFile<span class="token punctuation">]</span>

<span class="token comment"># -t 检测配置文件。使用场景：用于上线前检测，避免上线错误</span>
<span class="token punctuation">.</span><span class="token operator">/</span>nginx <span class="token operator">-</span>t <span class="token operator">-</span>c sample<span class="token punctuation">.</span>conf

<span class="token comment"># 查看当前 nginx 进程号</span>
<span class="token comment"># logs/nginx.pid 是 nginx.pid 的文件路径</span>
<span class="token function">cat</span> logs<span class="token operator">/</span>nginx<span class="token punctuation">.</span>pid
</code></pre><ul><li>系统 API</ul><pre class="language-powershell" v-pre><code><span class="token comment"># 查看端口占用，如 8800 端口</span>
<span class="token comment"># -ano 是三个参数 -a -n -o 简写形式</span>
netstat <span class="token operator">-</span>ano<span class="token punctuation">|</span>findstr 8800

tasklist <span class="token operator">/</span>? <span class="token comment"># 帮助文档</span>

<span class="token comment"># /fi filter 显示一系列符合筛选器指定的进程</span>

<span class="token comment"># 查看当前 nginx 进程</span>
<span class="token comment"># 其中运算符 eq 表示 等于</span>
tasklist <span class="token operator">/</span>fi <span class="token string">"imagename eq nginx.exe"</span> <span class="token comment"># cmd and powershell</span>
tasklist <span class="token operator">/</span><span class="token operator">/</span>fi <span class="token string">"imagename eq nginx.exe"</span> <span class="token comment"># git bash for win</span>

<span class="token comment"># 结束所有 nginx 进程</span>

tskill nginx <span class="token comment"># 推荐</span>

<span class="token comment"># /f 强行终止</span>
taskkill <span class="token operator">/</span>fi <span class="token string">"imagename eq nginx.exe"</span> <span class="token operator">/</span>f <span class="token comment"># cmd and powershell</span>
taskkill <span class="token operator">/</span><span class="token operator">/</span>fi <span class="token string">"imagename eq nginx.exe"</span> <span class="token operator">/</span><span class="token operator">/</span>f <span class="token comment"># git bash for win</span>

<span class="token comment"># 与 pid 配合使用</span>
<span class="token function">cat</span> logs<span class="token operator">/</span>nginx<span class="token punctuation">.</span>pid <span class="token comment"># 得到 Nginx 主进程 PID 值 pidNumber</span>
taskkill <span class="token operator">/</span><span class="token operator">/</span>pid pidNumber <span class="token operator">/</span><span class="token operator">/</span>f
</code></pre><p>注：<code>tasklist</code> 和 <code>taskkill</code> 命令在 <code>git bash for win</code> 中必须以双斜杠传参（<a href="https://stackoverflow.com/questions/34981745/taskkill-pid-not-working-in-gitbash" rel="noopener noreferrer" target="_blank">source<outboundlink></a>）。<h3 id="代理基础配置"><a href="#代理基础配置" class="header-anchor" aria-hidden="true">#</a> 代理基础配置</h3><ol><li>在 <code>host</code> 文件中映射原始请求地址。示例：</ol><pre class="language-powershell" v-pre><code><span class="token comment"># 用于将 example.com 解析为 127.0.0.1，原理是 PC 首先在本地 host 文件中解析 URL</span>
127<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>1 example<span class="token punctuation">.</span>com
</code></pre><ol start="2"><li>单独配置 <code>servers/example.conf</code>，以模块化 <code>Nginx</code> 代理配置。</ol><p>拓展：<code>http</code> 是明文传输，故可在代理层修改原始请求的请求首部和内容。<pre class="language-nginx" v-pre><code><span class="token comment"># 每个代理服务都在一个 server 中定义</span>
<span class="token keyword">server</span> <span class="token punctuation">{</span>
  <span class="token comment"># 监听的端口</span>
  <span class="token keyword">listen</span>      <span class="token number">80</span><span class="token punctuation">;</span>
  <span class="token comment"># 监听的 URL，即用户输入的 URL</span>
  <span class="token keyword">server_name</span> test<span class="token punctuation">.</span>com<span class="token punctuation">;</span>

  <span class="token comment"># 转发的目标地址</span>
  <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>
    <span class="token comment"># 1. 代理层接受到原始请求后，将发起一个新的请求至代理路径。依据 HTTP 原则，该新的请</span>
    <span class="token comment"># 求的 host 默认为 proxy_pass。</span>
    <span class="token comment"># 注：可于终端 server 打印并查看新请求的 host 请求首部。</span>
    <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">8800</span><span class="token punctuation">;</span>
    <span class="token comment"># 2. 恢复原始请求的 host 请求首部。变量 $host 即原始请求的 host 请求首部。</span>
    <span class="token comment"># 注：经浏览器控制台 network tag 可查看原始请求的 host 请求首部</span>
    <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>以上配置将实现 <code>example.com ==转发至==> http://127.0.0.1:8800</code>。<p><em><strong>注</strong></em>，代理服务器根据原始请求的 <code>host</code> 请求首部来 <em><strong>选择</strong></em> 代理的目标路径。即可以实现一个端口监听，多个路径代理。<h3 id="缓存功能"><a href="#缓存功能" class="header-anchor" aria-hidden="true">#</a> 缓存功能</h3><pre class="language-nginx" v-pre><code><span class="token comment"># proxy_cache_path 配置缓存存放路径</span>
<span class="token comment"># levels 配置生成多级文件夹，使得多个代理分离为自己独立的文件夹</span>
<span class="token comment"># keys_zone 配置在内存中分配给匹配的缓存（因为匹配的缓存将暂存在内存中）的区域名称和大小</span>
<span class="token keyword">proxy_cache_path</span> cache levels<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">2</span> keys_zone<span class="token operator">=</span>my_cache<span class="token punctuation">:</span><span class="token number">10</span>m<span class="token punctuation">;</span> <span class="token comment"># 2 级目录，内存 10m</span>

<span class="token keyword">server</span> <span class="token punctuation">{</span>
  <span class="token keyword">listen</span>      <span class="token number">80</span><span class="token punctuation">;</span>
  <span class="token keyword">server_name</span> test<span class="token punctuation">.</span>com<span class="token punctuation">;</span>

  <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>
    <span class="token keyword">proxy_cache</span> my_cache<span class="token punctuation">;</span> <span class="token comment"># 根据名字 my_caches 配置缓存存储的区域</span>
    <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">8800</span><span class="token punctuation">;</span>
    <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>代理缓存的应用场景：只要一次代理缓存，那么后续在缓存有效期内所有请求到代理服务器的请求都可使用该缓存，那么可大大节约向真正资源服务器请求的数量与时间。<p>与代理缓存相关的响应首部（对于 <code>client</code> 来说）<ol><li><p><code>Cache-Control</code><ul><li><p><code>s-maxage</code>: 功能与 <code>max-age</code> 相同，且 <code>s-maxage</code> 覆盖 <code>max-age</code>。二者区别在于 <code>s-maxage</code> 适用对象仅限共享缓存的对象，如中转代理服务器。<li><p><code>private</code>：标注只允许 <code>client</code> 缓存数据，中转代理服务器不能缓存该数据。</ul><pre class="language-js" v-pre><code><span class="token comment">// 资源服务器</span>
response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// private 将导致 max-age 和 s-maxage 失效</span>
  <span class="token string">'Cache-Control'</span><span class="token punctuation">:</span> <span class="token string">'max-age=2, s-maxage=20, private'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><ul><li><code>no-store</code>：路径中所有节点（包含 <code>client</code>）都不能缓存该响应数据。</ul><pre class="language-js" v-pre><code><span class="token comment">// 资源服务器</span>
response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// no-store 将导致 max-age 和 s-maxage 失效</span>
  <span class="token string">'Cache-Control'</span><span class="token punctuation">:</span> <span class="token string">'max-age=2, s-maxage=20, no-store'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><li><p><code>Vary</code>: <code>Vary</code> 指定某一 <code>client</code> 端请求头，只有当该请求首部的值与上次请求首部的值相等时，才缓存响应数据。<pre class="language-js" v-pre><code><span class="token comment">// client</span>
<span class="token keyword">const</span> index <span class="token operator">=</span> <span class="token number">0</span>

<span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/data'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  headers<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 只有当此次 `x-test-Cache` 的值与上次请求相同时，才缓存此次响应数据</span>
    <span class="token string">'X-test-Cache'</span><span class="token punctuation">:</span> index<span class="token operator">++</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><pre class="language-js" v-pre><code><span class="token comment">// 资源服务器</span>
response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token string">'Cache-Control'</span><span class="token punctuation">:</span> <span class="token string">'s-maxage=200'</span><span class="token punctuation">,</span>
  <span class="token comment">// 只有当 `Vary` 所标注的请求首部当次值与上次请求时的值相同时，才缓存当前响应数据</span>
  <span class="token string">'Vary'</span><span class="token punctuation">:</span> <span class="token string">'X-test-Cache'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></ol><p>适用场景：在同一 URL 情况下，根据不同的 <code>userAgent</code> 来缓存不同的响应数据。比如根据移动端与 PC 端返回不同的数据。<h2 id="https"><a href="#https" class="header-anchor" aria-hidden="true">#</a> HTTPS</h2><p><code>HTTP</code> 是明文传输，为了密文传输，诞生了 <code>HTTPS</code>。<h3 id="加密与解密"><a href="#加密与解密" class="header-anchor" aria-hidden="true">#</a> 加密与解密</h3><p>公钥（即服务端证书）用于加密被传输的数据。私钥用于解密被传输的数据。<p>在握手阶段，进行公钥与私钥匹配。<code>client</code> 将在最初阶段传输加密套件，用于与 <code>server</code> 端内容协商（<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation" rel="noopener noreferrer" target="_blank">source<outboundlink></a>）选择最终使用的加密方式。私钥始终保持在 <code>server</code> 端，用于解密，那么据此保证了传输的安全性。<p><img alt="https-principle" src="https://assets.set.sh/2018/180606-http-protocol/https-principle.svg"><h3 id="部署"><a href="#部署" class="header-anchor" aria-hidden="true">#</a> 部署</h3><ol><li>生成证书（<a href="https://gist.github.com/lbwa/5607c3a66573610b5ccfd4ef4aaa780f" rel="noopener noreferrer" target="_blank">本地生成证书命令<outboundlink></a>）</ol><ol start="2"><li>配置 <code>Nginx</code> 代理</ol><p>（<a href="http://nginx.org/en/docs/http/configuring_https_servers.html" rel="noopener noreferrer" target="_blank">reference<outboundlink></a>）<pre class="language-nginx" v-pre><code><span class="token keyword">proxy_cache_path</span> cache levels<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">2</span> keys_zone<span class="token operator">=</span>my_cache<span class="token punctuation">:</span><span class="token number">10</span>m<span class="token punctuation">;</span>

<span class="token keyword">server</span> <span class="token punctuation">{</span>
  <span class="token comment"># https 默认端口是 443</span>
  <span class="token keyword">listen</span>      <span class="token number">443</span> <span class="token keyword">ssl</span><span class="token punctuation">;</span>
  <span class="token keyword">server_name</span> test<span class="token punctuation">.</span>com<span class="token punctuation">;</span>

  <span class="token comment"># ssl on; 于 1.15 版本中废弃，listen &lt;port> ssl 代替</span>
  <span class="token keyword">ssl_certificate_key</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>certs<span class="token operator">/</span>localhost<span class="token operator">-</span>privkey<span class="token punctuation">.</span>pem<span class="token punctuation">;</span>
  <span class="token keyword">ssl_certificate</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>certs<span class="token operator">/</span>localhost<span class="token operator">-</span>cert<span class="token punctuation">.</span>pem<span class="token punctuation">;</span>

  <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>
    <span class="token keyword">proxy_cache</span> my_cache<span class="token punctuation">;</span>
    <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">8800</span><span class="token punctuation">;</span>
    <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>补充：将 <code>HTTP</code> 转发至 <code>HTTPS</code><pre class="language-nginx" v-pre><code><span class="token comment"># 在 部署.2 的基础上实现</span>

<span class="token keyword">server</span> <span class="token punctuation">{</span>
  <span class="token keyword">listen</span>      <span class="token number">80</span> default_server<span class="token punctuation">;</span>
  <span class="token keyword">listen</span>       <span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token number">80</span> default_server<span class="token punctuation">;</span>
  <span class="token keyword">server_name</span> test<span class="token punctuation">.</span>com<span class="token punctuation">;</span>

  <span class="token comment"># $server_name 接受请求的服务器的名称，此处即是 test.com</span>
  <span class="token comment"># $request_uri 原始完整的请求 URL，包含查询参数，即访问主机上的路径，如 /api/data</span>
  <span class="token keyword">return</span> <span class="token number">302</span> <span class="token keyword">https</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token variable">$server_name</span><span class="token variable">$request_uri</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre><h2 id="http-2"><a href="#http-2" class="header-anchor" aria-hidden="true">#</a> HTTP 2</h2><ol><li><p>信道复用，在单个 <code>TCP</code> 通道内可 <em><strong>并发请求</strong></em>，但在 <code>HTTP 1.1</code> 中单个 <code>TCP</code> 通道内是串行请求。<li><p>分帧传输，每帧以包含上下文的形式传输，过程中不一定是按照顺序传输的。因为包含上下文，故在响应端，可根据上下文重组各帧还原数据。<li><p>Server Push，<code>server</code> 端不再是只有被动接受请求才能响应，<code>server</code> 端在 <code>HTTP 2</code> 中可主动推送数据至 <code>client</code>。</ol><h3 id="部署-2"><a href="#部署-2" class="header-anchor" aria-hidden="true">#</a> 部署</h3><p>（<a href="http://nginx.org/en/docs/http/ngx_http_v2_module.html" rel="noopener noreferrer" target="_blank">reference<outboundlink></a>）<p>在 <code>HTTP 2</code> 标准中，<code>HTTP 2</code> 并不强制使用 <code>HTTPS</code>。值得注意的是，目前浏览器都要在开启 <code>HTTPS</code> 的情况下才能使用 <code>HTTP 2</code>。<pre class="language-nginx" v-pre><code><span class="token comment"># 中转服务器</span>
<span class="token keyword">server</span> <span class="token punctuation">{</span>
  <span class="token keyword">listen</span>             <span class="token number">443</span> <span class="token keyword">ssl</span> http2<span class="token punctuation">;</span>
  <span class="token keyword">server_name</span>        test<span class="token punctuation">.</span>com<span class="token punctuation">;</span>
  <span class="token comment"># 指定主动推送</span>
  http2_push_preload on<span class="token punctuation">;</span>
  <span class="token comment"># ...</span>
<span class="token punctuation">}</span>
</code></pre><ul><li><p>查看 <code>server</code> 端主动推送的相关信息，于地址栏输入 <code>chrome://net-internals/#http2</code> 查看。<li><p>注：浏览器只会接受安全的认证过证书的 <code>server</code> 端推送的信息，否则主动推送信息将被忽略。</ul><p>补充：<code>HTTPS</code> vs <code>HTTP 1.1</code> vs <code>HTTP 2</code> <a href="https://http2.akamai.com/demo/http2-lab.html" rel="noopener noreferrer" target="_blank">demo<outboundlink></a><p><em><strong>注</strong></em>：<code>Nginx</code> 代理服务器可以为 <code>HTTP 2</code> 做兼容，他会根据 <code>client</code> 端所支持的协议返回响应数据，而不需要开发人员来做协议兼容。</div></article><button data-v-e85d20b2 data-v-e85d20b2 class="floating-btn __position" style="display:none"><svg class="icon-rocket" data-v-e85d20b2 viewBox="0 0 512 512"><path d="M256 421.6c-18.1 0-33.2-6.8-42.9-10.9-5.4-2.3-11.3 1.8-10.9 7.6l3.5 51c.2 3.1 3.8 4.7 6.3 2.8l14.5-11c1.8-1.4 4.5-.9 5.7 1l20.5 32.1c1.5 2.4 5.1 2.4 6.6 0l20.5-32.1c1.2-1.9 3.9-2.4 5.7-1l14.5 11c2.5 1.9 6.1.3 6.3-2.8l3.5-51c.4-5.8-5.5-10-10.9-7.6-9.8 4.1-24.8 10.9-42.9 10.9z" data-v-e85d20b2></path><path d="M397.7 293.1l-48-49.1c0-158-93.2-228-93.2-228s-94.1 70-94.1 228l-48 49.1c-1.8 1.8-2.6 4.5-2.2 7.1L130.6 412c.9 5.7 7.1 8.5 11.8 5.4l67.1-45.4s20.7 20 47.1 20c26.4 0 46.1-20 46.1-20l67.1 45.4c4.6 3.1 10.8.3 11.8-5.4l18.5-111.9c.2-2.6-.6-5.2-2.4-7zM256.5 192c-17 0-30.7-14.3-30.7-32s13.8-32 30.7-32c17 0 30.7 14.3 30.7 32s-13.7 32-30.7 32z" data-v-e85d20b2></path></svg></button></main><footer class="blog-footer sf__main__layout grid col grid-jc-center" data-v-1044ad0a data-v-cac63c14><div class="footer-info" data-v-1044ad0a>Copyright © 2018 <a href="https://github.com/lbwa" class="author" rel="noopener" target="_blank" data-v-1044ad0a>Bowen</a></div></footer><section class="loading-wrapper grid col grid-center grid-jc-center" data-v-cac63c14 style="display:none"><div class="loading"><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div></div><a class="loading-tips">Loading</a></section></section></div></div><script type="text/javascript">window.__NUXT__={layout:"blog",data:[{menu:[{errno:0,to:"writings/dom-location",title:"获取 Element 在 document 中的位置信息",author:"Bowen",date:"2018 SEP 01",tags:["前端开发","CSS"]},{errno:0,to:"writings/spa-and-mpa",title:"SPA 与 MPA 的比较与优化",author:"Bowen",date:"2018 AUG 04",tags:["前端开发","SPA","MPA","skeleton"]},{errno:0,to:"writings/async-function-in-js",title:"Event loops 中的 AsyncFunction",author:"Bowen",date:"2018 JUL 26",tags:["JavaScript","async","事件循环"]},{errno:0,to:"writings/pwa-fundamentals",title:"PWA 基础",author:"Bowen",date:"2018 JUL 07",tags:["前端开发","PWA"]},{errno:0,to:"writings/js-design-pattern",title:"JS 设计模式",author:"Bowen",date:"2018 JUN 12",tags:["前端开发","设计模式"]},{errno:0,to:"writings/http-request",title:"HTTP 协议请求首部",author:"Bowen",date:"2018 JUN 08",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-response",title:"HTTP 协议响应首部",author:"Bowen",date:"2018 JUN 07",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-protocol",title:"HTTP 协议",author:"Bowen",date:"2018 JUN 06",tags:["前端开发","网络请求"]},{errno:0,to:"writings/execution-context",title:"JS 执行上下文",author:"Bowen",date:"2018 MAY 07",tags:["前端开发","JavaScript","执行上下文"]},{errno:0,to:"writings/vue-lifecycle-and-slots",title:"对 Vue 插槽和生命周期的一点思考",author:"Bowen",date:"2018 APR 24",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/learning-vue-unit-test",title:"总结如何进行单元测试",author:"Bowen",date:"2018 APR 21",tags:["前端开发","Vue.js","应用测试"]},{errno:0,to:"writings/cross-domain-solution",title:"客户端跨域解决方案",author:"Bowen",date:"2018 APR 19",tags:["前端开发","网络请求"]},{errno:0,to:"writings/css-bfc",title:"探究 BFC 以及闭合浮动原理",author:"Bowen",date:"2018 MAR 29",tags:["前端开发","CSS"]},{errno:0,to:"writings/vue.js-reusability-and-composition",title:"学习 Vue.js 可复用性和组合",author:"Bowen",date:"2018 MAR 12",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/event-loop",title:"解析 event loops",author:"Bowen",date:"2018 MAR 08",tags:["前端开发","JavaScript","事件循环"]},{errno:0,to:"writings/learning-vuex",title:"学习 vuex 基础",author:"Bowen",date:"2018 MAR 06",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/compare-commonjs-with-esm",title:"比较 CommonJS 与 ES6 Module 语法",author:"Bowen",date:"2018 FEB 27",tags:["前端开发","JavaScript","模块"]},{errno:0,to:"writings/learning-vuejs-essentials",title:"学习 Vue.js 基础",author:"Bowen",date:"2018 FEB 24",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/keyword-this",title:"理解 this 的指向",author:"Bowen",date:"2018 FEB 06",tags:["前端开发","JavaScript"]}]},{title:"HTTP 协议",date:"2018 JUN 06",author:"Bowen",tags:["前端开发","网络请求"],content:'<h2 id="http-三次握手"><a class="header-anchor" href="#http-三次握手" aria-hidden="true">#</a> HTTP 三次握手</h2>\n<p><code>HTTP</code> 自身没有和 <code>server</code> 端通信传输的功能，<code>HTTP</code> 本身只能发起和响应请求，并不传输请求。他是通过创建的 <code>TCP connection</code>（作为传输请求的通道）来实现数据传递功能。所有的 <code>HTTP</code> 请求创建时，都会创建一个 <code>TCP</code> 通道用于数据传输。</p>\n<p><img src="https://assets.set.sh/2018/180606-http-protocol/http-tcp.svg" alt="http-tcp"></p>\n<ul>\n<li>\n<p><code>HTTP 1.0</code> 时，在 <code>HTTP</code> 请求创建时，同样会创建一个 <code>TCP</code> 通道用于传输数据。在服务端响应请求后，<code>TCP</code> 通道就会关闭（非常驻）。</p>\n</li>\n<li>\n<p><code>HTTP 1.1</code> 时，可 <em><strong>额外声明</strong></em> 让服务端响应请求后，<code>TCP</code> 仍保持通道开启（常驻状态）。此举用于避免多次请求时，不必要的 <code>三次握手</code> 性能开销。</p>\n<ul>\n<li>现阶段使用最为广泛的 <code>HTTP</code> 协议版本。</li>\n</ul>\n</li>\n<li>\n<p><code>HTTP 2</code> 可并发请求，那么在保持 <code>TCP</code> 通道开启时，相同用户多次对同一服务器的并发请求可共用一个 <code>TCP</code> 通道。</p>\n<ul>\n<li><code>HTTP 2</code> 正在逐步推广中。</li>\n</ul>\n</li>\n</ul>\n<h3 id="三次握手"><a class="header-anchor" href="#三次握手" aria-hidden="true">#</a> 三次握手</h3>\n<p>在 <code>HTTP</code> 通过 <code>TCP</code> 执行正式的请求之前，有 3 次预先请求发生在 <code>client</code> 和 <code>server</code> 端之间。</p>\n<ol>\n<li>\n<p><code>client</code> 创建一个预请求以告知 <code>server</code>：<code>client</code> 即将发起一个正式 <code>TCP</code> 连接。此次请求包含标志位（<code>SYN=1,Seq=X</code>）。</p>\n</li>\n<li>\n<p><code>server</code> 响应 1 中的预请求，开启相应 <code>TCP</code> 端口，并返回一个响应数据包（<code>SYN=1, ACK=X+1, Seq=Y</code>）给 <code>client</code>。</p>\n<ul>\n<li>\n<p>此次 <code>server</code> 返回数据表示 <code>server</code> 不仅能够正常接受 <code>client</code> 的请求，而且已开启相应端口准备接收即将到来的正式 <code>TCP</code> 连接。</p>\n</li>\n<li>\n<p>此时 <code>server</code> 端的 <code>TCP</code> 端口将保持开启至响应 <code>client</code> 请求（<code>client</code> 已正常接收的请求或关闭当前 <code>TCP</code> 连接的请求）。</p>\n</li>\n</ul>\n</li>\n<li>\n<p><code>client</code> 在收到 <code>server</code> 端返回的允许创建 <code>TCP</code> 连接的请求之后，向 <code>server</code> 发送已正常接收到 2 中的响应数据的请求（<code>ACK=Y+1, Seq=Z</code>）。</p>\n<ul>\n<li>此次请求表示 <code>client</code> 能够正常接受 <code>server</code> 的响应数据。</li>\n</ul>\n</li>\n</ol>\n<p>此时，完成 <code>三次握手</code> 预请求，创建正式的 <code>TCP</code> 请求。</p>\n<h3 id="三次握手的意义"><a class="header-anchor" href="#三次握手的意义" aria-hidden="true">#</a> 三次握手的意义</h3>\n<ol>\n<li>\n<p>若没有三次握手，直接请求，那么在 <code>server</code> 返回数据时，<code>server</code> 并不知道 <code>client</code> 是否能够正确的接受到请求，是否过程中有数据丢失，那么 <code>server</code> 就可能在错误的时机仍然保持 <code>TCP</code> 连接端口来等待 <code>client</code> 确认数据已接受的请求或关闭当前 <code>TCP</code> 连接的请求，这样将带来一系列不必要的 <code>server</code> 性能开销。在 <code>client</code> 等待时间内没有正确接收请求时，<code>client</code> 就会关闭 <code>TCP</code> 连接。那么此时 <code>server</code> 也就没有必要为为无用的数据连接继续保持开启相应 <code>TCP</code> 连接端口。</p>\n</li>\n<li>\n<p>在有了三次握手的策略后，在正式请求之前，就可以确保当前 <code>TCP</code> 通道是可用的，及时发现当前 <code>TCP</code> 的网络问题。避免因网络问题导致的无用的数据传输带来的 <code>server</code> 端口常驻的性能开销。</p>\n</li>\n</ol>\n<h2 id="uri-url-urn"><a class="header-anchor" href="#uri-url-urn" aria-hidden="true">#</a> URI/URL/URN</h2>\n<p><code>URI</code>: Uniform Resource Identifier 统一资源标志符</p>\n<ul>\n<li>\n<p>用于唯一标识互联网中的信息资源</p>\n</li>\n<li>\n<p>包含 <code>URL</code> 和 <code>URN</code></p>\n</li>\n</ul>\n<p><code>URL</code>: Uniform Resource Locator 统一资源定位器</p>\n<ul>\n<li>\n<p>格式如下：</p>\n<p><code>protocol://user:pass@host.com:80/path?query=string#hash</code></p>\n<ul>\n<li>\n<p><code>protocol</code> 协议。如 <code>https</code>、<code>http</code>、<code>ftp</code> 等。</p>\n</li>\n<li>\n<p><code>user:pass</code> 用户验证。因暴露用户账号密码不安全，故不推荐使用。</p>\n</li>\n<li>\n<p><code>host</code> 主机名。</p>\n</li>\n<li>\n<p><code>80</code> 主机端口，默认为 <code>80</code>。每个物理主机端口都存放着不同的 web 服务。</p>\n</li>\n<li>\n<p><code>path</code> 路由。</p>\n<ol>\n<li>\n<p><code>/</code> 表示当前 <code>web</code> 服务的根目录，而不是主机的根目录。</p>\n</li>\n<li>\n<p><code>path</code> 路径默认情况下为 <code>web</code> 服务器下数据存放的路径。当数据库独立时，那么 <code>path</code> 仅表示数据的 <em><strong>存放地址</strong></em>，并不能表示该数据在服务器磁盘上的路径。</p>\n</li>\n<li>\n<p>故推荐在程序内部鉴别数据，而不是通过 URL 鉴别数据。</p>\n</li>\n</ol>\n</li>\n<li>\n<p><code>query=string</code> 查询参数。常用于向 <code>server</code> 端传参。</p>\n</li>\n<li>\n<p><code>hash</code> 哈希值。定位某个资源的某一片段。如文章的锚点。</p>\n</li>\n</ul>\n</li>\n</ul>\n<p><code>URN</code>: Uniform Resource Name （永久）统一资源定位符</p>\n<ul>\n<li>用于永久性在网络中标识出资源，因限制过多，已逐渐被 <code>URI</code> 取代。（<a href="https://en.wikipedia.org/wiki/Uniform_Resource_Name" target="_blank" rel="noopener noreferrer">extension<OutboundLink/></a>）</li>\n</ul>\n<h2 id="http-报文"><a class="header-anchor" href="#http-报文" aria-hidden="true">#</a> HTTP 报文</h2>\n<p><code>HTTP</code> 报文没有强约束，可自定义报文内容。</p>\n<p><img src="https://assets.set.sh/2018/180606-http-protocol/http-bw.svg" alt="http-bw"></p>\n<h2 id="http-方法"><a class="header-anchor" href="#http-方法" aria-hidden="true">#</a> HTTP 方法</h2>\n<ul>\n<li>\n<p>用来定义对于资源的操作</p>\n<ul>\n<li>\n<p>常用方法有 <code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>。另外还有 <code>HEAD</code>、<code>OPTIONS</code>、<code>PATCH</code> 方法。</p>\n</li>\n<li>\n<p>应该从开发人员的使用方式来定义各自方法的语义。</p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="http-code"><a class="header-anchor" href="#http-code" aria-hidden="true">#</a> HTTP code</h2>\n<ul>\n<li>\n<p>定义服务器对请求的处理结果。</p>\n<ul>\n<li>\n<p>2XX - Success - 表示成功处理请求。如 200。</p>\n</li>\n<li>\n<p>3XX - Redirection - 需要重定向，浏览器直接跳转。</p>\n</li>\n<li>\n<p>4XX - Client Error - 客户端请求错误。</p>\n</li>\n<li>\n<p>5XX - Server Error - 服务端响应错误。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>推荐 <code>server</code> 端正确配置 HTTP code，使得 HTTP code 语义化。好的 <code>HTTP</code> 服务应该可以通过 HTTP code 来判断请求结果。而不是只有 <code>200</code> 或 <code>500</code>。</p>\n</li>\n</ul>\n<p>拓展：<a href="http://tool.oschina.net/commons?type=5" target="_blank" rel="noopener noreferrer">code 码参考<OutboundLink/></a></p>\n<h2 id="http-客户端"><a class="header-anchor" href="#http-客户端" aria-hidden="true">#</a> HTTP 客户端</h2>\n<p>能够发起 HTTP 请求，并能够接收返回数据的客户端都可称为 HTTP 客户端。如 <code>curl</code>、<code>XMLHttpRequest</code>、浏览器等。</p>\n<p>除了在浏览器中可以观察 HTTP 请求的细节外，亦可使用 <code>curl</code> 命令行工具来观察。</p>\n<pre v-pre class="language-powershell"><code><span class="token comment"># -v 表示显示报文信息</span>\ncurl <span class="token operator">-</span>v www<span class="token punctuation">.</span>baidu<span class="token punctuation">.</span>com\n</code></pre>\n<p>返回数据如下：</p>\n<pre v-pre class="language-powershell"><code><span class="token operator">*</span> Rebuilt URL to: www<span class="token punctuation">.</span>google<span class="token punctuation">.</span>com<span class="token operator">/</span>\n  <span class="token operator">%</span> Total    <span class="token operator">%</span> Received <span class="token operator">%</span> Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n  0     0    0     0    0     0      0      0 <span class="token operator">--</span>:<span class="token operator">--</span>:<span class="token operator">--</span> <span class="token operator">--</span>:<span class="token operator">--</span>:<span class="token operator">--</span> <span class="token operator">--</span>:<span class="token operator">--</span>:<span class="token operator">--</span>     0<span class="token operator">*</span>\n  Trying 172<span class="token punctuation">.</span>217<span class="token punctuation">.</span>10<span class="token punctuation">.</span>132<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>\n<span class="token operator">*</span> TCP_NODELAY <span class="token function">set</span>\n<span class="token operator">*</span> Connected to www<span class="token punctuation">.</span>google<span class="token punctuation">.</span>com <span class="token punctuation">(</span>172<span class="token punctuation">.</span>217<span class="token punctuation">.</span>10<span class="token punctuation">.</span>132<span class="token punctuation">)</span> port 80 <span class="token punctuation">(</span><span class="token comment">#0)</span>\n<span class="token comment"># 请求报文</span>\n  <span class="token comment"># 起始行</span>\n> GET <span class="token operator">/</span> HTTP<span class="token operator">/</span>1<span class="token punctuation">.</span>1\n  <span class="token comment"># 首部</span>\n> Host: www<span class="token punctuation">.</span>google<span class="token punctuation">.</span>com\n> User<span class="token operator">-</span>Agent: curl<span class="token operator">/</span>7<span class="token punctuation">.</span>57<span class="token punctuation">.</span>0\n> Accept: <span class="token operator">*</span>/<span class="token operator">*</span>\n> <span class="token comment"># 此处有一空行</span>\n<span class="token comment"># 响应报文</span>\n  <span class="token comment"># 起始行</span>\n&lt; HTTP<span class="token operator">/</span>1<span class="token punctuation">.</span>1 200 OK\n  <span class="token comment"># 首部</span>\n&lt; Date: Thu<span class="token punctuation">,</span> 07 Jun 2018 14:28:45 GMT\n&lt; Expires: <span class="token operator">-</span>1\n&lt; Cache<span class="token operator">-</span>Control: private<span class="token punctuation">,</span> max<span class="token operator">-</span>age=0\n&lt; Content<span class="token operator">-</span><span class="token function">Type</span>: text<span class="token operator">/</span>html<span class="token punctuation">;</span> charset=ISO<span class="token operator">-</span>8859<span class="token operator">-</span>1\n<span class="token comment"># 省略一些信息</span>\n<span class="token comment"># ...</span>\n&lt; Transfer<span class="token operator">-</span>Encoding: chunked\n&lt;\n<span class="token punctuation">{</span> <span class="token punctuation">[</span>759 bytes <span class="token keyword">data</span><span class="token punctuation">]</span>\n100  3555    0  3555    0     0   3555      0 <span class="token operator">--</span>:<span class="token operator">--</span>:<span class="token operator">--</span>  0:00:01 <span class="token operator">--</span>:<span class="token operator">--</span>:<span class="token operator">--</span>  1834\n<span class="token comment"># 以下是响应报文的主体内容区域</span>\n<span class="token comment"># ...</span>\n&lt;<span class="token operator">!</span>doctype html>&lt;html\n</code></pre>\n<h2 id="http-首部"><a class="header-anchor" href="#http-首部" aria-hidden="true">#</a> HTTP 首部</h2>\n<p>在实现 <code>HTTP</code> 协议过程中，一系列功能都是通过配置相应的 <code>HTTP</code> 首部来实现的。</p>\n<p>👉<a href="/blog/writings/http-response/">HTTP 响应首部</a></p>\n<p>👉<a href="/blog/writings/http-request/">HTTP 请求首部</a></p>\n<h2 id="实战"><a class="header-anchor" href="#实战" aria-hidden="true">#</a> 实战</h2>\n<p>（以 <code>Nginx</code> 为例）</p>\n<p><code>Nginx</code>（<a href="https://nginx.org/en/" target="_blank" rel="noopener noreferrer">官网<OutboundLink/></a>）纯粹地实现 <code>HTTP</code> 协议，其中并不包含业务逻辑，正因如此它的 <em><strong>可拓展性强</strong></em>。</p>\n<h3 id="api"><a class="header-anchor" href="#api" aria-hidden="true">#</a> API</h3>\n<ul>\n<li><code>Nginx</code> API</li>\n</ul>\n<p>API 文档：<a href="http://nginx.org/en/docs/windows.html" target="_blank" rel="noopener noreferrer">API Docs<OutboundLink/></a></p>\n<p>命令行参数：<a href="http://nginx.org/en/docs/switches.html" target="_blank" rel="noopener noreferrer">Command-line parameters<OutboundLink/></a></p>\n<pre v-pre class="language-powershell"><code><span class="token comment"># -c file 使用一个指定的配置文件代替默认配置文件，默认值为 nginx/nginx.conf</span>\n\n<span class="token comment"># 启动服务</span>\n<span class="token function">start</span> nginx <span class="token punctuation">[</span><span class="token operator">-</span>c confFile<span class="token punctuation">]</span> <span class="token comment"># 推荐，但配置文件出错时，无提示信息</span>\n<span class="token comment"># 或者</span>\n<span class="token punctuation">.</span><span class="token operator">/</span>nginx <span class="token punctuation">[</span><span class="token operator">-</span>c confFile<span class="token punctuation">]</span> <span class="token comment"># 会占用当前窗口，但配置文件从出错时，有提示信息</span>\n\n<span class="token comment"># -s signal 发送一个 signal 到 nginx 主进程</span>\n<span class="token comment"># signal 值为 stop, quit, reload, reopen 之一</span>\n\n<span class="token comment"># 重启服务</span>\n<span class="token punctuation">.</span><span class="token operator">/</span>nginx <span class="token operator">-</span>s reload\n\n<span class="token comment"># 退出服务</span>\n<span class="token punctuation">.</span><span class="token operator">/</span>nginx <span class="token operator">-</span>s stop <span class="token comment"># 立即停止服务，可能不会保存相关信息</span>\n<span class="token punctuation">.</span><span class="token operator">/</span>nginx <span class="token operator">-</span>s quit <span class="token comment"># 有序地停止服务，并保存相关信息</span>\n\n<span class="token comment"># -g directives 发送一个全局配置指令</span>\n<span class="token comment"># HUP 指令，使用新的配置文件启动进程，之后平缓停止原有进程，即平滑重启</span>\n\n<span class="token comment"># 平滑重启</span>\n<span class="token punctuation">.</span><span class="token operator">/</span>nginx <span class="token operator">-</span>g HUP <span class="token punctuation">[</span><span class="token operator">-</span>c newConfFile<span class="token punctuation">]</span>\n\n<span class="token comment"># -t 检测配置文件。使用场景：用于上线前检测，避免上线错误</span>\n<span class="token punctuation">.</span><span class="token operator">/</span>nginx <span class="token operator">-</span>t <span class="token operator">-</span>c sample<span class="token punctuation">.</span>conf\n\n<span class="token comment"># 查看当前 nginx 进程号</span>\n<span class="token comment"># logs/nginx.pid 是 nginx.pid 的文件路径</span>\n<span class="token function">cat</span> logs<span class="token operator">/</span>nginx<span class="token punctuation">.</span>pid\n</code></pre>\n<ul>\n<li>系统 API</li>\n</ul>\n<pre v-pre class="language-powershell"><code><span class="token comment"># 查看端口占用，如 8800 端口</span>\n<span class="token comment"># -ano 是三个参数 -a -n -o 简写形式</span>\nnetstat <span class="token operator">-</span>ano<span class="token punctuation">|</span>findstr 8800\n\ntasklist <span class="token operator">/</span>? <span class="token comment"># 帮助文档</span>\n\n<span class="token comment"># /fi filter 显示一系列符合筛选器指定的进程</span>\n\n<span class="token comment"># 查看当前 nginx 进程</span>\n<span class="token comment"># 其中运算符 eq 表示 等于</span>\ntasklist <span class="token operator">/</span>fi <span class="token string">"imagename eq nginx.exe"</span> <span class="token comment"># cmd and powershell</span>\ntasklist <span class="token operator">/</span><span class="token operator">/</span>fi <span class="token string">"imagename eq nginx.exe"</span> <span class="token comment"># git bash for win</span>\n\n<span class="token comment"># 结束所有 nginx 进程</span>\n\ntskill nginx <span class="token comment"># 推荐</span>\n\n<span class="token comment"># /f 强行终止</span>\ntaskkill <span class="token operator">/</span>fi <span class="token string">"imagename eq nginx.exe"</span> <span class="token operator">/</span>f <span class="token comment"># cmd and powershell</span>\ntaskkill <span class="token operator">/</span><span class="token operator">/</span>fi <span class="token string">"imagename eq nginx.exe"</span> <span class="token operator">/</span><span class="token operator">/</span>f <span class="token comment"># git bash for win</span>\n\n<span class="token comment"># 与 pid 配合使用</span>\n<span class="token function">cat</span> logs<span class="token operator">/</span>nginx<span class="token punctuation">.</span>pid <span class="token comment"># 得到 Nginx 主进程 PID 值 pidNumber</span>\ntaskkill <span class="token operator">/</span><span class="token operator">/</span>pid pidNumber <span class="token operator">/</span><span class="token operator">/</span>f\n</code></pre>\n<p>注：<code>tasklist</code> 和 <code>taskkill</code> 命令在 <code>git bash for win</code> 中必须以双斜杠传参（<a href="https://stackoverflow.com/questions/34981745/taskkill-pid-not-working-in-gitbash" target="_blank" rel="noopener noreferrer">source<OutboundLink/></a>）。</p>\n<h3 id="代理基础配置"><a class="header-anchor" href="#代理基础配置" aria-hidden="true">#</a> 代理基础配置</h3>\n<ol>\n<li>在 <code>host</code> 文件中映射原始请求地址。示例：</li>\n</ol>\n<pre v-pre class="language-powershell"><code><span class="token comment"># 用于将 example.com 解析为 127.0.0.1，原理是 PC 首先在本地 host 文件中解析 URL</span>\n127<span class="token punctuation">.</span>0<span class="token punctuation">.</span>0<span class="token punctuation">.</span>1 example<span class="token punctuation">.</span>com\n</code></pre>\n<ol start="2">\n<li>单独配置 <code>servers/example.conf</code>，以模块化 <code>Nginx</code> 代理配置。</li>\n</ol>\n<p>拓展：<code>http</code> 是明文传输，故可在代理层修改原始请求的请求首部和内容。</p>\n<pre v-pre class="language-nginx"><code><span class="token comment"># 每个代理服务都在一个 server 中定义</span>\n<span class="token keyword">server</span> <span class="token punctuation">{</span>\n  <span class="token comment"># 监听的端口</span>\n  <span class="token keyword">listen</span>      <span class="token number">80</span><span class="token punctuation">;</span>\n  <span class="token comment"># 监听的 URL，即用户输入的 URL</span>\n  <span class="token keyword">server_name</span> test<span class="token punctuation">.</span>com<span class="token punctuation">;</span>\n\n  <span class="token comment"># 转发的目标地址</span>\n  <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>\n    <span class="token comment"># 1. 代理层接受到原始请求后，将发起一个新的请求至代理路径。依据 HTTP 原则，该新的请</span>\n    <span class="token comment"># 求的 host 默认为 proxy_pass。</span>\n    <span class="token comment"># 注：可于终端 server 打印并查看新请求的 host 请求首部。</span>\n    <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">8800</span><span class="token punctuation">;</span>\n    <span class="token comment"># 2. 恢复原始请求的 host 请求首部。变量 $host 即原始请求的 host 请求首部。</span>\n    <span class="token comment"># 注：经浏览器控制台 network tag 可查看原始请求的 host 请求首部</span>\n    <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>以上配置将实现 <code>example.com ==转发至==&gt; http://127.0.0.1:8800</code>。</p>\n<p><em><strong>注</strong></em>，代理服务器根据原始请求的 <code>host</code> 请求首部来 <em><strong>选择</strong></em> 代理的目标路径。即可以实现一个端口监听，多个路径代理。</p>\n<h3 id="缓存功能"><a class="header-anchor" href="#缓存功能" aria-hidden="true">#</a> 缓存功能</h3>\n<pre v-pre class="language-nginx"><code><span class="token comment"># proxy_cache_path 配置缓存存放路径</span>\n<span class="token comment"># levels 配置生成多级文件夹，使得多个代理分离为自己独立的文件夹</span>\n<span class="token comment"># keys_zone 配置在内存中分配给匹配的缓存（因为匹配的缓存将暂存在内存中）的区域名称和大小</span>\n<span class="token keyword">proxy_cache_path</span> cache levels<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">2</span> keys_zone<span class="token operator">=</span>my_cache<span class="token punctuation">:</span><span class="token number">10</span>m<span class="token punctuation">;</span> <span class="token comment"># 2 级目录，内存 10m</span>\n\n<span class="token keyword">server</span> <span class="token punctuation">{</span>\n  <span class="token keyword">listen</span>      <span class="token number">80</span><span class="token punctuation">;</span>\n  <span class="token keyword">server_name</span> test<span class="token punctuation">.</span>com<span class="token punctuation">;</span>\n\n  <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>\n    <span class="token keyword">proxy_cache</span> my_cache<span class="token punctuation">;</span> <span class="token comment"># 根据名字 my_caches 配置缓存存储的区域</span>\n    <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">8800</span><span class="token punctuation">;</span>\n    <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>代理缓存的应用场景：只要一次代理缓存，那么后续在缓存有效期内所有请求到代理服务器的请求都可使用该缓存，那么可大大节约向真正资源服务器请求的数量与时间。</p>\n<p>与代理缓存相关的响应首部（对于 <code>client</code> 来说）</p>\n<ol>\n<li>\n<p><code>Cache-Control</code></p>\n<ul>\n<li>\n<p><code>s-maxage</code>: 功能与 <code>max-age</code> 相同，且 <code>s-maxage</code> 覆盖 <code>max-age</code>。二者区别在于 <code>s-maxage</code> 适用对象仅限共享缓存的对象，如中转代理服务器。</p>\n</li>\n<li>\n<p><code>private</code>：标注只允许 <code>client</code> 缓存数据，中转代理服务器不能缓存该数据。</p>\n</li>\n</ul>\n<pre v-pre class="language-js"><code><span class="token comment">// 资源服务器</span>\nresponse<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token comment">// private 将导致 max-age 和 s-maxage 失效</span>\n  <span class="token string">\'Cache-Control\'</span><span class="token punctuation">:</span> <span class="token string">\'max-age=2, s-maxage=20, private\'</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<ul>\n<li><code>no-store</code>：路径中所有节点（包含 <code>client</code>）都不能缓存该响应数据。</li>\n</ul>\n<pre v-pre class="language-js"><code><span class="token comment">// 资源服务器</span>\nresponse<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token comment">// no-store 将导致 max-age 和 s-maxage 失效</span>\n  <span class="token string">\'Cache-Control\'</span><span class="token punctuation">:</span> <span class="token string">\'max-age=2, s-maxage=20, no-store\'</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n</li>\n<li>\n<p><code>Vary</code>: <code>Vary</code> 指定某一 <code>client</code> 端请求头，只有当该请求首部的值与上次请求首部的值相等时，才缓存响应数据。</p>\n<pre v-pre class="language-js"><code><span class="token comment">// client</span>\n<span class="token keyword">const</span> index <span class="token operator">=</span> <span class="token number">0</span>\n\n<span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'/data\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  headers<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 只有当此次 `x-test-Cache` 的值与上次请求相同时，才缓存此次响应数据</span>\n    <span class="token string">\'X-test-Cache\'</span><span class="token punctuation">:</span> index<span class="token operator">++</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<pre v-pre class="language-js"><code><span class="token comment">// 资源服务器</span>\nresponse<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token string">\'Cache-Control\'</span><span class="token punctuation">:</span> <span class="token string">\'s-maxage=200\'</span><span class="token punctuation">,</span>\n  <span class="token comment">// 只有当 `Vary` 所标注的请求首部当次值与上次请求时的值相同时，才缓存当前响应数据</span>\n  <span class="token string">\'Vary\'</span><span class="token punctuation">:</span> <span class="token string">\'X-test-Cache\'</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n</li>\n</ol>\n<p>适用场景：在同一 URL 情况下，根据不同的 <code>userAgent</code> 来缓存不同的响应数据。比如根据移动端与 PC 端返回不同的数据。</p>\n<h2 id="https"><a class="header-anchor" href="#https" aria-hidden="true">#</a> HTTPS</h2>\n<p><code>HTTP</code> 是明文传输，为了密文传输，诞生了 <code>HTTPS</code>。</p>\n<h3 id="加密与解密"><a class="header-anchor" href="#加密与解密" aria-hidden="true">#</a> 加密与解密</h3>\n<p>公钥（即服务端证书）用于加密被传输的数据。私钥用于解密被传输的数据。</p>\n<p>在握手阶段，进行公钥与私钥匹配。<code>client</code> 将在最初阶段传输加密套件，用于与 <code>server</code> 端内容协商（<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation" target="_blank" rel="noopener noreferrer">source<OutboundLink/></a>）选择最终使用的加密方式。私钥始终保持在 <code>server</code> 端，用于解密，那么据此保证了传输的安全性。</p>\n<p><img src="https://assets.set.sh/2018/180606-http-protocol/https-principle.svg" alt="https-principle"></p>\n<h3 id="部署"><a class="header-anchor" href="#部署" aria-hidden="true">#</a> 部署</h3>\n<ol>\n<li>生成证书（<a href="https://gist.github.com/lbwa/5607c3a66573610b5ccfd4ef4aaa780f" target="_blank" rel="noopener noreferrer">本地生成证书命令<OutboundLink/></a>）</li>\n</ol>\n<ol start="2">\n<li>配置 <code>Nginx</code> 代理</li>\n</ol>\n<p>（<a href="http://nginx.org/en/docs/http/configuring_https_servers.html" target="_blank" rel="noopener noreferrer">reference<OutboundLink/></a>）</p>\n<pre v-pre class="language-nginx"><code><span class="token keyword">proxy_cache_path</span> cache levels<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token number">2</span> keys_zone<span class="token operator">=</span>my_cache<span class="token punctuation">:</span><span class="token number">10</span>m<span class="token punctuation">;</span>\n\n<span class="token keyword">server</span> <span class="token punctuation">{</span>\n  <span class="token comment"># https 默认端口是 443</span>\n  <span class="token keyword">listen</span>      <span class="token number">443</span> <span class="token keyword">ssl</span><span class="token punctuation">;</span>\n  <span class="token keyword">server_name</span> test<span class="token punctuation">.</span>com<span class="token punctuation">;</span>\n\n  <span class="token comment"># ssl on; 于 1.15 版本中废弃，listen &lt;port> ssl 代替</span>\n  <span class="token keyword">ssl_certificate_key</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>certs<span class="token operator">/</span>localhost<span class="token operator">-</span>privkey<span class="token punctuation">.</span>pem<span class="token punctuation">;</span>\n  <span class="token keyword">ssl_certificate</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token operator">/</span>certs<span class="token operator">/</span>localhost<span class="token operator">-</span>cert<span class="token punctuation">.</span>pem<span class="token punctuation">;</span>\n\n  <span class="token keyword">location</span> <span class="token operator">/</span> <span class="token punctuation">{</span>\n    <span class="token keyword">proxy_cache</span> my_cache<span class="token punctuation">;</span>\n    <span class="token keyword">proxy_pass</span> <span class="token keyword">http</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token punctuation">:</span><span class="token number">8800</span><span class="token punctuation">;</span>\n    <span class="token keyword">proxy_set_header</span> Host <span class="token variable">$host</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>补充：将 <code>HTTP</code> 转发至 <code>HTTPS</code></p>\n<pre v-pre class="language-nginx"><code><span class="token comment"># 在 部署.2 的基础上实现</span>\n\n<span class="token keyword">server</span> <span class="token punctuation">{</span>\n  <span class="token keyword">listen</span>      <span class="token number">80</span> default_server<span class="token punctuation">;</span>\n  <span class="token keyword">listen</span>       <span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token punctuation">]</span><span class="token punctuation">:</span><span class="token number">80</span> default_server<span class="token punctuation">;</span>\n  <span class="token keyword">server_name</span> test<span class="token punctuation">.</span>com<span class="token punctuation">;</span>\n\n  <span class="token comment"># $server_name 接受请求的服务器的名称，此处即是 test.com</span>\n  <span class="token comment"># $request_uri 原始完整的请求 URL，包含查询参数，即访问主机上的路径，如 /api/data</span>\n  <span class="token keyword">return</span> <span class="token number">302</span> <span class="token keyword">https</span><span class="token punctuation">:</span><span class="token operator">/</span><span class="token operator">/</span><span class="token variable">$server_name</span><span class="token variable">$request_uri</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h2 id="http-2"><a class="header-anchor" href="#http-2" aria-hidden="true">#</a> HTTP 2</h2>\n<ol>\n<li>\n<p>信道复用，在单个 <code>TCP</code> 通道内可 <em><strong>并发请求</strong></em>，但在 <code>HTTP 1.1</code> 中单个 <code>TCP</code> 通道内是串行请求。</p>\n</li>\n<li>\n<p>分帧传输，每帧以包含上下文的形式传输，过程中不一定是按照顺序传输的。因为包含上下文，故在响应端，可根据上下文重组各帧还原数据。</p>\n</li>\n<li>\n<p>Server Push，<code>server</code> 端不再是只有被动接受请求才能响应，<code>server</code> 端在 <code>HTTP 2</code> 中可主动推送数据至 <code>client</code>。</p>\n</li>\n</ol>\n<h3 id="部署-2"><a class="header-anchor" href="#部署-2" aria-hidden="true">#</a> 部署</h3>\n<p>（<a href="http://nginx.org/en/docs/http/ngx_http_v2_module.html" target="_blank" rel="noopener noreferrer">reference<OutboundLink/></a>）</p>\n<p>在 <code>HTTP 2</code> 标准中，<code>HTTP 2</code> 并不强制使用 <code>HTTPS</code>。值得注意的是，目前浏览器都要在开启 <code>HTTPS</code> 的情况下才能使用 <code>HTTP 2</code>。</p>\n<pre v-pre class="language-nginx"><code><span class="token comment"># 中转服务器</span>\n<span class="token keyword">server</span> <span class="token punctuation">{</span>\n  <span class="token keyword">listen</span>             <span class="token number">443</span> <span class="token keyword">ssl</span> http2<span class="token punctuation">;</span>\n  <span class="token keyword">server_name</span>        test<span class="token punctuation">.</span>com<span class="token punctuation">;</span>\n  <span class="token comment"># 指定主动推送</span>\n  http2_push_preload on<span class="token punctuation">;</span>\n  <span class="token comment"># ...</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<ul>\n<li>\n<p>查看 <code>server</code> 端主动推送的相关信息，于地址栏输入 <code>chrome://net-internals/#http2</code> 查看。</p>\n</li>\n<li>\n<p>注：浏览器只会接受安全的认证过证书的 <code>server</code> 端推送的信息，否则主动推送信息将被忽略。</p>\n</li>\n</ul>\n<p>补充：<code>HTTPS</code> vs <code>HTTP 1.1</code> vs <code>HTTP 2</code> <a href="https://http2.akamai.com/demo/http2-lab.html" target="_blank" rel="noopener noreferrer">demo<OutboundLink/></a></p>\n<p><em><strong>注</strong></em>：<code>Nginx</code> 代理服务器可以为 <code>HTTP 2</code> 做兼容，他会根据 <code>client</code> 端所支持的协议返回响应数据，而不需要开发人员来做协议兼容。</p>\n'}],error:null,serverRendered:!0}</script><script defer src="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js"></script><script defer src="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js"></script><script defer src="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js"></script><script defer src="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js"></script><script defer src="/_nuxt/vendor.13de21511613edf061b2.js"></script><script defer src="/_nuxt/app.5a4fa6b8fcf73db97515.js"></script>