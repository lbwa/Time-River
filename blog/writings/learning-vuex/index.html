<!doctype html><html data-n-head="lang" data-n-head-ssr lang="zh"><meta data-n-head="true" content="IE=edge,chrome=1" http-equiv='"X-UA-Compatible'><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" name="viewport"><meta data-n-head="true" content="bowen blog, bowen 博客, vuejs, reactjs, ssr, 前端开发, 前端 , web开发, nodejs, github" name="keywords"><meta data-n-head="true" content="一个分享代码经历的地方" name="description" data-hid="description"><meta data-n-head="true" content="yes" name="apple-mobile-web-app-capable"><meta data-n-head="true" content="black" name="apple-mobile-web-app-status-bar-style"><meta data-n-head="true" content="yes" name="mobile-web-app-capable" data-hid="mobile-web-app-capable"><meta data-n-head="true" content="Bowen Blog" name="apple-mobile-web-app-title" data-hid="apple-mobile-web-app-title"><meta data-n-head="true" content="Bowen" name="author" data-hid="author"><meta data-n-head="true" content="#24292e" name="theme-color" data-hid="theme-color"><meta data-n-head="true" content="website" name="og:type" data-hid="og:type" property="og:type"><meta data-n-head="true" content="Bowen Blog" name="og:title" data-hid="og:title" property="og:title"><meta data-n-head="true" content="A place which is used to share programming experiences" name="og:description" data-hid="og:description" property="og:description"><title data-n-head="true">学习 vuex 基础 | Bowen Blog</title><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="/_nuxt/manifest.2108b1d4.json" rel="manifest" data-n-head="true"><link href="/_nuxt/icons/icon_64.e20A200w20w.png" rel="shortcut icon" data-n-head="true"><link href="/_nuxt/icons/icon_512.e20A200w20w.png" rel="apple-touch-icon" data-n-head="true" sizes="512x512"><link href="https://set.sh/blog/writings/learning-vuex/" rel="alternate" data-n-head="true" hreflang="zh"><link href="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js" rel="preload" as="script"><link href="/_nuxt/vendor.13de21511613edf061b2.js" rel="preload" as="script"><link href="/_nuxt/app.5a4fa6b8fcf73db97515.js" rel="preload" as="script"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="preload" as="style"><link href="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js" rel="preload" as="script"><link href="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/tags/_id/index.edb9dbabb1b9c2ef81f2.js" rel="prefetch"><link href="/_nuxt/pages/index.1d0ac68e309be0e86168.js" rel="prefetch"><link href="/_nuxt/pages/blog/tags/index.2659d358b69abdfd34bf.js" rel="prefetch"><link href="/_nuxt/pages/blog/projects/index.3ff8e031c3cb4f25eaed.js" rel="prefetch"><link href="/_nuxt/pages/blog/writings/index.b016af22016e152b7231.js" rel="prefetch"><link href="/_nuxt/layouts/home.dd55e95df1c2109ebde6.js" rel="prefetch"><link href="/_nuxt/layouts/default.89ffa224d3d7769e4fbb.js" rel="prefetch"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="stylesheet"><body data-n-head=""><div id="__nuxt" data-server-rendered="true"><div class="nuxt-progress" style="width:0%;height:2px;background-color:#3eaf7c;opacity:0"></div><div id="__layout"><section class="blog sf__parent__clearfix" data-v-cac63c14><header class="header __position components-animation" data-v-13c46026 data-v-cac63c14><nav class="mobile-navigator" data-v-13c46026 data-v-d4cae7a6><label class="label-line" data-v-d4cae7a6><span class="__position label-line line-top" data-v-d4cae7a6><span class="__position line-crust line-crust-top" data-v-d4cae7a6></span></span><span class="__position label-line line-bottom" data-v-d4cae7a6><span class="__position line-crust line-crust-bottom" data-v-d4cae7a6></span></span></label></nav><nav class="navigator __position grid" data-v-13c46026 role="navigation"><a href="/" class="navigator-link hover-animation grid-cell" data-v-13c46026>HOME</a><a href="/blog/writings/" class="navigator-link hover-animation grid-cell" data-v-13c46026>WRITINGS</a><a href="/blog/projects/" class="navigator-link hover-animation grid-cell" data-v-13c46026>PROJECTS</a><a href="/blog/tags/" class="navigator-link hover-animation grid-cell" data-v-13c46026>TAGS</a><a href="https://github.com/lbwa" class="navigator-link hover-animation grid-cell" data-v-13c46026 rel="noopener" target="_blank">GITHUB</a></nav><div class="background-helper __position" data-v-13c46026></div></header><main class="articles-container wrapper sf__reference__layout" data-v-cac63c14 role="main"><article class="articles-main"><div class="article-header"><h1 class="article-title">学习 vuex 基础</h1><span class="article-author">Bowen</span><span class="article-date">2018 MAR 06</span><div class="article-tags"><a href="/blog/tags/前端开发" class="article-tag">前端开发</a><a href="/blog/tags/vue.js" class="article-tag">Vue.js</a></div></div><div class="article-content"><h2 id="核心概念"><a href="#核心概念" class="header-anchor" aria-hidden="true">#</a> 核心概念</h2><p>vuex 就是将 vue 中需要管理的状态，全部集中到一个容器中，集中管理。下文代码中 store 指代 vuex 容器实例（<code>const store = new Vuex.Store({ ... })</code>），同时在组件中可使用<code>this.$store</code>来访问 vuex 容器实例。注意，在通过<code>this.$store</code>来访问各个选项时，选项名末尾除state外，都必须有<code>s</code>。<p>Vuex 通过 store 选项，提供了一种机制将状态从根组件"注入"到每一个子组件中（需调用<code>Vuex.use(Vuex)</code>）。通过在<strong>根实例</strong>中注册<code>store</code>选项，该 store 实例会注入到根组件下的<strong>所有</strong>子组件中，且子组件可以通过<code>this.$store</code>访问到。<h3 id="state-——-存储状态的容器"><a href="#state-——-存储状态的容器" class="header-anchor" aria-hidden="true">#</a> state —— 存储状态的容器</h3><p>state 用于缓存状态（计算属性）数据。可<strong>类比</strong>于 vue 实例中的 data 数据对象。<p>特点：<ol><li>具有响应式变化的特点，最简单读取 vuex 实例（store）的状态的方法是，在计算属性中返回某个状态。如下所示:</ol><pre class="language-js" v-pre><code>computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  <span class="token function">count</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>count
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>但是，一般的用法是，通过<strong>store选项</strong>注入到 vue 组件中。 2. <a href="https://vuex.vuejs.org/zh-cn/state.html" rel="noopener noreferrer" target="_blank">mapState 辅助函数<outboundlink></a>用于读取多个状态，生成计算属性（状态）<h3 id="getter-——-处理旧状态生成新状态"><a href="#getter-——-处理旧状态生成新状态" class="header-anchor" aria-hidden="true">#</a> getter —— 处理旧状态生成新状态</h3><p>getter 可<strong>类比</strong> vue 实例中的 computed 选项，可称为是 store 的计算属性。读取 state 中的数据A，经 getter 中的处理函数处理后返回生成一个新的状态数据B（A的计算属性）。<p>getter 暴露一个<code>store.getter</code>对象，这里<code>store</code>指的是 vuex 的实例对象，可写作<code>this.$store</code>或<code>$store</code>。getter 对象中包含了一些处理 state 中状态的处理函数。这些处理函数将返回一个新的状态数据，这些新的状态数据是<strong>储存于 getter 对象中的</strong>。<p>getter 中的处理函数接受 state 中的状态数据作为<strong>第一参数</strong>，另外可选的，可将 getter 中的其他 getter 作为<strong>第二参数</strong><p><code>mapGetters</code><a href="https://vuex.vuejs.org/zh-cn/getters.html" rel="noopener noreferrer" target="_blank">辅助函数<outboundlink></a>仅仅是将 store 中的 getter 映射到局部计算属性。<p><code>mapGetters</code>的实现和<code>mapState</code>很类似，不同的是<code>mapGetters</code>函数的参数<strong>不能是函数</strong>，只能是一个字符串。对比如下：<pre class="language-js" v-pre><code><span class="token keyword">import</span> <span class="token punctuation">{</span> mapState<span class="token punctuation">,</span> mapGetters <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  computed<span class="token punctuation">:</span> <span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token comment">// mapState 中可以传入函数</span>
    <span class="token comment">// 若要访问局部状态 state 必须借助一个普通函数</span>
    <span class="token function">countPlusLocalState</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>localCount
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 等价于</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
    <span class="token function">countPlusLocalState</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// this.$store.state 即为局部状态容器</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>localCount
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  <span class="token comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span>
    <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
      <span class="token string">'doneTodosCount'</span><span class="token punctuation">,</span><span class="token comment">// mapGetters 中不能传入函数</span>
      <span class="token string">'anotherGetter'</span><span class="token punctuation">,</span>
      <span class="token comment">// ...</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">// 等价于</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">doneTodosCount</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>getters<span class="token punctuation">[</span><span class="token string">'doneTodosCount'</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">anotherGetter</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>getters<span class="token punctuation">[</span><span class="token string">'anotherGetter'</span><span class="token punctuation">]</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre><h3 id="mutation-——-修改旧状态"><a href="#mutation-——-修改旧状态" class="header-anchor" aria-hidden="true">#</a> Mutation —— 修改旧状态</h3><h4 id="含义及作用"><a href="#含义及作用" class="header-anchor" aria-hidden="true">#</a> 含义及作用</h4><p>更改 vuex 的 store 中的状态的<strong>唯一方法</strong>是提交 mutation。可<strong>类比</strong>vue中的事件，提交 mutation <strong>类比</strong>触发事件(this.$emit(‘事件名’))。<p>每个 mutation 都有一个字符串类型的<strong>事件类型(type)<strong>和一个回调函数（接受 state 作为第一参数），该回调函数即是更改 state 状态的</strong>关键</strong>。回调函数的名称<strong>即是</strong>事件类型。<p>这种 mutation 中定义事件类型和回调函数的方式<strong>可看作</strong>是自定义事件注册。但<strong>不能直接调用</strong> mutation 中的回调函数。<h4 id="使用方法"><a href="#使用方法" class="header-anchor" aria-hidden="true">#</a> 使用方法</h4><p>不能直接调用 mutation handler，可类比调用<code>this.$emit</code>方法触发某自定义事件。那么，使用 mutation handler 的方法如下：<pre class="language-js" v-pre><code>store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'mutations 选项中的回调函数名'</span><span class="token punctuation">)</span>
</code></pre><blockquote><p><code>store.commit()</code>可传入一个可选项第二参数，作为载荷。 载荷的作用是带入 mutation handler 中作为参数使用。</blockquote><p>另外，还可以使用对象风格的提交方式（其中必包含事件类型 type ），该对象将整体传入 mutation 对象。如下所示提交 mutation 的三种方法：<pre class="language-js" v-pre><code>store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span>
<span class="token comment">// 或者写为</span>
store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> amount<span class="token punctuation">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 或者写为</span>
store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  type<span class="token punctuation">:</span> <span class="token string">'increment'</span><span class="token punctuation">,</span> <span class="token comment">// 将用于匹配对应的回调函数</span>
  amount<span class="token punctuation">:</span> <span class="token number">10</span> <span class="token comment">// 将作为 回调函数 的参数使用</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>综上，在组件中使用<code>this.$store.commit('xxx')</code>来提交 mutation。或使用<code>mapMutations</code>将组件的 methods 映射为<code>store.commit</code>调用（需要在根节点注入 store）<pre class="language-js" v-pre><code><span class="token keyword">import</span> <span class="token punctuation">{</span> mapMutations <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
      <span class="token comment">// 将 `this.increment()` 映射为 `this.$store.commit('increment')`</span>
      <span class="token string">'increment'</span><span class="token punctuation">,</span>

      <span class="token comment">// `mapMutations` 也支持载荷：</span>
      <span class="token string">'incrementBy'</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token comment">// 将 `this.add()` 映射为 `this.$store.commit('increment')`</span>
      add<span class="token punctuation">:</span> <span class="token string">'increment'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h4 id="注意事项"><a href="#注意事项" class="header-anchor" aria-hidden="true">#</a> 注意事项</h4><ol><li>mutations 选项中的方法是不分组件的 , 假如你在 A.js 文件中的定义了 fn 方法 , 在其他文件（B.js等等）中的一个 fn 方法 , 那么 $store.commit('fn') 会<strong>执行所有</strong>的 fn 方法。<li>mutations 选项中的操作<strong>必须是同步</strong>的。</ol><h3 id="action-——-可包含异步的“mutation”"><a href="#action-——-可包含异步的“mutation”" class="header-anchor" aria-hidden="true">#</a> Action —— 可包含异步的“Mutation”</h3><p>action 与 mutation 根本作用都是修改状态，不同之处在于：<ol><li>action 提交的是 mutation，而不是直接修改状态<li>action 可以包含任意异步操作</ol><p><strong>本质上</strong>，action 是通过提交 mutation 来修改状态的，最终还是回归到<strong>只有</strong> mutation 能够修改 state 中的状态。<p>actions 选项中的回调函数接受的<strong>参数</strong>是一个与 store 实例对象具有相同方法和属性的 context 对象。<p>常见<a href="https://vuex.vuejs.org/zh-cn/actions.html" rel="noopener noreferrer" target="_blank">action 注册<outboundlink></a>如下：<pre class="language-js" v-pre><code><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  state<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    count<span class="token punctuation">:</span> <span class="token number">0</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">increment</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      state<span class="token punctuation">.</span>count<span class="token operator">++</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">increment</span> <span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// comtext 与 store 有相同的属性和方法</span>
      context<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span> <span class="token comment">// action 通过提交 mutation 来修改状态</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>据<a href="https://vuex.vuejs.org/zh-cn/actions.html" rel="noopener noreferrer" target="_blank">vuex 官方文档<outboundlink></a>，有这么一段话：<blockquote><p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。</blockquote><p>因为在<a href="https://vuex.vuejs.org/zh-cn/actions.html" rel="noopener noreferrer" target="_blank">分发 action<outboundlink></a>时要使用到<code>store.dispatch</code>来触发 action 中的函数，那么我们给 action 对象中的函数定义时需要一个名字，该函数名作为分发 action 的<strong>依据</strong>。此时，该函数的参数对象会<strong>获得与 store 实例相同的方法和实例</strong>，而且因为有 ES6 的<a href="http://es6.ruanyifeng.com/#docs/destructuring#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC" rel="noopener noreferrer" target="_blank">解构赋值<outboundlink></a>的存在，那么之前注册 actions 选项的代码与下面的代码等价：<pre class="language-js" v-pre><code>actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>

  <span class="token comment">/**
   * 默认的 action 对象中的函数的参数对象将获得与 store 实例相同的方法和属性（容器实例
   * 默认有 commit 方法），那么 { commit } 对象是存在有 commit 方法的(因为 ES6 解构
   * 赋值)。commit 不仅仅是属性，还是方法。
   */</span>

  <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> commit <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h4 id="分发-action"><a href="#分发-action" class="header-anchor" aria-hidden="true">#</a> 分发 action</h4><p>action 通过<code>store.dispatch</code>方法触发分发。<pre class="language-js" v-pre><code>store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'actions 中的回调函数'</span><span class="token punctuation">)</span>
</code></pre><p>这里可总结为：<ol><li>action 中函数通过<code>this.$store.dispatch('xxx')</code>触发执行。<li>action 中函数内部通过<code>context.commit('xxx')</code>触发提交<code>mutations</code></ol><p>根据 action 本质还是提交 mutation 来说，不直接分发 mutation 的原因在于 mutation 必须是同步执行的。那么，分发 action 的<strong>意义</strong>在于可在 action 内部中<strong>执行异步操作</strong>。<p>在组件中使用<code>this.$store.dispatch('xxx')</code>分发 action，或者使用<code>mapActions</code>辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用（需要先在根节点注入 store ）：<pre class="language-js" v-pre><code><span class="token keyword">import</span> <span class="token punctuation">{</span> mapActions <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'vuex'</span>

<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
      <span class="token comment">// 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`</span>
      <span class="token string">'increment'</span><span class="token punctuation">,</span>

      <span class="token comment">// `mapActions` 也支持载荷：</span>
      <span class="token comment">// 映射为 `this.$store.dispatch('incrementBy', amount)`</span>
      <span class="token string">'incrementBy'</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
      <span class="token comment">// 将 `this.add()` 映射为 `this.$store.dispatch('increment')`</span>
      add<span class="token punctuation">:</span> <span class="token string">'increment'</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h4 id="组合-action"><a href="#组合-action" class="header-anchor" aria-hidden="true">#</a> 组合 action</h4><p>前文提到，action 对象内部可执行异步操作，那么如何知道其对象内部的处理函数何时执行结束？ 因为只有知道执行结束才能组合其他 action 中的处理函数，用于处理复杂的异步情况。<p>首先，必须明白<code>store.dispatch</code>可以处理 被触发的 action 内部的处理函数返回的 Promise，简而言之，<code>store.dispatch</code><strong>可以</strong>处理 Promise。并且<code>store.dispatch</code>方法本身仍旧<strong>返回 Promise 对象</strong>。<pre class="language-js" v-pre><code>actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  <span class="token function">actionA</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> commit <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> <span class="token comment">// actionA 函数返回一个 Promise</span>
      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
        <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'someMutation'</span><span class="token punctuation">)</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// store.dispatch 方法可处理 Promise 对象，那么有以下代码成立</span>
store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'actionA'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// store.dispatch 方法可处理 Promise 对象且本身返回 Promise ，那么可在 action 中可以</span>
<span class="token comment">// 调用其他的 action</span>
actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  <span class="token function">actionB</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> dispatch<span class="token punctuation">,</span> commit <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'actionA'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'someOtherMutation'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>因为有进化版的 Promise，即<a href="http://es6.ruanyifeng.com/#docs/async" rel="noopener noreferrer" target="_blank">async/await<outboundlink></a>，aysnc 函数本身返回一个 Promise 对象，那么我们可以据此组合 action：<pre class="language-js" v-pre><code><span class="token comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span>

actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  <span class="token keyword">async</span> <span class="token function">actionA</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> commit <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'gotData'</span><span class="token punctuation">,</span> <span class="token keyword">await</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  <span class="token keyword">async</span> <span class="token function">actionB</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> dispatch<span class="token punctuation">,</span> commit <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">await</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'actionA'</span><span class="token punctuation">)</span> <span class="token comment">// 等待 actionA 完成</span>
    <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'gotOtherData'</span><span class="token punctuation">,</span> <span class="token keyword">await</span> <span class="token function">getOtherData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h3 id="module-——-将-store-分割成模块"><a href="#module-——-将-store-分割成模块" class="header-anchor" aria-hidden="true">#</a> module —— 将 store 分割成模块</h3><p>每个模块可拥有自己的 store 容器，其中包含属于自己模块的 state、mutation、action、getter。store 容器中可使用 module 选项来<strong>包含其他模块的 store 容器</strong>。<h4 id="模块内的局部状态"><a href="#模块内的局部状态" class="header-anchor" aria-hidden="true">#</a> 模块内的局部状态</h4><p>对于模块内部的 mutation 和 getter，接收的第一个参数是模块的<strong>局部状态对象</strong>。<pre class="language-js" v-pre><code><span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>
  state<span class="token punctuation">:</span> <span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
  mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">increment</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 这里的 `state` 对象是模块的局部状态，指向 state: { count: 0 }</span>
      state<span class="token punctuation">.</span>count<span class="token operator">++</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>对于模块内部的 action，局部状态通过<code>context.state</code>暴露出来，根节点状态则为<code>context.rootState</code>（参数对象简写成以下代码格式的原因见 Action 章节简介）：<pre class="language-js" v-pre><code><span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// state 是局部状态，commit 是提交 mutation 的方法，rootState 是根节点状态</span>
    <span class="token function">incrementIfOddOnRootSum</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> state<span class="token punctuation">,</span> commit<span class="token punctuation">,</span> rootState <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> rootState<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'increment'</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：<pre class="language-js" v-pre><code><span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token comment">// ...</span>
  getters<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// state 是模块内的局部状态，getters 是调用其他的 getter，rootState 是根节点状态</span>
    <span class="token function">sumWithRootCount</span> <span class="token punctuation">(</span>state<span class="token punctuation">,</span> getters<span class="token punctuation">,</span> rootState<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 这里是三个参数，而不是一个对象</span>
      <span class="token keyword">return</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> rootState<span class="token punctuation">.</span>count
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><h4 id="命名空间"><a href="#命名空间" class="header-anchor" aria-hidden="true">#</a> 命名空间</h4><p>默认情况下，模块内部的 action、mutation 和 getter 是注册在<strong>全局</strong>命名空间的。<p>通过在 module 选项中添加<code>namespaced: true</code>来使模块成为成为<strong>命名空间模块</strong>，当模块被注册之后，它所有的 <code>getters</code>、<code>actions</code>、<code>mutations</code> 都会自动根据模块注册的路径<strong>调整</strong>命名。<pre class="language-js" v-pre><code><span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  modules<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    moduleA<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// namespaced 选项限定了模块下的 mutations 和 actions 的命名空间（作用域）</span>
      namespaced<span class="token punctuation">:</span> <span class="token boolean">true</span>
      <span class="token comment">//...</span>
      mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        <span class="token function">getSomeState</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// ...</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>在以上示例中，<code>namespaced</code> 选项限定了当前模块下的 <code>getters</code> 和 <code>mutations</code> 和 <code>actions</code> 的命名空间（或者理解为作用域），使得要调用它们必须先调用它们的模块。即 <code>this.$store.commit('moduleA/getSomeState')</code>。<pre class="language-js" v-pre><code><span class="token comment">// 组件内</span>
<span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
  <span class="token string">'moduleA/getSomeState'</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token comment">// 调用 Mutations</span>
<span class="token keyword">this</span><span class="token punctuation">[</span><span class="token string">'moduleA/getSomeState'</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><p>或者在组件中另外定义名称<pre class="language-js" v-pre><code><span class="token comment">// 组件内</span>
<span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  getSomeState<span class="token punctuation">:</span> <span class="token string">'moduleA/getSomeState'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 调用 Mutations</span>
<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSomeState</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><p>设置命名空间的好处是，可在不同的模块之间取<strong>同名</strong>的 <code>mutations</code> 等函数而不会冲突，它们也会获取自己命名空间的 <code>state</code>。<h5 id="命名空间内访问全局内容"><a href="#命名空间内访问全局内容" class="header-anchor" aria-hidden="true">#</a> 命名空间内访问全局内容</h5><p>特别地，在命名空间内，<code>rootState</code> 和 <code>rootGetters</code> 将作为<strong>第三</strong>和<strong>第四</strong>参数传入 <code>mutations</code>，在 <code>actions</code> 中作为 <code>context</code> 的属性传入，那么可在命名空间内调用 <code>rootState</code> 和 <code>rootGetters</code> 得到全局的 <code>state</code> 和 <code>getters</code>。<p>在命名空间内调用全局的 <code>mutations</code> 和 <code>actions</code> 时，<strong>必须</strong>添加第三参数 <code>{ root: true }</code> 来调用全局函数。否则调用的是命名空间内的函数。<pre class="language-js" v-pre><code><span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  modules<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    moduleA<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// namespaced 选项限定了模块下的 mutations 和 actions 的命名空间（作用域）</span>
      namespaced<span class="token punctuation">:</span> <span class="token boolean">true</span>
      <span class="token comment">//...</span>
      actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        getMoreState<span class="token punctuation">:</span> <span class="token punctuation">{</span>
          <span class="token comment">// context 包含了命名空间的所有 state, getters, mutations, actions,</span>
          <span class="token comment">// dispatch, commit, rootState, rootGetters</span>
          <span class="token comment">// 或根据需要写成形如 { commit } 的形式</span>
          <span class="token function">handler</span> <span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// ...</span>

            <span class="token comment">// 调用命名空间的 someOtherAction</span>
            context<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'someOtherAction'</span><span class="token punctuation">)</span>

            <span class="token comment">// 调用全局空间中的 someOtherAction，载荷为 null，即没有载荷</span>
            context<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'someOtherAction'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> root<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><h5 id="命名空间内注册全局-action"><a href="#命名空间内注册全局-action" class="header-anchor" aria-hidden="true">#</a> 命名空间内注册全局 action</h5><p>在注册时，添加 <code>root: true</code> 选项。<pre class="language-js" v-pre><code><span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  modules<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    moduleA<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      <span class="token comment">// namespaced 选项限定了模块下的 mutations 和 actions 的命名空间（作用域）</span>
      namespaced<span class="token punctuation">:</span> <span class="token boolean">true</span>
      <span class="token comment">//...</span>
      actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        getMoreState<span class="token punctuation">:</span> <span class="token punctuation">{</span>
          root<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
          <span class="token comment">// context 包含了命名空间的所有 state, getters, mutations, actions,</span>
          <span class="token comment">// dispatch, commit, rootState, rootGetters</span>
          <span class="token function">handler</span> <span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token comment">// ...</span>
          <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// ...</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><h5 id="兄弟命名空间调用"><a href="#兄弟命名空间调用" class="header-anchor" aria-hidden="true">#</a> 兄弟命名空间调用</h5><pre class="language-js" v-pre><code><span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  modules<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    moduleA<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      namespaced<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token comment">//...</span>
      mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        <span class="token function">getSomeState</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// ...</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
      <span class="token comment">// ...</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>

    moduleB<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      namespaced<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        <span class="token function">editModuleAState</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> commit <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token comment">// 补全命名空间路径，并指明 { root: true }</span>
          <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'moduleA/getSomeState'</span><span class="token punctuation">,</span> someDate<span class="token punctuation">,</span> <span class="token punctuation">{</span> root<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>由示例可知，兄弟命名空间的调用可通过全局调用 <code>{ root: true }</code> 来完成。</div></article><button data-v-e85d20b2 data-v-e85d20b2 class="floating-btn __position" style="display:none"><svg class="icon-rocket" data-v-e85d20b2 viewBox="0 0 512 512"><path d="M256 421.6c-18.1 0-33.2-6.8-42.9-10.9-5.4-2.3-11.3 1.8-10.9 7.6l3.5 51c.2 3.1 3.8 4.7 6.3 2.8l14.5-11c1.8-1.4 4.5-.9 5.7 1l20.5 32.1c1.5 2.4 5.1 2.4 6.6 0l20.5-32.1c1.2-1.9 3.9-2.4 5.7-1l14.5 11c2.5 1.9 6.1.3 6.3-2.8l3.5-51c.4-5.8-5.5-10-10.9-7.6-9.8 4.1-24.8 10.9-42.9 10.9z" data-v-e85d20b2></path><path d="M397.7 293.1l-48-49.1c0-158-93.2-228-93.2-228s-94.1 70-94.1 228l-48 49.1c-1.8 1.8-2.6 4.5-2.2 7.1L130.6 412c.9 5.7 7.1 8.5 11.8 5.4l67.1-45.4s20.7 20 47.1 20c26.4 0 46.1-20 46.1-20l67.1 45.4c4.6 3.1 10.8.3 11.8-5.4l18.5-111.9c.2-2.6-.6-5.2-2.4-7zM256.5 192c-17 0-30.7-14.3-30.7-32s13.8-32 30.7-32c17 0 30.7 14.3 30.7 32s-13.7 32-30.7 32z" data-v-e85d20b2></path></svg></button></main><footer class="blog-footer sf__main__layout grid col grid-jc-center" data-v-1044ad0a data-v-cac63c14><div class="footer-info" data-v-1044ad0a>Copyright © 2018 <a href="https://github.com/lbwa" class="author" rel="noopener" target="_blank" data-v-1044ad0a>Bowen</a></div></footer><section class="loading-wrapper grid col grid-center grid-jc-center" data-v-cac63c14 style="display:none"><div class="loading"><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div></div><a class="loading-tips">Loading</a></section></section></div></div><script type="text/javascript">window.__NUXT__={layout:"blog",data:[{menu:[{errno:0,to:"writings/dom-location",title:"获取 Element 在 document 中的位置信息",author:"Bowen",date:"2018 SEP 01",tags:["前端开发","CSS"]},{errno:0,to:"writings/spa-and-mpa",title:"SPA 与 MPA 的比较与优化",author:"Bowen",date:"2018 AUG 04",tags:["前端开发","SPA","MPA","skeleton"]},{errno:0,to:"writings/async-function-in-js",title:"Event loops 中的 AsyncFunction",author:"Bowen",date:"2018 JUL 26",tags:["JavaScript","async","事件循环"]},{errno:0,to:"writings/pwa-fundamentals",title:"PWA 基础",author:"Bowen",date:"2018 JUL 07",tags:["前端开发","PWA"]},{errno:0,to:"writings/js-design-pattern",title:"JS 设计模式",author:"Bowen",date:"2018 JUN 12",tags:["前端开发","设计模式"]},{errno:0,to:"writings/http-request",title:"HTTP 协议请求首部",author:"Bowen",date:"2018 JUN 08",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-response",title:"HTTP 协议响应首部",author:"Bowen",date:"2018 JUN 07",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-protocol",title:"HTTP 协议",author:"Bowen",date:"2018 JUN 06",tags:["前端开发","网络请求"]},{errno:0,to:"writings/execution-context",title:"JS 执行上下文",author:"Bowen",date:"2018 MAY 07",tags:["前端开发","JavaScript","执行上下文"]},{errno:0,to:"writings/vue-lifecycle-and-slots",title:"对 Vue 插槽和生命周期的一点思考",author:"Bowen",date:"2018 APR 24",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/learning-vue-unit-test",title:"总结如何进行单元测试",author:"Bowen",date:"2018 APR 21",tags:["前端开发","Vue.js","应用测试"]},{errno:0,to:"writings/cross-domain-solution",title:"客户端跨域解决方案",author:"Bowen",date:"2018 APR 19",tags:["前端开发","网络请求"]},{errno:0,to:"writings/css-bfc",title:"探究 BFC 以及闭合浮动原理",author:"Bowen",date:"2018 MAR 29",tags:["前端开发","CSS"]},{errno:0,to:"writings/vue.js-reusability-and-composition",title:"学习 Vue.js 可复用性和组合",author:"Bowen",date:"2018 MAR 12",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/event-loop",title:"解析 event loops",author:"Bowen",date:"2018 MAR 08",tags:["前端开发","JavaScript","事件循环"]},{errno:0,to:"writings/learning-vuex",title:"学习 vuex 基础",author:"Bowen",date:"2018 MAR 06",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/compare-commonjs-with-esm",title:"比较 CommonJS 与 ES6 Module 语法",author:"Bowen",date:"2018 FEB 27",tags:["前端开发","JavaScript","模块"]},{errno:0,to:"writings/learning-vuejs-essentials",title:"学习 Vue.js 基础",author:"Bowen",date:"2018 FEB 24",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/keyword-this",title:"理解 this 的指向",author:"Bowen",date:"2018 FEB 06",tags:["前端开发","JavaScript"]}]},{title:"学习 vuex 基础",date:"2018 MAR 06",author:"Bowen",tags:["前端开发","Vue.js"],content:'<h2 id="核心概念"><a class="header-anchor" href="#核心概念" aria-hidden="true">#</a> 核心概念</h2>\n<p>vuex 就是将 vue 中需要管理的状态，全部集中到一个容器中，集中管理。下文代码中 store 指代 vuex 容器实例（<code>const store = new Vuex.Store({ ... })</code>），同时在组件中可使用<code>this.$store</code>来访问 vuex 容器实例。注意，在通过<code>this.$store</code>来访问各个选项时，选项名末尾除state外，都必须有<code>s</code>。</p>\n<p>Vuex 通过 store 选项，提供了一种机制将状态从根组件&quot;注入&quot;到每一个子组件中（需调用<code>Vuex.use(Vuex)</code>）。通过在<strong>根实例</strong>中注册<code>store</code>选项，该 store 实例会注入到根组件下的<strong>所有</strong>子组件中，且子组件可以通过<code>this.$store</code>访问到。</p>\n<h3 id="state-——-存储状态的容器"><a class="header-anchor" href="#state-——-存储状态的容器" aria-hidden="true">#</a> state —— 存储状态的容器</h3>\n<p>state 用于缓存状态（计算属性）数据。可<strong>类比</strong>于 vue 实例中的 data 数据对象。</p>\n<p>特点：</p>\n<ol>\n<li>具有响应式变化的特点，最简单读取 vuex 实例（store）的状态的方法是，在计算属性中返回某个状态。如下所示:</li>\n</ol>\n<pre v-pre class="language-js"><code>computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n  <span class="token function">count</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>count\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>但是，一般的用法是，通过<strong>store选项</strong>注入到 vue 组件中。\n2. <a href="https://vuex.vuejs.org/zh-cn/state.html" target="_blank" rel="noopener noreferrer">mapState 辅助函数<OutboundLink/></a>用于读取多个状态，生成计算属性（状态）</p>\n<h3 id="getter-——-处理旧状态生成新状态"><a class="header-anchor" href="#getter-——-处理旧状态生成新状态" aria-hidden="true">#</a> getter —— 处理旧状态生成新状态</h3>\n<p>getter 可<strong>类比</strong> vue 实例中的 computed 选项，可称为是 store 的计算属性。读取 state 中的数据A，经 getter 中的处理函数处理后返回生成一个新的状态数据B（A的计算属性）。</p>\n<p>getter 暴露一个<code>store.getter</code>对象，这里<code>store</code>指的是 vuex 的实例对象，可写作<code>this.$store</code>或<code>$store</code>。getter 对象中包含了一些处理 state 中状态的处理函数。这些处理函数将返回一个新的状态数据，这些新的状态数据是<strong>储存于 getter 对象中的</strong>。</p>\n<p>getter 中的处理函数接受 state 中的状态数据作为<strong>第一参数</strong>，另外可选的，可将 getter 中的其他 getter 作为<strong>第二参数</strong></p>\n<p><code>mapGetters</code><a href="https://vuex.vuejs.org/zh-cn/getters.html" target="_blank" rel="noopener noreferrer">辅助函数<OutboundLink/></a>仅仅是将 store 中的 getter 映射到局部计算属性。</p>\n<p><code>mapGetters</code>的实现和<code>mapState</code>很类似，不同的是<code>mapGetters</code>函数的参数<strong>不能是函数</strong>，只能是一个字符串。对比如下：</p>\n<pre v-pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> mapState<span class="token punctuation">,</span> mapGetters <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'vuex\'</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  computed<span class="token punctuation">:</span> <span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n    <span class="token comment">// ...</span>\n    <span class="token comment">// mapState 中可以传入函数</span>\n    <span class="token comment">// 若要访问局部状态 state 必须借助一个普通函数</span>\n    <span class="token function">countPlusLocalState</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>localCount\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 等价于</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// ...</span>\n    <span class="token function">countPlusLocalState</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// this.$store.state 即为局部状态容器</span>\n      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>localCount\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span>\n    <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span>\n      <span class="token string">\'doneTodosCount\'</span><span class="token punctuation">,</span><span class="token comment">// mapGetters 中不能传入函数</span>\n      <span class="token string">\'anotherGetter\'</span><span class="token punctuation">,</span>\n      <span class="token comment">// ...</span>\n    <span class="token punctuation">]</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n<span class="token comment">// 等价于</span>\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token function">doneTodosCount</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>getters<span class="token punctuation">[</span><span class="token string">\'doneTodosCount\'</span><span class="token punctuation">]</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    <span class="token function">anotherGetter</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>getters<span class="token punctuation">[</span><span class="token string">\'anotherGetter\'</span><span class="token punctuation">]</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n</code></pre>\n<h3 id="mutation-——-修改旧状态"><a class="header-anchor" href="#mutation-——-修改旧状态" aria-hidden="true">#</a> Mutation —— 修改旧状态</h3>\n<h4 id="含义及作用"><a class="header-anchor" href="#含义及作用" aria-hidden="true">#</a> 含义及作用</h4>\n<p>更改 vuex 的 store 中的状态的<strong>唯一方法</strong>是提交 mutation。可<strong>类比</strong>vue中的事件，提交 mutation <strong>类比</strong>触发事件(this.$emit(‘事件名’))。</p>\n<p>每个 mutation 都有一个字符串类型的<strong>事件类型(type)<strong>和一个回调函数（接受 state 作为第一参数），该回调函数即是更改 state 状态的</strong>关键</strong>。回调函数的名称<strong>即是</strong>事件类型。</p>\n<p>这种 mutation 中定义事件类型和回调函数的方式<strong>可看作</strong>是自定义事件注册。但<strong>不能直接调用</strong> mutation 中的回调函数。</p>\n<h4 id="使用方法"><a class="header-anchor" href="#使用方法" aria-hidden="true">#</a> 使用方法</h4>\n<p>不能直接调用 mutation handler，可类比调用<code>this.$emit</code>方法触发某自定义事件。那么，使用 mutation handler 的方法如下：</p>\n<pre v-pre class="language-js"><code>store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'mutations 选项中的回调函数名\'</span><span class="token punctuation">)</span>\n</code></pre>\n<blockquote>\n<p><code>store.commit()</code>可传入一个可选项第二参数，作为载荷。 载荷的作用是带入 mutation handler 中作为参数使用。</p>\n</blockquote>\n<p>另外，还可以使用对象风格的提交方式（其中必包含事件类型 type ），该对象将整体传入 mutation 对象。如下所示提交 mutation 的三种方法：</p>\n<pre v-pre class="language-js"><code>store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">)</span>\n<span class="token comment">// 或者写为</span>\nstore<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> amount<span class="token punctuation">:</span> <span class="token number">10</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token comment">// 或者写为</span>\nstore<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  type<span class="token punctuation">:</span> <span class="token string">\'increment\'</span><span class="token punctuation">,</span> <span class="token comment">// 将用于匹配对应的回调函数</span>\n  amount<span class="token punctuation">:</span> <span class="token number">10</span> <span class="token comment">// 将作为 回调函数 的参数使用</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>综上，在组件中使用<code>this.$store.commit(\'xxx\')</code>来提交 mutation。或使用<code>mapMutations</code>将组件的 methods 映射为<code>store.commit</code>调用（需要在根节点注入 store）</p>\n<pre v-pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> mapMutations <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'vuex\'</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">[</span>\n      <span class="token comment">// 将 `this.increment()` 映射为 `this.$store.commit(\'increment\')`</span>\n      <span class="token string">\'increment\'</span><span class="token punctuation">,</span>\n\n      <span class="token comment">// `mapMutations` 也支持载荷：</span>\n      <span class="token string">\'incrementBy\'</span>\n    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      <span class="token comment">// 将 `this.add()` 映射为 `this.$store.commit(\'increment\')`</span>\n      add<span class="token punctuation">:</span> <span class="token string">\'increment\'</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h4 id="注意事项"><a class="header-anchor" href="#注意事项" aria-hidden="true">#</a> 注意事项</h4>\n<ol>\n<li>mutations 选项中的方法是不分组件的 , 假如你在 A.js 文件中的定义了\nfn 方法 , 在其他文件（B.js等等）中的一个 fn 方法 , 那么\n$store.commit(\'fn\') 会<strong>执行所有</strong>的 fn 方法。</li>\n<li>mutations 选项中的操作<strong>必须是同步</strong>的。</li>\n</ol>\n<h3 id="action-——-可包含异步的“mutation”"><a class="header-anchor" href="#action-——-可包含异步的“mutation”" aria-hidden="true">#</a> Action —— 可包含异步的“Mutation”</h3>\n<p>action 与 mutation 根本作用都是修改状态，不同之处在于：</p>\n<ol>\n<li>action 提交的是 mutation，而不是直接修改状态</li>\n<li>action 可以包含任意异步操作</li>\n</ol>\n<p><strong>本质上</strong>，action 是通过提交 mutation 来修改状态的，最终还是回归到<strong>只有</strong> mutation 能够修改 state 中的状态。</p>\n<p>actions 选项中的回调函数接受的<strong>参数</strong>是一个与 store 实例对象具有相同方法和属性的 context 对象。</p>\n<p>常见<a href="https://vuex.vuejs.org/zh-cn/actions.html" target="_blank" rel="noopener noreferrer">action 注册<OutboundLink/></a>如下：</p>\n<pre v-pre class="language-js"><code><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  state<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    count<span class="token punctuation">:</span> <span class="token number">0</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token function">increment</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      state<span class="token punctuation">.</span>count<span class="token operator">++</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token function">increment</span> <span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// comtext 与 store 有相同的属性和方法</span>\n      context<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">)</span> <span class="token comment">// action 通过提交 mutation 来修改状态</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>据<a href="https://vuex.vuejs.org/zh-cn/actions.html" target="_blank" rel="noopener noreferrer">vuex 官方文档<OutboundLink/></a>，有这么一段话：</p>\n<blockquote>\n<p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。</p>\n</blockquote>\n<p>因为在<a href="https://vuex.vuejs.org/zh-cn/actions.html" target="_blank" rel="noopener noreferrer">分发 action<OutboundLink/></a>时要使用到<code>store.dispatch</code>来触发 action 中的函数，那么我们给 action 对象中的函数定义时需要一个名字，该函数名作为分发 action 的<strong>依据</strong>。此时，该函数的参数对象会<strong>获得与 store 实例相同的方法和实例</strong>，而且因为有 ES6 的<a href="http://es6.ruanyifeng.com/#docs/destructuring#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC" target="_blank" rel="noopener noreferrer">解构赋值<OutboundLink/></a>的存在，那么之前注册 actions 选项的代码与下面的代码等价：</p>\n<pre v-pre class="language-js"><code>actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n\n  <span class="token comment">/**\n   * 默认的 action 对象中的函数的参数对象将获得与 store 实例相同的方法和属性（容器实例\n   * 默认有 commit 方法），那么 { commit } 对象是存在有 commit 方法的(因为 ES6 解构\n   * 赋值)。commit 不仅仅是属性，还是方法。\n   */</span>\n\n  <span class="token function">increment</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> commit <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h4 id="分发-action"><a class="header-anchor" href="#分发-action" aria-hidden="true">#</a> 分发 action</h4>\n<p>action 通过<code>store.dispatch</code>方法触发分发。</p>\n<pre v-pre class="language-js"><code>store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">\'actions 中的回调函数\'</span><span class="token punctuation">)</span>\n</code></pre>\n<p>这里可总结为：</p>\n<ol>\n<li>action 中函数通过<code>this.$store.dispatch(\'xxx\')</code>触发执行。</li>\n<li>action 中函数内部通过<code>context.commit(\'xxx\')</code>触发提交<code>mutations</code></li>\n</ol>\n<p>根据 action 本质还是提交 mutation 来说，不直接分发 mutation 的原因在于 mutation 必须是同步执行的。那么，分发 action 的<strong>意义</strong>在于可在 action 内部中<strong>执行异步操作</strong>。</p>\n<p>在组件中使用<code>this.$store.dispatch(\'xxx\')</code>分发 action，或者使用<code>mapActions</code>辅助函数将组件的 methods 映射为 <code>store.dispatch</code> 调用（需要先在根节点注入 store ）：</p>\n<pre v-pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> mapActions <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">\'vuex\'</span>\n\n<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span>\n      <span class="token comment">// 将 `this.increment()` 映射为 `this.$store.dispatch(\'increment\')`</span>\n      <span class="token string">\'increment\'</span><span class="token punctuation">,</span>\n\n      <span class="token comment">// `mapActions` 也支持载荷：</span>\n      <span class="token comment">// 映射为 `this.$store.dispatch(\'incrementBy\', amount)`</span>\n      <span class="token string">\'incrementBy\'</span>\n    <span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n      <span class="token comment">// 将 `this.add()` 映射为 `this.$store.dispatch(\'increment\')`</span>\n      add<span class="token punctuation">:</span> <span class="token string">\'increment\'</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h4 id="组合-action"><a class="header-anchor" href="#组合-action" aria-hidden="true">#</a> 组合 action</h4>\n<p>前文提到，action 对象内部可执行异步操作，那么如何知道其对象内部的处理函数何时执行结束？\n因为只有知道执行结束才能组合其他 action 中的处理函数，用于处理复杂的异步情况。</p>\n<p>首先，必须明白<code>store.dispatch</code>可以处理 被触发的 action 内部的处理函数返回的 Promise，简而言之，<code>store.dispatch</code><strong>可以</strong>处理 Promise。并且<code>store.dispatch</code>方法本身仍旧<strong>返回 Promise 对象</strong>。</p>\n<pre v-pre class="language-js"><code>actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n  <span class="token function">actionA</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> commit <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> <span class="token comment">// actionA 函数返回一个 Promise</span>\n      <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n        <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'someMutation\'</span><span class="token punctuation">)</span>\n        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// store.dispatch 方法可处理 Promise 对象，那么有以下代码成立</span>\nstore<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">\'actionA\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// store.dispatch 方法可处理 Promise 对象且本身返回 Promise ，那么可在 action 中可以</span>\n<span class="token comment">// 调用其他的 action</span>\nactions<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  <span class="token function">actionB</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> dispatch<span class="token punctuation">,</span> commit <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">\'actionA\'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'someOtherMutation\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>因为有进化版的 Promise，即<a href="http://es6.ruanyifeng.com/#docs/async" target="_blank" rel="noopener noreferrer">async/await<OutboundLink/></a>，aysnc 函数本身返回一个 Promise 对象，那么我们可以据此组合 action：</p>\n<pre v-pre class="language-js"><code><span class="token comment">// 假设 getData() 和 getOtherData() 返回的是 Promise</span>\n\nactions<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n  <span class="token keyword">async</span> <span class="token function">actionA</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> commit <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'gotData\'</span><span class="token punctuation">,</span> <span class="token keyword">await</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  <span class="token keyword">async</span> <span class="token function">actionB</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> dispatch<span class="token punctuation">,</span> commit <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">await</span> <span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">\'actionA\'</span><span class="token punctuation">)</span> <span class="token comment">// 等待 actionA 完成</span>\n    <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'gotOtherData\'</span><span class="token punctuation">,</span> <span class="token keyword">await</span> <span class="token function">getOtherData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h3 id="module-——-将-store-分割成模块"><a class="header-anchor" href="#module-——-将-store-分割成模块" aria-hidden="true">#</a> module —— 将 store 分割成模块</h3>\n<p>每个模块可拥有自己的 store 容器，其中包含属于自己模块的 state、mutation、action、getter。store 容器中可使用 module 选项来<strong>包含其他模块的 store 容器</strong>。</p>\n<h4 id="模块内的局部状态"><a class="header-anchor" href="#模块内的局部状态" aria-hidden="true">#</a> 模块内的局部状态</h4>\n<p>对于模块内部的 mutation 和 getter，接收的第一个参数是模块的<strong>局部状态对象</strong>。</p>\n<pre v-pre class="language-js"><code><span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>\n  state<span class="token punctuation">:</span> <span class="token punctuation">{</span> count<span class="token punctuation">:</span> <span class="token number">0</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token function">increment</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 这里的 `state` 对象是模块的局部状态，指向 state: { count: 0 }</span>\n      state<span class="token punctuation">.</span>count<span class="token operator">++</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>对于模块内部的 action，局部状态通过<code>context.state</code>暴露出来，根节点状态则为<code>context.rootState</code>（参数对象简写成以下代码格式的原因见 Action 章节简介）：</p>\n<pre v-pre class="language-js"><code><span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// state 是局部状态，commit 是提交 mutation 的方法，rootState 是根节点状态</span>\n    <span class="token function">incrementIfOddOnRootSum</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> state<span class="token punctuation">,</span> commit<span class="token punctuation">,</span> rootState <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>state<span class="token punctuation">.</span>count <span class="token operator">+</span> rootState<span class="token punctuation">.</span>count<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'increment\'</span><span class="token punctuation">)</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：</p>\n<pre v-pre class="language-js"><code><span class="token keyword">const</span> moduleA <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token comment">// ...</span>\n  getters<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// state 是模块内的局部状态，getters 是调用其他的 getter，rootState 是根节点状态</span>\n    <span class="token function">sumWithRootCount</span> <span class="token punctuation">(</span>state<span class="token punctuation">,</span> getters<span class="token punctuation">,</span> rootState<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">// 这里是三个参数，而不是一个对象</span>\n      <span class="token keyword">return</span> state<span class="token punctuation">.</span>count <span class="token operator">+</span> rootState<span class="token punctuation">.</span>count\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<h4 id="命名空间"><a class="header-anchor" href="#命名空间" aria-hidden="true">#</a> 命名空间</h4>\n<p>默认情况下，模块内部的 action、mutation 和 getter 是注册在<strong>全局</strong>命名空间的。</p>\n<p>通过在 module 选项中添加<code>namespaced: true</code>来使模块成为成为<strong>命名空间模块</strong>，当模块被注册之后，它所有的 <code>getters</code>、<code>actions</code>、<code>mutations</code> 都会自动根据模块注册的路径<strong>调整</strong>命名。</p>\n<pre v-pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  modules<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    moduleA<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      <span class="token comment">// namespaced 选项限定了模块下的 mutations 和 actions 的命名空间（作用域）</span>\n      namespaced<span class="token punctuation">:</span> <span class="token boolean">true</span>\n      <span class="token comment">//...</span>\n      mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n        <span class="token function">getSomeState</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token comment">// ...</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>在以上示例中，<code>namespaced</code> 选项限定了当前模块下的 <code>getters</code> 和 <code>mutations</code> 和 <code>actions</code> 的命名空间（或者理解为作用域），使得要调用它们必须先调用它们的模块。即 <code>this.$store.commit(\'moduleA/getSomeState\')</code>。</p>\n<pre v-pre class="language-js"><code><span class="token comment">// 组件内</span>\n<span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">[</span>\n  <span class="token string">\'moduleA/getSomeState\'</span>\n<span class="token punctuation">]</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 调用 Mutations</span>\n<span class="token keyword">this</span><span class="token punctuation">[</span><span class="token string">\'moduleA/getSomeState\'</span><span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre>\n<p>或者在组件中另外定义名称</p>\n<pre v-pre class="language-js"><code><span class="token comment">// 组件内</span>\n<span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  getSomeState<span class="token punctuation">:</span> <span class="token string">\'moduleA/getSomeState\'</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 调用 Mutations</span>\n<span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getSomeState</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n</code></pre>\n<p>设置命名空间的好处是，可在不同的模块之间取<strong>同名</strong>的 <code>mutations</code> 等函数而不会冲突，它们也会获取自己命名空间的 <code>state</code>。</p>\n<h5 id="命名空间内访问全局内容"><a class="header-anchor" href="#命名空间内访问全局内容" aria-hidden="true">#</a> 命名空间内访问全局内容</h5>\n<p>特别地，在命名空间内，<code>rootState</code> 和 <code>rootGetters</code> 将作为<strong>第三</strong>和<strong>第四</strong>参数传入 <code>mutations</code>，在 <code>actions</code> 中作为 <code>context</code> 的属性传入，那么可在命名空间内调用 <code>rootState</code> 和 <code>rootGetters</code> 得到全局的 <code>state</code> 和 <code>getters</code>。</p>\n<p>在命名空间内调用全局的 <code>mutations</code> 和 <code>actions</code> 时，<strong>必须</strong>添加第三参数 <code>{ root: true }</code> 来调用全局函数。否则调用的是命名空间内的函数。</p>\n<pre v-pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  modules<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    moduleA<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      <span class="token comment">// namespaced 选项限定了模块下的 mutations 和 actions 的命名空间（作用域）</span>\n      namespaced<span class="token punctuation">:</span> <span class="token boolean">true</span>\n      <span class="token comment">//...</span>\n      actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n        getMoreState<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n          <span class="token comment">// context 包含了命名空间的所有 state, getters, mutations, actions,</span>\n          <span class="token comment">// dispatch, commit, rootState, rootGetters</span>\n          <span class="token comment">// 或根据需要写成形如 { commit } 的形式</span>\n          <span class="token function">handler</span> <span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// ...</span>\n\n            <span class="token comment">// 调用命名空间的 someOtherAction</span>\n            context<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">\'someOtherAction\'</span><span class="token punctuation">)</span>\n\n            <span class="token comment">// 调用全局空间中的 someOtherAction，载荷为 null，即没有载荷</span>\n            context<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">\'someOtherAction\'</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> root<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n          <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// ...</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h5 id="命名空间内注册全局-action"><a class="header-anchor" href="#命名空间内注册全局-action" aria-hidden="true">#</a> 命名空间内注册全局 action</h5>\n<p>在注册时，添加 <code>root: true</code> 选项。</p>\n<pre v-pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  modules<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    moduleA<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      <span class="token comment">// namespaced 选项限定了模块下的 mutations 和 actions 的命名空间（作用域）</span>\n      namespaced<span class="token punctuation">:</span> <span class="token boolean">true</span>\n      <span class="token comment">//...</span>\n      actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n        getMoreState<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n          root<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n          <span class="token comment">// context 包含了命名空间的所有 state, getters, mutations, actions,</span>\n          <span class="token comment">// dispatch, commit, rootState, rootGetters</span>\n          <span class="token function">handler</span> <span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n            <span class="token comment">// ...</span>\n          <span class="token punctuation">}</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// ...</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h5 id="兄弟命名空间调用"><a class="header-anchor" href="#兄弟命名空间调用" aria-hidden="true">#</a> 兄弟命名空间调用</h5>\n<pre v-pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  modules<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    moduleA<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      namespaced<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n      <span class="token comment">//...</span>\n      mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n        <span class="token function">getSomeState</span> <span class="token punctuation">(</span>state<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token comment">// ...</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n      <span class="token comment">// ...</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n    moduleB<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      namespaced<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>\n      actions<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n        <span class="token function">editModuleAState</span> <span class="token punctuation">(</span><span class="token punctuation">{</span> commit <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          <span class="token comment">// 补全命名空间路径，并指明 { root: true }</span>\n          <span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">\'moduleA/getSomeState\'</span><span class="token punctuation">,</span> someDate<span class="token punctuation">,</span> <span class="token punctuation">{</span> root<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>由示例可知，兄弟命名空间的调用可通过全局调用 <code>{ root: true }</code> 来完成。</p>\n'}],error:null,serverRendered:!0}</script><script defer src="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js"></script><script defer src="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js"></script><script defer src="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js"></script><script defer src="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js"></script><script defer src="/_nuxt/vendor.13de21511613edf061b2.js"></script><script defer src="/_nuxt/app.5a4fa6b8fcf73db97515.js"></script>