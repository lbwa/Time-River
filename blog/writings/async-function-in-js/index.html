<!doctype html><html data-n-head="lang" data-n-head-ssr lang="zh"><meta data-n-head="true" content="IE=edge,chrome=1" http-equiv='"X-UA-Compatible'><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" name="viewport"><meta data-n-head="true" content="bowen blog, bowen 博客, vuejs, reactjs, ssr, 前端开发, 前端 , web开发, nodejs, github" name="keywords"><meta data-n-head="true" content="一个分享代码经历的地方" name="description" data-hid="description"><meta data-n-head="true" content="yes" name="apple-mobile-web-app-capable"><meta data-n-head="true" content="black" name="apple-mobile-web-app-status-bar-style"><meta data-n-head="true" content="yes" name="mobile-web-app-capable" data-hid="mobile-web-app-capable"><meta data-n-head="true" content="Bowen Blog" name="apple-mobile-web-app-title" data-hid="apple-mobile-web-app-title"><meta data-n-head="true" content="Bowen" name="author" data-hid="author"><meta data-n-head="true" content="#24292e" name="theme-color" data-hid="theme-color"><meta data-n-head="true" content="website" name="og:type" data-hid="og:type" property="og:type"><meta data-n-head="true" content="Bowen Blog" name="og:title" data-hid="og:title" property="og:title"><meta data-n-head="true" content="A place which is used to share programming experiences" name="og:description" data-hid="og:description" property="og:description"><title data-n-head="true">Event loops 中的 AsyncFunction | Bowen Blog</title><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="/_nuxt/manifest.2108b1d4.json" rel="manifest" data-n-head="true"><link href="/_nuxt/icons/icon_64.e20A200w20w.png" rel="shortcut icon" data-n-head="true"><link href="/_nuxt/icons/icon_512.e20A200w20w.png" rel="apple-touch-icon" data-n-head="true" sizes="512x512"><link href="https://set.sh/blog/writings/async-function-in-js/" rel="alternate" data-n-head="true" hreflang="zh"><link href="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js" rel="preload" as="script"><link href="/_nuxt/vendor.13de21511613edf061b2.js" rel="preload" as="script"><link href="/_nuxt/app.5a4fa6b8fcf73db97515.js" rel="preload" as="script"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="preload" as="style"><link href="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js" rel="preload" as="script"><link href="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/tags/_id/index.edb9dbabb1b9c2ef81f2.js" rel="prefetch"><link href="/_nuxt/pages/index.1d0ac68e309be0e86168.js" rel="prefetch"><link href="/_nuxt/pages/blog/tags/index.2659d358b69abdfd34bf.js" rel="prefetch"><link href="/_nuxt/pages/blog/projects/index.3ff8e031c3cb4f25eaed.js" rel="prefetch"><link href="/_nuxt/pages/blog/writings/index.b016af22016e152b7231.js" rel="prefetch"><link href="/_nuxt/layouts/home.dd55e95df1c2109ebde6.js" rel="prefetch"><link href="/_nuxt/layouts/default.89ffa224d3d7769e4fbb.js" rel="prefetch"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="stylesheet"><body data-n-head=""><div id="__nuxt" data-server-rendered="true"><div class="nuxt-progress" style="width:0%;height:2px;background-color:#3eaf7c;opacity:0"></div><div id="__layout"><section class="blog sf__parent__clearfix" data-v-cac63c14><header class="header __position components-animation" data-v-13c46026 data-v-cac63c14><nav class="mobile-navigator" data-v-13c46026 data-v-d4cae7a6><label class="label-line" data-v-d4cae7a6><span class="__position label-line line-top" data-v-d4cae7a6><span class="__position line-crust line-crust-top" data-v-d4cae7a6></span></span><span class="__position label-line line-bottom" data-v-d4cae7a6><span class="__position line-crust line-crust-bottom" data-v-d4cae7a6></span></span></label></nav><nav class="navigator __position grid" data-v-13c46026 role="navigation"><a href="/" class="navigator-link hover-animation grid-cell" data-v-13c46026>HOME</a><a href="/blog/writings/" class="navigator-link hover-animation grid-cell" data-v-13c46026>WRITINGS</a><a href="/blog/projects/" class="navigator-link hover-animation grid-cell" data-v-13c46026>PROJECTS</a><a href="/blog/tags/" class="navigator-link hover-animation grid-cell" data-v-13c46026>TAGS</a><a href="https://github.com/lbwa" rel="noopener" target="_blank" class="navigator-link hover-animation grid-cell" data-v-13c46026>GITHUB</a></nav><div class="background-helper __position" data-v-13c46026></div></header><main class="articles-container wrapper sf__reference__layout" data-v-cac63c14 role="main"><article class="articles-main"><div class="article-header"><h1 class="article-title">Event loops 中的 AsyncFunction</h1><span class="article-author">Bowen</span><span class="article-date">2018 JUL 26</span><div class="article-tags"><a href="/blog/tags/javascript" class="article-tag">JavaScript</a><a href="/blog/tags/async" class="article-tag">async</a><a href="/blog/tags/事件循环" class="article-tag">事件循环</a></div></div><div class="article-content"><blockquote><p>本文旨在讨论 <code>async function</code> 的实现原理。但实现 <code>async function</code> 的方式本身不具有唯一性，其实现方式多种多样，但这些实现方式都应遵循 <code>ES</code> 标准。本文主要介绍了以 <code>Generator</code> 函数为基础，借助 <code>Promise</code> 对象实现自动执行器来实现 <code>async function</code>。</blockquote><p>起因是由于自己在使用 <code>async function</code> 时疑惑 <code>async function</code> 的本质到底是什么，它的函数体在执行时，是在宏任务队列 <code>task queue</code> 中执行（宏任务异步回调）还是在微任务队列 <code>micro queue</code> 中执行（微任务异步回调）还是以普通代码执行的形式在当前宏任务的执行上下文栈中执行？<h2 id="typescript-中的实现"><a href="#typescript-中的实现" class="header-anchor" aria-hidden="true">#</a> Typescript 中的实现</h2><p><code>Typescript</code> 通过 <code>Promise</code> 对象来实现 <code>Generator function</code> 中自动调用 <code>next</code> 方法。即实现了 <code>async function</code>。<pre class="language-js" v-pre><code><span class="token comment">// 编译为 ES2016，即没有 async function 的情形</span>
<span class="token keyword">var</span> __awaiter <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">&&</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__awaiter<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> _arguments<span class="token punctuation">,</span> <span class="token constant">P</span><span class="token punctuation">,</span> generator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// return new Promise(...)</span>
  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token constant">P</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token constant">P</span> <span class="token operator">=</span> Promise<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 该函数被 Promise.then() 调用，即在当前事件循环中的 microtask queue 中执行回调</span>
    <span class="token comment">// 即可理解为在遇到函数体中第一个 await 之后的代码调用都是在微任务队列中完成</span>
    <span class="token comment">// 即在当前事件循环的微任务队列实现自动执行 Generator 函数</span>
    <span class="token keyword">function</span> <span class="token function">fulfilled</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 传入 result.value</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token comment">// microtask queue</span>
        <span class="token comment">// 执行至下一个 await</span>
        <span class="token function">step</span><span class="token punctuation">(</span>generator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">function</span> <span class="token function">rejected</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">try</span> <span class="token punctuation">{</span>
        <span class="token function">step</span><span class="token punctuation">(</span>generator<span class="token punctuation">[</span><span class="token string">"throw"</span><span class="token punctuation">]</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// gen.next() 返回一个 yield 表达式返回的对象（{value: 表达式返回值, done: false}）</span>
    <span class="token keyword">function</span> <span class="token function">step</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 传入 generator.next()</span>
      <span class="token comment">// 判断是否已经迭代到序列末端</span>
      result<span class="token punctuation">.</span>done
        <span class="token operator">?</span> <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 已到序列末端</span>
        <span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">P</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 未到序列末端</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 启用微任务队列来实现自动执行 gen.next()</span>
          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>fulfilled<span class="token punctuation">,</span> rejected<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token comment">// trigger</span>
    <span class="token function">step</span><span class="token punctuation">(</span><span class="token punctuation">(</span>generator <span class="token operator">=</span> generator<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> _arguments <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre><p>以上是自己使用 <code>typescript</code> 编译 <code>async function</code> 返回的编译结果，从结果可以看出，<code>typescript 2.9.2</code> 中 <code>async function</code> 实现原理的本质是 <code>Generator</code> 函数加上 <code>Promise</code> 自动执行器。另外参考 <a href="https://github.com/tj/co/blob/master/index.js#L98-L106" rel="noopener noreferrer" target="_blank">co 源码<outboundlink></a>和 <a href="http://es6.ruanyifeng.com/#docs/async#async-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" rel="noopener noreferrer" target="_blank">ECMAScript 6 入门<outboundlink></a>中实现 <code>async function</code> 的原理亦与之相似。<p>其中的关键点在于使用 <code>Promise.resolve</code> 来调用 <code>then</code> 方法，以通过 <em><strong>微任务队列</strong></em> 来实现自动调用 <code>Generator</code> 函数的 <code>next</code> 方法。那么在 <code>async function</code> 函数体中，在遇到第一个 <code>await</code> 关键字之前的所有代码执行都是在 <em><strong>当前宏任务的执行上下文栈</strong></em> 中被调用执行，在第一个 <code>await</code> 及其之后的所有同步或异步代码都是通过 <em><strong>微任务队列</strong></em> <code>microtask queue</code> 来实现相对于 <code>async function</code> 函数体外部的 <em><strong>非阻塞</strong></em> 执行。<h2 id="es-标准"><a href="#es-标准" class="header-anchor" aria-hidden="true">#</a> ES 标准</h2><blockquote><p>以下解析主要参考最新正式版 ES 标准 <a href="https://www.ecma-international.org/ecma-262/9.0/#sec-async-functions-abstract-operations-async-function-start" rel="noopener noreferrer" target="_blank">ES2018<outboundlink></a>(即 ES 9th)。</blockquote><p>首先应该明白的专有<a href="https://www.ecma-international.org/ecma-262/#sec-async-function-definitions" rel="noopener noreferrer" target="_blank">名词解析<outboundlink></a>：<table><thead><tr><th>名称<th>描述<tbody><tr><td><code>asyncContext</code><td><code>AsyncFunction</code> 的执行上下文<tr><td><code>asyncFunctionBody</code><td><code>AsyncFunction</code> 的函数体，<code>FunctionBody [~Yield, +Await]</code><tr><td><code>awaitExpression</code><td><code>await</code> 表达式，<code>await UnaryExpression[?Yield, +Await]</code></table><p>对于一般的 <code>AsyncFunction</code> 都将依据以下步骤执行。<ol><li><p>设定 <code>runningContext</code> 为 当前正在执行上下文（更多关于我对执行上下文的 <a href="/blog/writings/execution-context/">理解</a>）。<li><p>将 <code>asyncContext</code> 设置为 <code>runningContext</code> 的一份拷贝副本。<li><p>设定 <code>asyncContext</code> 的代码求值状态，以用于在当 <code>asyncContext</code> 执行上下文恢复求值时，将执行以下步骤。<ol><li><p>设置 <code>result</code> 为 <code>asyncFunctionBody</code> 的求值结果<li><p>断言：<ul><li><p>如果我们执行至此，<code>async function</code> 要么抛出一个异常，要么显式地或隐式地返回一个值；<li><p>此时所有的 <code>await</code> 都已 <code>resolved</code>。</ul><li><p>从执行上下文栈中移除 <code>asyncContext</code> 上下文。恢复执行上下文栈中最顶层执行上下文的执行，并将其设定为当前正在执行上下文。<li><p>如果 <code>result</code> 是 <code>normal</code> 类型（即没有显式地 <code>return</code> 返回值），那么调用 <code>Promise.resolve()</code><li><p>否则如果 <code>result</code> 是 <code>return</code> 类型（即有显式地 <code>return</code> 返回一个值），那么调用 <code>Promise.resolve(return 的值))</code><li><p>否则如果 <code>result</code> 是 <code>throw</code> 类型（即抛出了一个异常），那么调用 <code>Promise.reject(throw 的异常值)</code><li><p>返回</ol><li><p>将 <code>asyncContext</code> 推入执行上下文栈的最上层。此时 <code>asyncContext</code> 即成为了当前正在执行的执行上下文。<li><p>(注：在执行 <code>asyncFunction</code> 时可能在函数体中存在 <code>await</code> 表达式，使得 <code>asyncContext</code> 脱离正在执行上下文进入 <code>heap memory</code> 等待执行回调，即进入一种冻结状态。在 <code>await</code> 表达式 <code>resolved</code> 之后继续执行下方第 <code>6</code> 步)<li><p>恢复被暂停的 <code>asyncContext</code> 的求值。设置 <code>result</code> 的值是此时的计算返回值。<li><p>断言：当我们返回此处时，<code>asyncContext</code> 已经从执行上下文栈中移除，并且 <code>runningContext</code> 是此时的当前执行上下文。<li><p>断言：<ul><li><p><code>result</code> 是一个值为 <code>undefined</code> 的 <code>normal</code> 类型返回值（即没有显式地在函数体内调用 <code>return</code> 的情形。）。<li><p>计算后返回值的可能来源是 <a href="https://www.ecma-international.org/ecma-262/#await" rel="noopener noreferrer" target="_blank">Await<outboundlink></a>表达式或者 <code>async function</code> 中不存在未执行的 <code>await</code> 表达式时，执行 3.7 步骤（即之后执行 4 将 <code>asyncContext</code> 设置为当前正在执行上下文）。</ul><li><p>返回</ol><h2 id="实践"><a href="#实践" class="header-anchor" aria-hidden="true">#</a> 实践</h2><pre class="language-js" v-pre><code><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'From promise object'</span><span class="token punctuation">)</span> <span class="token comment">// 1 current event loop</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'from promise'</span><span class="token punctuation">)</span> <span class="token comment">// 4 current event loop</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> ts <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token comment">// 2 current event loop</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'From async function'</span><span class="token punctuation">)</span>

  <span class="token comment">/**
   * 1. 第一次执行至此时， asyncContext 弹出执行上下文栈，并移除当前执行上下文标识
   * 2. await 标识了一个异步操作，那么为了不阻塞当前宏任务中其他执行上下文栈的执行，故
   * 此时 asyncContext 弹出执行上下文栈，将当前执行上下文标识转移给其他执行上下文
   */</span>
  <span class="token comment">// 4 microtask queue</span>
  <span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">await</span> promise

  <span class="token comment">// 4 microtask queue</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token comment">// current event loop</span>
<span class="token function">ts</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// 3 current event loop</span>
<span class="token comment">// 在 async function 遇到第一个 await 之后获得当前执行上下文标识</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'event loop end'</span><span class="token punctuation">)</span>

<span class="token comment">// 匿名函数在倒计时结束后加入 task queue，此处即是成为宏任务队列中的下一个宏任务</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">{</span>
  <span class="token comment">// 5 next event loop</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'From setTimeout'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
</code></pre><pre class="language-bash" v-pre><code><span class="token comment"># nodejs 10 and Chrome 67</span>
From promise object
From async <span class="token keyword">function</span>
event loop end
from promise
From setTimeout
</code></pre><p>以上结果正好验证了之前对 <code>async function</code> 的执行原理分析。<p>在 2 处时，代码执行仍在当前事件循环的执行上下文栈中执行，当遇到第一个 <code>await</code> 表达式时，该表达式进入了 <code>heap memory</code> 等待 <code>Promise</code> 被 <code>resolved</code>（示例代码中是直接调用 <code>resolve()</code>，这不影响分析 <code>async function</code>）。在 <code>await</code> 表达式等待计算结果期间，当前执行上下文标识转移，继续执行当前宏任务的其他执行上下文。待 <code>await</code> 表达式被 <code>resolved</code> 之后，该表达式将进入 <code>microtask queue</code> 等待执行（如同正常的微任务异步回调一样）。<p><code>await</code> 表达式及其之后所有代码之所以要进入 <code>microtask queue</code> 正是为了 <em><strong>防止</strong></em> 对当前宏任务中其他执行上下文造成 <em><strong>阻塞</strong></em>。在他进入 <code>microtask queue</code> 之后，只有等到当前宏任务所有执行上下文都执行完毕之后，才会被调用执行。<p>以上正是体现了 <code>async function</code> 的异步原理。<h2 id="结论"><a href="#结论" class="header-anchor" aria-hidden="true">#</a> 结论</h2><p>通过简要分析一般 <code>async function</code> 的原理及其典型实现方式，可以得出以下基本实现：<ol><li><p>异步流程必须保证不阻塞后续代码执行。<ul><li>在现行 <code>ES</code> 标准中，无疑 <code>microtask queue</code> 是符合这一角色担当（不是实现非阻塞的唯一方式）。<code>microtask queue</code> 不阻塞当前宏任务其他执行上下文的执行，只在当前宏任务中所有执行上下文都执行完成后被调用。这样的特点正好符合 <em><strong>非阻塞</strong></em>　的特性。</ul><li><p>为了实现异步流程可控性，控制异步流程的 <em><strong>并发性</strong></em>，即表现为以同步的方式书写异步函数。那么可以结合 <code>Generator</code> 函数来实现。<code>Generator function</code> 本身具有 <em><strong>可控</strong></em>　这一特点（即 <code>next</code> 方法），可严格控制异步流程。结合 <code>Generator function</code> 的可控特点可实现 <code>async function</code> 中控制多个异步流程之间的逻辑关系，各个异步流程之间执行先后顺序，它们之间是否需要并发异步执行。<li><p><code>Promise</code> 对象的异步回调的调用方式即是微任务异步回调。那么可以通过 <code>Promise</code> 对象来实现 2 中的 <code>Generator function</code> 的自动执行器。那么可实现在 2 的基础上达到非阻塞的效果。<li><p>结合 2 和 3 ，那么即可实现 1 中的 <em><strong>非阻塞</strong></em> 流程。该流程不阻塞当前宏任务中其他执行上下文的执行。并且可以做到严格控制各个异步流程之间的关系（<em><strong>执行先后，是否并发</strong></em>）。</ol><p><em><strong>结论</strong></em>：实现 <code>async function</code> 的关键点在于实现一个非阻塞的流程。<h2 id="参考"><a href="#参考" class="header-anchor" aria-hidden="true">#</a> 参考</h2><ul><li><p><a href="https://www.ecma-international.org/ecma-262/9.0/#sec-async-functions-abstract-operations-async-function-start" rel="noopener noreferrer" target="_blank">ECMAScript asyncFunctionStart<outboundlink></a><li><p><a href="https://www.ecma-international.org/ecma-262/#await" rel="noopener noreferrer" target="_blank">ECMAScript await<outboundlink></a><li><p><a href="https://github.com/tj/co/blob/master/index.js#L98-L106" rel="noopener noreferrer" target="_blank">co 源码<outboundlink></a><li><p><a href="https://medium.com/siliconwat/how-javascript-async-await-works-3cab4b7d21da" rel="noopener noreferrer" target="_blank">How JavaScript Async/Await Works<outboundlink></a><li><p><a href="http://nikgrozev.com/2017/10/01/async-await/" rel="noopener noreferrer" target="_blank">Await and Async Explained with Diagrams and Examples<outboundlink></a><li><p><a href="http://es6.ruanyifeng.com/#docs/async#async-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" rel="noopener noreferrer" target="_blank">ECMAScript 6 入门<outboundlink></a><li><p><a href="https://www.zhihu.com/question/39571954" rel="noopener noreferrer" target="_blank">async/await 实现原理<outboundlink></a><li><p><a href="https://www.zhihu.com/question/62254462/answer/197769615" rel="noopener noreferrer" target="_blank">JS 中异步执行代码的意义<outboundlink></a></ul></div></article><button data-v-e85d20b2 data-v-e85d20b2 class="floating-btn __position" style="display:none"><svg class="icon-rocket" data-v-e85d20b2 viewBox="0 0 512 512"><path d="M256 421.6c-18.1 0-33.2-6.8-42.9-10.9-5.4-2.3-11.3 1.8-10.9 7.6l3.5 51c.2 3.1 3.8 4.7 6.3 2.8l14.5-11c1.8-1.4 4.5-.9 5.7 1l20.5 32.1c1.5 2.4 5.1 2.4 6.6 0l20.5-32.1c1.2-1.9 3.9-2.4 5.7-1l14.5 11c2.5 1.9 6.1.3 6.3-2.8l3.5-51c.4-5.8-5.5-10-10.9-7.6-9.8 4.1-24.8 10.9-42.9 10.9z" data-v-e85d20b2></path><path d="M397.7 293.1l-48-49.1c0-158-93.2-228-93.2-228s-94.1 70-94.1 228l-48 49.1c-1.8 1.8-2.6 4.5-2.2 7.1L130.6 412c.9 5.7 7.1 8.5 11.8 5.4l67.1-45.4s20.7 20 47.1 20c26.4 0 46.1-20 46.1-20l67.1 45.4c4.6 3.1 10.8.3 11.8-5.4l18.5-111.9c.2-2.6-.6-5.2-2.4-7zM256.5 192c-17 0-30.7-14.3-30.7-32s13.8-32 30.7-32c17 0 30.7 14.3 30.7 32s-13.7 32-30.7 32z" data-v-e85d20b2></path></svg></button></main><footer class="blog-footer sf__main__layout grid col grid-jc-center" data-v-1044ad0a data-v-cac63c14><div class="footer-info" data-v-1044ad0a>Copyright © 2018 <a href="https://github.com/lbwa" rel="noopener" target="_blank" class="author" data-v-1044ad0a>Bowen</a></div></footer><section class="loading-wrapper grid col grid-center grid-jc-center" data-v-cac63c14 style="display:none"><div class="loading"><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div></div><a class="loading-tips">Loading</a></section></section></div></div><script type="text/javascript">window.__NUXT__={layout:"blog",data:[{menu:[{errno:0,to:"writings/dom-location",title:"获取 Element 在 document 中的位置信息",author:"Bowen",date:"2018 SEP 01",tags:["前端开发","CSS"]},{errno:0,to:"writings/spa-and-mpa",title:"SPA 与 MPA 的比较与优化",author:"Bowen",date:"2018 AUG 04",tags:["前端开发","SPA","MPA","skeleton"]},{errno:0,to:"writings/async-function-in-js",title:"Event loops 中的 AsyncFunction",author:"Bowen",date:"2018 JUL 26",tags:["JavaScript","async","事件循环"]},{errno:0,to:"writings/pwa-fundamentals",title:"PWA 基础",author:"Bowen",date:"2018 JUL 07",tags:["前端开发","PWA"]},{errno:0,to:"writings/js-design-pattern",title:"JS 设计模式",author:"Bowen",date:"2018 JUN 12",tags:["前端开发","设计模式"]},{errno:0,to:"writings/http-request",title:"HTTP 协议请求首部",author:"Bowen",date:"2018 JUN 08",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-response",title:"HTTP 协议响应首部",author:"Bowen",date:"2018 JUN 07",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-protocol",title:"HTTP 协议",author:"Bowen",date:"2018 JUN 06",tags:["前端开发","网络请求"]},{errno:0,to:"writings/execution-context",title:"JS 执行上下文",author:"Bowen",date:"2018 MAY 07",tags:["前端开发","JavaScript","执行上下文"]},{errno:0,to:"writings/vue-lifecycle-and-slots",title:"对 Vue 插槽和生命周期的一点思考",author:"Bowen",date:"2018 APR 24",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/learning-vue-unit-test",title:"总结如何进行单元测试",author:"Bowen",date:"2018 APR 21",tags:["前端开发","Vue.js","应用测试"]},{errno:0,to:"writings/cross-domain-solution",title:"客户端跨域解决方案",author:"Bowen",date:"2018 APR 19",tags:["前端开发","网络请求"]},{errno:0,to:"writings/css-bfc",title:"探究 BFC 以及闭合浮动原理",author:"Bowen",date:"2018 MAR 29",tags:["前端开发","CSS"]},{errno:0,to:"writings/vue.js-reusability-and-composition",title:"学习 Vue.js 可复用性和组合",author:"Bowen",date:"2018 MAR 12",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/event-loop",title:"解析 event loops",author:"Bowen",date:"2018 MAR 08",tags:["前端开发","JavaScript","事件循环"]},{errno:0,to:"writings/learning-vuex",title:"学习 vuex 基础",author:"Bowen",date:"2018 MAR 06",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/compare-commonjs-with-esm",title:"比较 CommonJS 与 ES6 Module 语法",author:"Bowen",date:"2018 FEB 27",tags:["前端开发","JavaScript","模块"]},{errno:0,to:"writings/learning-vuejs-essentials",title:"学习 Vue.js 基础",author:"Bowen",date:"2018 FEB 24",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/keyword-this",title:"理解 this 的指向",author:"Bowen",date:"2018 FEB 06",tags:["前端开发","JavaScript"]}]},{title:"Event loops 中的 AsyncFunction",date:"2018 JUL 26",author:"Bowen",tags:["JavaScript","async","事件循环"],content:'<blockquote>\n<p>本文旨在讨论 <code>async function</code> 的实现原理。但实现 <code>async function</code> 的方式本身不具有唯一性，其实现方式多种多样，但这些实现方式都应遵循 <code>ES</code> 标准。本文主要介绍了以 <code>Generator</code> 函数为基础，借助 <code>Promise</code> 对象实现自动执行器来实现 <code>async function</code>。</p>\n</blockquote>\n<p>起因是由于自己在使用 <code>async function</code> 时疑惑 <code>async function</code> 的本质到底是什么，它的函数体在执行时，是在宏任务队列 <code>task queue</code> 中执行（宏任务异步回调）还是在微任务队列 <code>micro queue</code> 中执行（微任务异步回调）还是以普通代码执行的形式在当前宏任务的执行上下文栈中执行？</p>\n<h2 id="typescript-中的实现"><a class="header-anchor" href="#typescript-中的实现" aria-hidden="true">#</a> Typescript 中的实现</h2>\n<p><code>Typescript</code> 通过 <code>Promise</code> 对象来实现 <code>Generator function</code> 中自动调用 <code>next</code> 方法。即实现了 <code>async function</code>。</p>\n<pre v-pre class="language-js"><code><span class="token comment">// 编译为 ES2016，即没有 async function 的情形</span>\n<span class="token keyword">var</span> __awaiter <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">&amp;&amp;</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__awaiter<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> _arguments<span class="token punctuation">,</span> <span class="token constant">P</span><span class="token punctuation">,</span> generator<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// return new Promise(...)</span>\n  <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token punctuation">(</span><span class="token constant">P</span> <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token constant">P</span> <span class="token operator">=</span> Promise<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 该函数被 Promise.then() 调用，即在当前事件循环中的 microtask queue 中执行回调</span>\n    <span class="token comment">// 即可理解为在遇到函数体中第一个 await 之后的代码调用都是在微任务队列中完成</span>\n    <span class="token comment">// 即在当前事件循环的微任务队列实现自动执行 Generator 函数</span>\n    <span class="token keyword">function</span> <span class="token function">fulfilled</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 传入 result.value</span>\n      <span class="token keyword">try</span> <span class="token punctuation">{</span>\n        <span class="token comment">// microtask queue</span>\n        <span class="token comment">// 执行至下一个 await</span>\n        <span class="token function">step</span><span class="token punctuation">(</span>generator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token keyword">function</span> <span class="token function">rejected</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">try</span> <span class="token punctuation">{</span>\n        <span class="token function">step</span><span class="token punctuation">(</span>generator<span class="token punctuation">[</span><span class="token string">"throw"</span><span class="token punctuation">]</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// gen.next() 返回一个 yield 表达式返回的对象（{value: 表达式返回值, done: false}）</span>\n    <span class="token keyword">function</span> <span class="token function">step</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 传入 generator.next()</span>\n      <span class="token comment">// 判断是否已经迭代到序列末端</span>\n      result<span class="token punctuation">.</span>done\n        <span class="token operator">?</span> <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>value<span class="token punctuation">)</span> <span class="token comment">// 已到序列末端</span>\n        <span class="token punctuation">:</span> <span class="token keyword">new</span> <span class="token class-name">P</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 未到序列末端</span>\n            <span class="token function">resolve</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>\n            <span class="token comment">// 启用微任务队列来实现自动执行 gen.next()</span>\n          <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>fulfilled<span class="token punctuation">,</span> rejected<span class="token punctuation">)</span><span class="token punctuation">;</span>\n    <span class="token punctuation">}</span>\n    <span class="token comment">// trigger</span>\n    <span class="token function">step</span><span class="token punctuation">(</span><span class="token punctuation">(</span>generator <span class="token operator">=</span> generator<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>thisArg<span class="token punctuation">,</span> _arguments <span class="token operator">||</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>\n<span class="token punctuation">}</span><span class="token punctuation">;</span>\n</code></pre>\n<p>以上是自己使用 <code>typescript</code> 编译 <code>async function</code> 返回的编译结果，从结果可以看出，<code>typescript 2.9.2</code> 中 <code>async function</code> 实现原理的本质是 <code>Generator</code> 函数加上 <code>Promise</code> 自动执行器。另外参考 <a href="https://github.com/tj/co/blob/master/index.js#L98-L106" target="_blank" rel="noopener noreferrer">co 源码<OutboundLink/></a> 和 <a href="http://es6.ruanyifeng.com/#docs/async#async-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" target="_blank" rel="noopener noreferrer">ECMAScript 6 入门<OutboundLink/></a> 中实现 <code>async function</code> 的原理亦与之相似。</p>\n<p>其中的关键点在于使用 <code>Promise.resolve</code> 来调用 <code>then</code> 方法，以通过 <em><strong>微任务队列</strong></em> 来实现自动调用 <code>Generator</code> 函数的 <code>next</code> 方法。那么在 <code>async function</code> 函数体中，在遇到第一个 <code>await</code> 关键字之前的所有代码执行都是在 <em><strong>当前宏任务的执行上下文栈</strong></em> 中被调用执行，在第一个 <code>await</code> 及其之后的所有同步或异步代码都是通过 <em><strong>微任务队列</strong></em> <code>microtask queue</code> 来实现相对于 <code>async function</code> 函数体外部的 <em><strong>非阻塞</strong></em> 执行。</p>\n<h2 id="es-标准"><a class="header-anchor" href="#es-标准" aria-hidden="true">#</a> ES 标准</h2>\n<blockquote>\n<p>以下解析主要参考最新正式版 ES 标准 <a href="https://www.ecma-international.org/ecma-262/9.0/#sec-async-functions-abstract-operations-async-function-start" target="_blank" rel="noopener noreferrer">ES2018<OutboundLink/></a> (即 ES 9th)。</p>\n</blockquote>\n<p>首先应该明白的专有<a href="https://www.ecma-international.org/ecma-262/#sec-async-function-definitions" target="_blank" rel="noopener noreferrer">名词解析<OutboundLink/></a>：</p>\n<table>\n<thead>\n<tr>\n<th>名称</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>asyncContext</code></td>\n<td><code>AsyncFunction</code> 的执行上下文</td>\n</tr>\n<tr>\n<td><code>asyncFunctionBody</code></td>\n<td><code>AsyncFunction</code> 的函数体，<code>FunctionBody [~Yield, +Await]</code></td>\n</tr>\n<tr>\n<td><code>awaitExpression</code></td>\n<td><code>await</code> 表达式，<code>await UnaryExpression[?Yield, +Await]</code></td>\n</tr>\n</tbody>\n</table>\n<p>对于一般的 <code>AsyncFunction</code> 都将依据以下步骤执行。</p>\n<ol>\n<li>\n<p>设定 <code>runningContext</code> 为 当前正在执行上下文（更多关于我对执行上下文的 <a href="/blog/writings/execution-context/">理解</a>）。</p>\n</li>\n<li>\n<p>将 <code>asyncContext</code> 设置为 <code>runningContext</code> 的一份拷贝副本。</p>\n</li>\n<li>\n<p>设定 <code>asyncContext</code> 的代码求值状态，以用于在当 <code>asyncContext</code> 执行上下文恢复求值时，将执行以下步骤。</p>\n<ol>\n<li>\n<p>设置 <code>result</code> 为 <code>asyncFunctionBody</code> 的求值结果</p>\n</li>\n<li>\n<p>断言：</p>\n<ul>\n<li>\n<p>如果我们执行至此，<code>async function</code> 要么抛出一个异常，要么显式地或隐式地返回一个值；</p>\n</li>\n<li>\n<p>此时所有的 <code>await</code> 都已 <code>resolved</code>。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>从执行上下文栈中移除 <code>asyncContext</code> 上下文。恢复执行上下文栈中最顶层执行上下文的执行，并将其设定为当前正在执行上下文。</p>\n</li>\n<li>\n<p>如果 <code>result</code> 是 <code>normal</code> 类型（即没有显式地 <code>return</code> 返回值），那么调用 <code>Promise.resolve()</code></p>\n</li>\n<li>\n<p>否则如果 <code>result</code> 是 <code>return</code> 类型（即有显式地 <code>return</code> 返回一个值），那么调用 <code>Promise.resolve(return 的值))</code></p>\n</li>\n<li>\n<p>否则如果 <code>result</code> 是 <code>throw</code> 类型（即抛出了一个异常），那么调用 <code>Promise.reject(throw 的异常值)</code></p>\n</li>\n<li>\n<p>返回</p>\n</li>\n</ol>\n</li>\n<li>\n<p>将 <code>asyncContext</code> 推入执行上下文栈的最上层。此时 <code>asyncContext</code> 即成为了当前正在执行的执行上下文。</p>\n</li>\n<li>\n<p>(注：在执行 <code>asyncFunction</code> 时可能在函数体中存在 <code>await</code> 表达式，使得 <code>asyncContext</code> 脱离正在执行上下文进入 <code>heap memory</code> 等待执行回调，即进入一种冻结状态。在 <code>await</code> 表达式 <code>resolved</code> 之后继续执行下方第 <code>6</code> 步)</p>\n</li>\n<li>\n<p>恢复被暂停的 <code>asyncContext</code> 的求值。设置 <code>result</code> 的值是此时的计算返回值。</p>\n</li>\n<li>\n<p>断言：当我们返回此处时，<code>asyncContext</code> 已经从执行上下文栈中移除，并且 <code>runningContext</code> 是此时的当前执行上下文。</p>\n</li>\n<li>\n<p>断言：</p>\n<ul>\n<li>\n<p><code>result</code> 是一个值为 <code>undefined</code> 的 <code>normal</code> 类型返回值（即没有显式地在函数体内调用 <code>return</code> 的情形。）。</p>\n</li>\n<li>\n<p>计算后返回值的可能来源是 <a href="https://www.ecma-international.org/ecma-262/#await" target="_blank" rel="noopener noreferrer">Await<OutboundLink/></a> 表达式或者 <code>async function</code> 中不存在未执行的 <code>await</code> 表达式时，执行 3.7 步骤（即之后执行 4 将 <code>asyncContext</code> 设置为当前正在执行上下文）。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>返回</p>\n</li>\n</ol>\n<h2 id="实践"><a class="header-anchor" href="#实践" aria-hidden="true">#</a> 实践</h2>\n<pre v-pre class="language-js"><code><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'From promise object\'</span><span class="token punctuation">)</span> <span class="token comment">// 1 current event loop</span>\n  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">\'from promise\'</span><span class="token punctuation">)</span> <span class="token comment">// 4 current event loop</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> ts <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token comment">// 2 current event loop</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'From async function\'</span><span class="token punctuation">)</span>\n\n  <span class="token comment">/**\n   * 1. 第一次执行至此时， asyncContext 弹出执行上下文栈，并移除当前执行上下文标识\n   * 2. await 标识了一个异步操作，那么为了不阻塞当前宏任务中其他执行上下文栈的执行，故\n   * 此时 asyncContext 弹出执行上下文栈，将当前执行上下文标识转移给其他执行上下文\n   */</span>\n  <span class="token comment">// 4 microtask queue</span>\n  <span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token keyword">await</span> promise\n\n  <span class="token comment">// 4 microtask queue</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token comment">// current event loop</span>\n<span class="token function">ts</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 3 current event loop</span>\n<span class="token comment">// 在 async function 遇到第一个 await 之后获得当前执行上下文标识</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'event loop end\'</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 匿名函数在倒计时结束后加入 task queue，此处即是成为宏任务队列中的下一个宏任务</span>\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=></span><span class="token punctuation">{</span>\n  <span class="token comment">// 5 next event loop</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'From setTimeout\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>\n</code></pre>\n<pre v-pre class="language-bash"><code><span class="token comment"># nodejs 10 and Chrome 67</span>\nFrom promise object\nFrom async <span class="token keyword">function</span>\nevent loop end\nfrom promise\nFrom setTimeout\n</code></pre>\n<p>以上结果正好验证了之前对 <code>async function</code> 的执行原理分析。</p>\n<p>在 2 处时，代码执行仍在当前事件循环的执行上下文栈中执行，当遇到第一个 <code>await</code> 表达式时，该表达式进入了 <code>heap memory</code> 等待 <code>Promise</code> 被 <code>resolved</code>（示例代码中是直接调用 <code>resolve()</code>，这不影响分析 <code>async function</code>）。在 <code>await</code> 表达式等待计算结果期间，当前执行上下文标识转移，继续执行当前宏任务的其他执行上下文。待 <code>await</code> 表达式被 <code>resolved</code> 之后，该表达式将进入 <code>microtask queue</code> 等待执行（如同正常的微任务异步回调一样）。</p>\n<p><code>await</code> 表达式及其之后所有代码之所以要进入 <code>microtask queue</code> 正是为了 <em><strong>防止</strong></em> 对当前宏任务中其他执行上下文造成 <em><strong>阻塞</strong></em>。在他进入 <code>microtask queue</code> 之后，只有等到当前宏任务所有执行上下文都执行完毕之后，才会被调用执行。</p>\n<p>以上正是体现了 <code>async function</code> 的异步原理。</p>\n<h2 id="结论"><a class="header-anchor" href="#结论" aria-hidden="true">#</a> 结论</h2>\n<p>通过简要分析一般 <code>async function</code> 的原理及其典型实现方式，可以得出以下基本实现：</p>\n<ol>\n<li>\n<p>异步流程必须保证不阻塞后续代码执行。</p>\n<ul>\n<li>在现行 <code>ES</code> 标准中，无疑 <code>microtask queue</code> 是符合这一角色担当（不是实现非阻塞的唯一方式）。<code>microtask queue</code> 不阻塞当前宏任务其他执行上下文的执行，只在当前宏任务中所有执行上下文都执行完成后被调用。这样的特点正好符合 <em><strong>非阻塞</strong></em>　的特性。</li>\n</ul>\n</li>\n<li>\n<p>为了实现异步流程可控性，控制异步流程的 <em><strong>并发性</strong></em>，即表现为以同步的方式书写异步函数。那么可以结合 <code>Generator</code> 函数来实现。<code>Generator function</code> 本身具有 <em><strong>可控</strong></em>　这一特点（即 <code>next</code> 方法），可严格控制异步流程。结合 <code>Generator function</code> 的可控特点可实现 <code>async function</code> 中控制多个异步流程之间的逻辑关系，各个异步流程之间执行先后顺序，它们之间是否需要并发异步执行。</p>\n</li>\n<li>\n<p><code>Promise</code> 对象的异步回调的调用方式即是微任务异步回调。那么可以通过 <code>Promise</code> 对象来实现 2 中的 <code>Generator function</code> 的自动执行器。那么可实现在 2 的基础上达到非阻塞的效果。</p>\n</li>\n<li>\n<p>结合 2 和 3 ，那么即可实现 1 中的 <em><strong>非阻塞</strong></em> 流程。该流程不阻塞当前宏任务中其他执行上下文的执行。并且可以做到严格控制各个异步流程之间的关系（<em><strong>执行先后，是否并发</strong></em>）。</p>\n</li>\n</ol>\n<p><em><strong>结论</strong></em>：实现 <code>async function</code> 的关键点在于实现一个非阻塞的流程。</p>\n<h2 id="参考"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>\n<ul>\n<li>\n<p><a href="https://www.ecma-international.org/ecma-262/9.0/#sec-async-functions-abstract-operations-async-function-start" target="_blank" rel="noopener noreferrer">ECMAScript asyncFunctionStart<OutboundLink/></a></p>\n</li>\n<li>\n<p><a href="https://www.ecma-international.org/ecma-262/#await" target="_blank" rel="noopener noreferrer">ECMAScript await<OutboundLink/></a></p>\n</li>\n<li>\n<p><a href="https://github.com/tj/co/blob/master/index.js#L98-L106" target="_blank" rel="noopener noreferrer">co 源码<OutboundLink/></a></p>\n</li>\n<li>\n<p><a href="https://medium.com/siliconwat/how-javascript-async-await-works-3cab4b7d21da" target="_blank" rel="noopener noreferrer">How JavaScript Async/Await Works<OutboundLink/></a></p>\n</li>\n<li>\n<p><a href="http://nikgrozev.com/2017/10/01/async-await/" target="_blank" rel="noopener noreferrer">Await and Async Explained with Diagrams and Examples<OutboundLink/></a></p>\n</li>\n<li>\n<p><a href="http://es6.ruanyifeng.com/#docs/async#async-%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86" target="_blank" rel="noopener noreferrer">ECMAScript 6 入门<OutboundLink/></a></p>\n</li>\n<li>\n<p><a href="https://www.zhihu.com/question/39571954" target="_blank" rel="noopener noreferrer">async/await 实现原理<OutboundLink/></a></p>\n</li>\n<li>\n<p><a href="https://www.zhihu.com/question/62254462/answer/197769615" target="_blank" rel="noopener noreferrer">JS 中异步执行代码的意义<OutboundLink/></a></p>\n</li>\n</ul>\n'}],error:null,serverRendered:!0}</script><script defer src="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js"></script><script defer src="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js"></script><script defer src="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js"></script><script defer src="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js"></script><script defer src="/_nuxt/vendor.13de21511613edf061b2.js"></script><script defer src="/_nuxt/app.5a4fa6b8fcf73db97515.js"></script>