<!doctype html><html data-n-head="lang" data-n-head-ssr lang="zh"><meta data-n-head="true" content="IE=edge,chrome=1" http-equiv='"X-UA-Compatible'><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" name="viewport"><meta data-n-head="true" content="bowen blog, bowen 博客, vuejs, reactjs, ssr, 前端开发, 前端 , web开发, nodejs, github" name="keywords"><meta data-n-head="true" content="一个分享代码经历的地方" name="description" data-hid="description"><meta data-n-head="true" content="yes" name="apple-mobile-web-app-capable"><meta data-n-head="true" content="black" name="apple-mobile-web-app-status-bar-style"><meta data-n-head="true" content="yes" name="mobile-web-app-capable" data-hid="mobile-web-app-capable"><meta data-n-head="true" content="Bowen Blog" name="apple-mobile-web-app-title" data-hid="apple-mobile-web-app-title"><meta data-n-head="true" content="Bowen" name="author" data-hid="author"><meta data-n-head="true" content="#24292e" name="theme-color" data-hid="theme-color"><meta data-n-head="true" content="website" name="og:type" data-hid="og:type" property="og:type"><meta data-n-head="true" content="Bowen Blog" name="og:title" data-hid="og:title" property="og:title"><meta data-n-head="true" content="A place which is used to share programming experiences" name="og:description" data-hid="og:description" property="og:description"><title data-n-head="true">PWA 基础 | Bowen Blog</title><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="/_nuxt/manifest.2108b1d4.json" rel="manifest" data-n-head="true"><link href="/_nuxt/icons/icon_64.e20A200w20w.png" rel="shortcut icon" data-n-head="true"><link href="/_nuxt/icons/icon_512.e20A200w20w.png" rel="apple-touch-icon" data-n-head="true" sizes="512x512"><link href="https://set.sh/blog/writings/pwa-fundamentals/" rel="alternate" data-n-head="true" hreflang="zh"><link href="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js" rel="preload" as="script"><link href="/_nuxt/vendor.13de21511613edf061b2.js" rel="preload" as="script"><link href="/_nuxt/app.5a4fa6b8fcf73db97515.js" rel="preload" as="script"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="preload" as="style"><link href="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js" rel="preload" as="script"><link href="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/tags/_id/index.edb9dbabb1b9c2ef81f2.js" rel="prefetch"><link href="/_nuxt/pages/index.1d0ac68e309be0e86168.js" rel="prefetch"><link href="/_nuxt/pages/blog/tags/index.2659d358b69abdfd34bf.js" rel="prefetch"><link href="/_nuxt/pages/blog/projects/index.3ff8e031c3cb4f25eaed.js" rel="prefetch"><link href="/_nuxt/pages/blog/writings/index.b016af22016e152b7231.js" rel="prefetch"><link href="/_nuxt/layouts/home.dd55e95df1c2109ebde6.js" rel="prefetch"><link href="/_nuxt/layouts/default.89ffa224d3d7769e4fbb.js" rel="prefetch"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="stylesheet"><body data-n-head=""><div id="__nuxt" data-server-rendered="true"><div class="nuxt-progress" style="width:0%;height:2px;background-color:#3eaf7c;opacity:0"></div><div id="__layout"><section class="blog sf__parent__clearfix" data-v-cac63c14><header class="header __position components-animation" data-v-13c46026 data-v-cac63c14><nav class="mobile-navigator" data-v-13c46026 data-v-d4cae7a6><label class="label-line" data-v-d4cae7a6><span class="__position label-line line-top" data-v-d4cae7a6><span class="__position line-crust line-crust-top" data-v-d4cae7a6></span></span><span class="__position label-line line-bottom" data-v-d4cae7a6><span class="__position line-crust line-crust-bottom" data-v-d4cae7a6></span></span></label></nav><nav class="navigator __position grid" data-v-13c46026 role="navigation"><a href="/" class="navigator-link hover-animation grid-cell" data-v-13c46026>HOME</a><a href="/blog/writings/" class="navigator-link hover-animation grid-cell" data-v-13c46026>WRITINGS</a><a href="/blog/projects/" class="navigator-link hover-animation grid-cell" data-v-13c46026>PROJECTS</a><a href="/blog/tags/" class="navigator-link hover-animation grid-cell" data-v-13c46026>TAGS</a><a href="https://github.com/lbwa" class="navigator-link hover-animation grid-cell" data-v-13c46026 rel="noopener" target="_blank">GITHUB</a></nav><div class="background-helper __position" data-v-13c46026></div></header><main class="articles-container wrapper sf__reference__layout" data-v-cac63c14 role="main"><article class="articles-main"><div class="article-header"><h1 class="article-title">PWA 基础</h1><span class="article-author">Bowen</span><span class="article-date">2018 JUL 07</span><div class="article-tags"><a href="/blog/tags/前端开发" class="article-tag">前端开发</a><a href="/blog/tags/pwa" class="article-tag">PWA</a></div></div><div class="article-content"><p><code>PWA</code> 意为 <code>progressive web application</code>，即渐进式网络应用。<h2 id="解决的问题"><a href="#解决的问题" class="header-anchor" aria-hidden="true">#</a> 解决的问题</h2><h3 id="对于-web-app"><a href="#对于-web-app" class="header-anchor" aria-hidden="true">#</a> 对于 <code>web App</code></h3><ol><li><p><code>PWA</code> 可离线访问应用，体验接近 <code>Native App</code>，2017 年 <code>twitter</code> 的 <code>PWA</code> 显著降低了用户跳出率。<li><p><code>PWA</code> 具备推送消息的能力，可即时加载和定期更新。</ol><h3 id="对于-native-app"><a href="#对于-native-app" class="header-anchor" aria-hidden="true">#</a> 对于 <code>Native App</code></h3><ol><li><p><code>PWA</code> 因存在 <code>manifest</code> 清单而具有 <code>SEO</code> 增强，可被搜索引擎发现，可安装于移动端桌面。<ul><li><code>native app</code> 天生是封闭的环境，故不存在 <code>SEO</code> 能力，<code>PWA</code> 在浏览器环境下运行，存在 <code>manifest</code> 清单,故具有 <code>native app</code> 所不具有的 <code>SEO</code> 能力。</ul><li><p><code>PWA</code> 无需借助应用商店安装，可直接使用。<li><p><code>PWA</code> 无需手动更新，它借助 <code>Service Worker</code> 保持最新状态。</ol><h3 id="对于以上二者"><a href="#对于以上二者" class="header-anchor" aria-hidden="true">#</a> 对于以上二者</h3><ol><li><code>PWA</code> 兼容任何具有浏览器的设备。因为它只依赖于支持 <code>Service Worker</code> 的浏览器运行。</ol><h2 id="基本架构"><a href="#基本架构" class="header-anchor" aria-hidden="true">#</a> 基本架构</h2><h3 id="app-shell"><a href="#app-shell" class="header-anchor" aria-hidden="true">#</a> <code>App shell</code></h3><p><code>App shell</code> 是驱动 <code>PWA</code> 的 <em><strong>最小</strong></em> <code>HTML</code>，<code>CSS</code>，<code>JS</code>的集合。可理解为 <code>App shell</code> 是 <code>PWA</code> 运行的 <em><strong>基础架构</strong></em>。<code>PWA</code> 中所有的数据层内容都将在 <code>App shell</code> 中运行。<p><code>App shell</code> 架构将应用核心架构与 UI 和 数据层 分离。应用核心架构与 UI （即 <code>App shell</code> ）在初次加载时就被缓存。在后续加载应用时， <em><strong>只需要</strong></em> 请求更新的数据层内容即可。应用的核心架构和 UI 是从 <em><strong>本地缓存</strong></em> 中读取，避免了多次重复请求应用核心和 UI。此时的 <code>PWA</code> 因仅需要请求数据层数据而具备了快速启动的能力。<h3 id="server-worker"><a href="#server-worker" class="header-anchor" aria-hidden="true">#</a> <code>Server Worker</code></h3><p><code>Service Worker</code>（又称<a href="https://developers.google.com/web/fundamentals/primers/service-workers/" rel="noopener noreferrer" target="_blank">服务工作线程<outboundlink></a>）运行在 <em><strong>独立</strong></em> 于浏览器主线程的 <code>ServiceWorkerGlobalScope</code> 上下文环境（即浏览器后台）中。它现阶段支持 <em><strong>离线体验</strong></em>，包含推送通知和后台同步等功能。<ol><li><p>它属于 JS 工作线程的一种，但 <em><strong>不具备</strong></em> 访问 <code>DOM</code> 的能力。它通过 <code>postMessage</code> 接口来与控制的页面通信。<li><p>本质是一种可编程的网络代理。可控制页面所发网络请求的处理方式。<li><p>它在闲置时会被终止，在有需要时重启。所以不应依赖 <code>Service Worker</code> 的 <code>onfetch</code> 和 <code>onmessage</code> 处理全局状态。<li><p>它是基于 <code>Promise</code> 对象的实现。</ol><p><em><strong>notice</strong></em>: <code>./service-worker.js</code> 的 <code>register</code> 注册路径是基于 <em><strong>应用</strong></em> 的 <em><strong>根路径</strong></em>，而不是相对于以上注册程序代码的路径。因为 <code>Service Worker</code> 的作用域是由应用的根路径文件夹所定义的。（<a href="https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/#_15" rel="noopener noreferrer" target="_blank">Google Developers<outboundlink></a>）<p>另附截止至本文发表之时 <code>Service Worker</code> 的兼容性列表 —— <a href="https://jakearchibald.github.io/isserviceworkerready/" rel="noopener noreferrer" target="_blank">Is Service Worker ready<outboundlink></a>。<h3 id="service-worker-与-app-shell"><a href="#service-worker-与-app-shell" class="header-anchor" aria-hidden="true">#</a> <code>Service Worker</code> 与 <code>App shell</code></h3><p>基于 <code>Service Worker</code> 的可离线使用，消息推送，网络请求代理等特性，我们可以使用 <code>Service Worker</code> 来缓存 <code>App shell</code> 来实现 <code>PWA</code> 的渐进增强。<h2 id="service-worker-的生命周期"><a href="#service-worker-的生命周期" class="header-anchor" aria-hidden="true">#</a> <code>Service Worker</code> 的生命周期</h2><p><code>Service Worker</code> 的生命周期完全独立于网页。<code>Service Worker</code> 在第一次打开应用页面界面时， 在页面的 JS 脚本中注册。（<a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle?hl=zh-cn" rel="noopener noreferrer" target="_blank">Google Developers<outboundlink></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" rel="noopener noreferrer" target="_blank">MDN<outboundlink></a>）<p><img alt="sw-lifecycle" src="https://assets.set.sh/2018/180707-pwa-fundamentals/sw-lifecycle.png"><h3 id="install-event"><a href="#install-event" class="header-anchor" aria-hidden="true">#</a> Install event</h3><p>该事件主要用于缓存 <code>App shell</code>。<ul><li>在安装 <code>Service Worker</code> 时，第一个触发的事件就是 <a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle?hl=zh-cn#install" rel="noopener noreferrer" target="_blank">install<outboundlink></a>事件，在该事件完成后，可认为 <code>Service Worker</code> 安装完成。</ul><pre class="language-js" v-pre><code><span class="token comment">// app.js</span>
<span class="token comment">// 注册 Service worker</span>
<span class="token comment">// https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/#_14</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">'serviceWorker'</span> <span class="token keyword">in</span> navigator<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  navigator<span class="token punctuation">.</span>serviceWorker
    <span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">'./service-worker.js'</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Service Worker registered !'</span><span class="token punctuation">,</span> reg<span class="token punctuation">.</span>scope<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">'Service Worker registered unsuccessfully !'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><pre class="language-js" v-pre><code><span class="token comment">// service-worker.js</span>
<span class="token keyword">const</span> cacheName <span class="token operator">=</span> <span class="token string">'PWA-application'</span>
<span class="token keyword">const</span> filesToCache <span class="token operator">=</span> <span class="token punctuation">[</span>
  <span class="token string">'/'</span><span class="token punctuation">,</span>
  <span class="token string">'/index.html'</span><span class="token punctuation">,</span>
  <span class="token comment">// ...</span>
<span class="token punctuation">]</span>

self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'install'</span><span class="token punctuation">,</span> evt <span class="token operator">=></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'[ServiceWorker] Install'</span><span class="token punctuation">)</span>
  <span class="token comment">// ExtendableEvent.waitUntil() 用于延长时间的寿命从而阻止浏览器在事件中的异步操作</span>
  <span class="token comment">// 完成之前终止服务工作线程</span>
  evt<span class="token punctuation">.</span><span class="token function">waitUntil</span><span class="token punctuation">(</span>
    <span class="token comment">// caches 对象是用于开辟存储容器。另注，是调用 caches 开辟容器而不是 Cache 或 cache</span>
    <span class="token comment">// caches.open 返回匹配 cacheName 的 cache 对象的 Promise。</span>
    caches<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>cacheName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>cache <span class="token operator">=></span> <span class="token punctuation">{</span>

      <span class="token comment">// cache 参数即为匹配的 cache 对象</span>
      console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">'[ServiceWorker] Caching app shell'</span><span class="token punctuation">)</span>

      <span class="token comment">// addAll 用于缓存当前 URL 数组（即 request[]）中每一项。</span>
      <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>filesToCache<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>在示例代码中 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache" rel="noopener noreferrer" target="_blank">cache<outboundlink></a>对象为缓存的 <code>Request / Response</code> 对象提供 <em><strong>存储容器</strong></em>。<code>cache.addAll</code> 方法具有原子性，任意一个文件缓存失败，整个缓存步骤也将失败。<h3 id="activate-event"><a href="#activate-event" class="header-anchor" aria-hidden="true">#</a> Activate event</h3><p>该事件主要用于更新 <code>cache</code> 容器。<ul><li>在安装事件完成后，会触发一个 <a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle?hl=zh-cn#activate_1" rel="noopener noreferrer" target="_blank">activate<outboundlink></a>激活事件，<code>activate</code> 事件会在新的 <code>Service Worker</code> 启动时触发（旧版本 <code>Service Worker</code> 不触发该事件）。它触发时会清理与之前版本的 <code>Service Worker</code> 相关联的旧资源与旧缓存。</ul><pre class="language-js" v-pre><code><span class="token comment">// service-worker.js</span>
<span class="token comment">// 只在不存在或旧版本 `Service Worker` 不再与任何页面关联时触发，否则进入 `waiting</span>
<span class="token comment">// to activate` 阶段。</span>
self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'activate'</span><span class="token punctuation">,</span> e <span class="token operator">=></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'[ServiceWorker] Activate'</span><span class="token punctuation">)</span>
  e<span class="token punctuation">.</span><span class="token function">waitUntil</span><span class="token punctuation">(</span>
    <span class="token comment">// 循环所有的 cache 容器</span>
    caches<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>keyList <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>keyList<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>key <span class="token operator">=></span> <span class="token punctuation">{</span>
        <span class="token comment">// 删除所有除当前 cache 容器以外的所有容器，又因为 activate 事件仅在新版本</span>
        <span class="token comment">// `Service Worker` 使用时才被调用，即可保证 Service Worker 在 App shell 更</span>
        <span class="token comment">// 改时更新 cache 容器，删除旧容器</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">!==</span> cacheName<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'[Service worker] Removing old cache'</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>
          <span class="token comment">// caches.delete 用于删除开辟的 cache 容器</span>
          <span class="token keyword">return</span> caches<span class="token punctuation">.</span><span class="token keyword">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
  <span class="token keyword">return</span> self<span class="token punctuation">.</span>clients<span class="token punctuation">.</span><span class="token function">claim</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 以上代码保证在 App shell 更新时，即启用新的 `Service Worker` 时更新 cache 缓存容器。</span>
<span class="token comment">// 另外必须在 `Service Worker` 文件顶部重新定义 `cacheName` 变量。</span>
</code></pre><p><em><strong>Notice</strong></em>: 如果现有的 <code>Service Worker</code> 已启用，那么新版本仅会在后台安装，但 <em><strong>不会</strong></em> 被激活，此时被称为 <a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle?hl=zh-cn#waiting" rel="noopener noreferrer" target="_blank">worker in waiting<outboundlink></a>。直到已加载的页面不再使用旧的 <code>Service Worker</code> 才会激活新的 <code>Service Worker</code>。只要旧版本的 <code>Service Worker</code> 不再与任何页面关联。那么新版本就会替代旧版本的 <code>Service Worker</code> 成为 <code>active worker</code>。旧版本及其关联资源（缓存）就会被清除。<h2 id="读取-app-shell-缓存"><a href="#读取-app-shell-缓存" class="header-anchor" aria-hidden="true">#</a> 读取 App shell 缓存</h2><p><code>Service Worker</code> 通过拦截 <code>PWA</code> 请求来决定从缓存中读取 <code>App shell</code>。仅当缓存中不存在 <code>App shell</code> 时，<code>Service Worker</code> 才会默认使用原生 <code>fetch</code> API 来请求源服务器获得一个副本。<pre class="language-js" v-pre><code>self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">'fetch'</span><span class="token punctuation">,</span> evt <span class="token operator">=></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'[ServiceWorker] Fetch'</span><span class="token punctuation">,</span> evt<span class="token punctuation">.</span>request<span class="token punctuation">.</span>url<span class="token punctuation">)</span>
  evt<span class="token punctuation">.</span><span class="token function">respondWith</span><span class="token punctuation">(</span>
    <span class="token comment">// caches.match 评估是否存在 evt.request 缓存</span>
    caches<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>evt<span class="token punctuation">.</span>request<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=></span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> response <span class="token operator">||</span> <span class="token function">fetch</span><span class="token punctuation">(</span>evt<span class="token punctuation">.</span>request<span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p><img alt="sw-fetch" src="https://assets.set.sh/2018/180707-pwa-fundamentals/sw-fetch.png"><p>当 <code>Cache storage</code> 中不存在指定 <code>cacheName</code> 的 <code>cache</code> 容器时，将发起网络请求，最终将缓存新的 <code>App shell</code> 于指定的 <code>cache</code> 容器中。<p><img alt="sw-offline" src="https://assets.set.sh/2018/180707-pwa-fundamentals/sw-offline.png"><p><code>Service Worker</code> 存在指定的 <code>App shell</code> 时，将从指定的 <code>cache</code> 容器中读取。<h3 id="边界情况"><a href="#边界情况" class="header-anchor" aria-hidden="true">#</a> 边界情况</h3><ol><li>缓存取决于为每次更改更新缓存容器键名</ol><p>以上 <code>Service Worker</code> 读取 <code>App shell</code> 时，仅当 <code>cacheName</code> 发生改变时，才会更新 <code>App shell</code>。否则将保持使用旧的缓存。即缓存取决于缓存键名。<ol start="2"><li>更新容器却更新了整个缓存容器</ol><p>这样有一个缺点，就是只要一个文件发生变化时，为了更新缓存就不得不使整个 <code>cache</code> 容器失效，而重新下载新的 <code>App shell</code>。这样是有很大的性能浪费的。<p>解决方案可以是将 <code>cacheName</code> 指定为根据内容而生成的文件名。即 <code>content hash</code> 文件名。<ol start="3"><li>浏览器自身缓存可能阻止 <code>Service Worker</code> 的缓存更新</ol><p>在初次安装处理程序时（<code>install handler</code>）浏览器将不会返回从浏览器缓存中返回数据，而是一定会执行 <code>HTTPS</code> 请求（补充：<code>Service Worker</code> 除本地服务器外仅支持 <code>HTTPS</code> 协议。）。这样做的目的就是为了保证安装的 <code>App shell</code> 一定是最新版。否则，浏览器将在初次安装 <code>App shell</code> 时使用旧版本 <code>App shell</code>。这将导致 <code>Service Worker</code> 永远得不到更新。因为浏览器在该情境下在一直循环使用旧版本。<p>推荐的方案是在安装 <code>App shell</code> 时总是请求源服务器。<ol start="4"><li>谨慎地在生产环境中执行缓存优先策略（<code>cache-first</code>）</ol><p>在生产环境中执行缓存优先策略时，将导致任何读取缓存的时候都不会查询网络。这将导致只要本地有缓存，就几乎不可能更新本地的 <code>Service Worker</code> 配置中的 <code>App shell</code>。<p>因为 <code>Service Worker</code> 配置是取决于定义注册该 <code>Service Worker</code> 的 <em><strong>那个</strong></em> 文件，而不是服务器。（本文中指的是当时注册该 <code>Service Worker</code> 的 <code>./service-worker.js</code>）（此处原文为 <code>Since the configuration depends on where it was defined</code>）<p>处理以上四点边界情况推荐使用 <a href="https://github.com/GoogleChrome/sw-precache" rel="noopener noreferrer" target="_blank">sw-precache<outboundlink></a>或 <a href="https://github.com/GoogleChrome/workbox" rel="noopener noreferrer" target="_blank">workbox<outboundlink></a>（Google 推荐 <code>workbox</code>） 之类的内容库来管理缓存。<h2 id="reference"><a href="#reference" class="header-anchor" aria-hidden="true">#</a> Reference</h2><ul><li><p><a href="https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/" rel="noopener noreferrer" target="_blank">Your first progressive web app<outboundlink></a>（Google Developers）<li><p><a href="https://developers.google.com/web/fundamentals/primers/service-workers/" rel="noopener noreferrer" target="_blank">Service Worker<outboundlink></a>（Google Developers）<li><p><a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle" rel="noopener noreferrer" target="_blank">Service Worker lifecycle<outboundlink></a>（Google Developers）<li><p><a href="https://codelabs.developers.google.com/codelabs/debugging-service-workers/#0" rel="noopener noreferrer" target="_blank">Debugging service workers<outboundlink></a>（Google Developers）<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers" rel="noopener noreferrer" target="_blank">Using service worker<outboundlink></a>（MDN）<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage/open" rel="noopener noreferrer" target="_blank">CacheStorage.open<outboundlink></a>（MDN）<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage/delete" rel="noopener noreferrer" target="_blank">CacheStorage.delete<outboundlink></a>（MDN）<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage/keys" rel="noopener noreferrer" target="_blank">CacheStorage.keys<outboundlink></a>（MDN）<li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache/addAll" rel="noopener noreferrer" target="_blank">Cache.addAll<outboundlink></a>（MDN）</ul></div></article><button data-v-e85d20b2 data-v-e85d20b2 class="floating-btn __position" style="display:none"><svg class="icon-rocket" data-v-e85d20b2 viewBox="0 0 512 512"><path d="M256 421.6c-18.1 0-33.2-6.8-42.9-10.9-5.4-2.3-11.3 1.8-10.9 7.6l3.5 51c.2 3.1 3.8 4.7 6.3 2.8l14.5-11c1.8-1.4 4.5-.9 5.7 1l20.5 32.1c1.5 2.4 5.1 2.4 6.6 0l20.5-32.1c1.2-1.9 3.9-2.4 5.7-1l14.5 11c2.5 1.9 6.1.3 6.3-2.8l3.5-51c.4-5.8-5.5-10-10.9-7.6-9.8 4.1-24.8 10.9-42.9 10.9z" data-v-e85d20b2></path><path d="M397.7 293.1l-48-49.1c0-158-93.2-228-93.2-228s-94.1 70-94.1 228l-48 49.1c-1.8 1.8-2.6 4.5-2.2 7.1L130.6 412c.9 5.7 7.1 8.5 11.8 5.4l67.1-45.4s20.7 20 47.1 20c26.4 0 46.1-20 46.1-20l67.1 45.4c4.6 3.1 10.8.3 11.8-5.4l18.5-111.9c.2-2.6-.6-5.2-2.4-7zM256.5 192c-17 0-30.7-14.3-30.7-32s13.8-32 30.7-32c17 0 30.7 14.3 30.7 32s-13.7 32-30.7 32z" data-v-e85d20b2></path></svg></button></main><footer class="blog-footer sf__main__layout grid col grid-jc-center" data-v-1044ad0a data-v-cac63c14><div class="footer-info" data-v-1044ad0a>Copyright © 2018 <a href="https://github.com/lbwa" class="author" rel="noopener" target="_blank" data-v-1044ad0a>Bowen</a></div></footer><section class="loading-wrapper grid col grid-center grid-jc-center" data-v-cac63c14 style="display:none"><div class="loading"><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div></div><a class="loading-tips">Loading</a></section></section></div></div><script type="text/javascript">window.__NUXT__={layout:"blog",data:[{menu:[{errno:0,to:"writings/dom-location",title:"获取 Element 在 document 中的位置信息",author:"Bowen",date:"2018 SEP 01",tags:["前端开发","CSS"]},{errno:0,to:"writings/spa-and-mpa",title:"SPA 与 MPA 的比较与优化",author:"Bowen",date:"2018 AUG 04",tags:["前端开发","SPA","MPA","skeleton"]},{errno:0,to:"writings/async-function-in-js",title:"Event loops 中的 AsyncFunction",author:"Bowen",date:"2018 JUL 26",tags:["JavaScript","async","事件循环"]},{errno:0,to:"writings/pwa-fundamentals",title:"PWA 基础",author:"Bowen",date:"2018 JUL 07",tags:["前端开发","PWA"]},{errno:0,to:"writings/js-design-pattern",title:"JS 设计模式",author:"Bowen",date:"2018 JUN 12",tags:["前端开发","设计模式"]},{errno:0,to:"writings/http-request",title:"HTTP 协议请求首部",author:"Bowen",date:"2018 JUN 08",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-response",title:"HTTP 协议响应首部",author:"Bowen",date:"2018 JUN 07",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-protocol",title:"HTTP 协议",author:"Bowen",date:"2018 JUN 06",tags:["前端开发","网络请求"]},{errno:0,to:"writings/execution-context",title:"JS 执行上下文",author:"Bowen",date:"2018 MAY 07",tags:["前端开发","JavaScript","执行上下文"]},{errno:0,to:"writings/vue-lifecycle-and-slots",title:"对 Vue 插槽和生命周期的一点思考",author:"Bowen",date:"2018 APR 24",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/learning-vue-unit-test",title:"总结如何进行单元测试",author:"Bowen",date:"2018 APR 21",tags:["前端开发","Vue.js","应用测试"]},{errno:0,to:"writings/cross-domain-solution",title:"客户端跨域解决方案",author:"Bowen",date:"2018 APR 19",tags:["前端开发","网络请求"]},{errno:0,to:"writings/css-bfc",title:"探究 BFC 以及闭合浮动原理",author:"Bowen",date:"2018 MAR 29",tags:["前端开发","CSS"]},{errno:0,to:"writings/vue.js-reusability-and-composition",title:"学习 Vue.js 可复用性和组合",author:"Bowen",date:"2018 MAR 12",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/event-loop",title:"解析 event loops",author:"Bowen",date:"2018 MAR 08",tags:["前端开发","JavaScript","事件循环"]},{errno:0,to:"writings/learning-vuex",title:"学习 vuex 基础",author:"Bowen",date:"2018 MAR 06",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/compare-commonjs-with-esm",title:"比较 CommonJS 与 ES6 Module 语法",author:"Bowen",date:"2018 FEB 27",tags:["前端开发","JavaScript","模块"]},{errno:0,to:"writings/learning-vuejs-essentials",title:"学习 Vue.js 基础",author:"Bowen",date:"2018 FEB 24",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/keyword-this",title:"理解 this 的指向",author:"Bowen",date:"2018 FEB 06",tags:["前端开发","JavaScript"]}]},{title:"PWA 基础",date:"2018 JUL 07",author:"Bowen",tags:["前端开发","PWA"],content:'<p><code>PWA</code> 意为 <code>progressive web application</code>，即渐进式网络应用。</p>\n<h2 id="解决的问题"><a class="header-anchor" href="#解决的问题" aria-hidden="true">#</a> 解决的问题</h2>\n<h3 id="对于-web-app"><a class="header-anchor" href="#对于-web-app" aria-hidden="true">#</a> 对于 <code>web App</code></h3>\n<ol>\n<li>\n<p><code>PWA</code> 可离线访问应用，体验接近 <code>Native App</code>，2017 年 <code>twitter</code> 的 <code>PWA</code> 显著降低了用户跳出率。</p>\n</li>\n<li>\n<p><code>PWA</code> 具备推送消息的能力，可即时加载和定期更新。</p>\n</li>\n</ol>\n<h3 id="对于-native-app"><a class="header-anchor" href="#对于-native-app" aria-hidden="true">#</a> 对于 <code>Native App</code></h3>\n<ol>\n<li>\n<p><code>PWA</code> 因存在 <code>manifest</code> 清单而具有 <code>SEO</code> 增强，可被搜索引擎发现，可安装于移动端桌面。</p>\n<ul>\n<li><code>native app</code> 天生是封闭的环境，故不存在 <code>SEO</code> 能力，<code>PWA</code> 在浏览器环境下运行，存在 <code>manifest</code> 清单,故具有 <code>native app</code> 所不具有的 <code>SEO</code> 能力。</li>\n</ul>\n</li>\n<li>\n<p><code>PWA</code> 无需借助应用商店安装，可直接使用。</p>\n</li>\n<li>\n<p><code>PWA</code> 无需手动更新，它借助 <code>Service Worker</code> 保持最新状态。</p>\n</li>\n</ol>\n<h3 id="对于以上二者"><a class="header-anchor" href="#对于以上二者" aria-hidden="true">#</a> 对于以上二者</h3>\n<ol>\n<li><code>PWA</code> 兼容任何具有浏览器的设备。因为它只依赖于支持 <code>Service Worker</code> 的浏览器运行。</li>\n</ol>\n<h2 id="基本架构"><a class="header-anchor" href="#基本架构" aria-hidden="true">#</a> 基本架构</h2>\n<h3 id="app-shell"><a class="header-anchor" href="#app-shell" aria-hidden="true">#</a> <code>App shell</code></h3>\n<p><code>App shell</code> 是驱动 <code>PWA</code> 的 <em><strong>最小</strong></em> <code>HTML</code>，<code>CSS</code>，<code>JS</code>的集合。可理解为 <code>App shell</code> 是 <code>PWA</code> 运行的 <em><strong>基础架构</strong></em>。<code>PWA</code> 中所有的数据层内容都将在 <code>App shell</code> 中运行。</p>\n<p><code>App shell</code> 架构将应用核心架构与 UI 和 数据层 分离。应用核心架构与 UI （即 <code>App shell</code> ）在初次加载时就被缓存。在后续加载应用时， <em><strong>只需要</strong></em> 请求更新的数据层内容即可。应用的核心架构和 UI 是从 <em><strong>本地缓存</strong></em> 中读取，避免了多次重复请求应用核心和 UI。此时的 <code>PWA</code> 因仅需要请求数据层数据而具备了快速启动的能力。</p>\n<h3 id="server-worker"><a class="header-anchor" href="#server-worker" aria-hidden="true">#</a> <code>Server Worker</code></h3>\n<p><code>Service Worker</code>（又称<a href="https://developers.google.com/web/fundamentals/primers/service-workers/" target="_blank" rel="noopener noreferrer">服务工作线程<OutboundLink/></a>）运行在 <em><strong>独立</strong></em> 于浏览器主线程的 <code>ServiceWorkerGlobalScope</code> 上下文环境（即浏览器后台）中。它现阶段支持 <em><strong>离线体验</strong></em>，包含推送通知和后台同步等功能。</p>\n<ol>\n<li>\n<p>它属于 JS 工作线程的一种，但 <em><strong>不具备</strong></em> 访问 <code>DOM</code> 的能力。它通过 <code>postMessage</code> 接口来与控制的页面通信。</p>\n</li>\n<li>\n<p>本质是一种可编程的网络代理。可控制页面所发网络请求的处理方式。</p>\n</li>\n<li>\n<p>它在闲置时会被终止，在有需要时重启。所以不应依赖 <code>Service Worker</code> 的 <code>onfetch</code> 和 <code>onmessage</code> 处理全局状态。</p>\n</li>\n<li>\n<p>它是基于 <code>Promise</code> 对象的实现。</p>\n</li>\n</ol>\n<p><em><strong>notice</strong></em>: <code>./service-worker.js</code> 的 <code>register</code> 注册路径是基于 <em><strong>应用</strong></em> 的 <em><strong>根路径</strong></em>，而不是相对于以上注册程序代码的路径。因为 <code>Service Worker</code> 的作用域是由应用的根路径文件夹所定义的。（<a href="https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/#_15" target="_blank" rel="noopener noreferrer">Google Developers<OutboundLink/></a>）</p>\n<p>另附截止至本文发表之时 <code>Service Worker</code> 的兼容性列表 —— <a href="https://jakearchibald.github.io/isserviceworkerready/" target="_blank" rel="noopener noreferrer">Is Service Worker ready<OutboundLink/></a>。</p>\n<h3 id="service-worker-与-app-shell"><a class="header-anchor" href="#service-worker-与-app-shell" aria-hidden="true">#</a> <code>Service Worker</code> 与 <code>App shell</code></h3>\n<p>基于 <code>Service Worker</code> 的可离线使用，消息推送，网络请求代理等特性，我们可以使用 <code>Service Worker</code> 来缓存 <code>App shell</code> 来实现 <code>PWA</code> 的渐进增强。</p>\n<h2 id="service-worker-的生命周期"><a class="header-anchor" href="#service-worker-的生命周期" aria-hidden="true">#</a> <code>Service Worker</code> 的生命周期</h2>\n<p><code>Service Worker</code> 的生命周期完全独立于网页。<code>Service Worker</code> 在第一次打开应用页面界面时， 在页面的 JS 脚本中注册。（<a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle?hl=zh-cn" target="_blank" rel="noopener noreferrer">Google Developers<OutboundLink/></a>，<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API" target="_blank" rel="noopener noreferrer">MDN<OutboundLink/></a>）</p>\n<p><img src="https://assets.set.sh/2018/180707-pwa-fundamentals/sw-lifecycle.png" alt="sw-lifecycle"></p>\n<h3 id="install-event"><a class="header-anchor" href="#install-event" aria-hidden="true">#</a> Install event</h3>\n<p>该事件主要用于缓存 <code>App shell</code>。</p>\n<ul>\n<li>在安装 <code>Service Worker</code> 时，第一个触发的事件就是 <a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle?hl=zh-cn#install" target="_blank" rel="noopener noreferrer">install<OutboundLink/></a> 事件，在该事件完成后，可认为 <code>Service Worker</code> 安装完成。</li>\n</ul>\n<pre v-pre class="language-js"><code><span class="token comment">// app.js</span>\n<span class="token comment">// 注册 Service worker</span>\n<span class="token comment">// https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/#_14</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">\'serviceWorker\'</span> <span class="token keyword">in</span> navigator<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  navigator<span class="token punctuation">.</span>serviceWorker\n    <span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span><span class="token string">\'./service-worker.js\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'Service Worker registered !\'</span><span class="token punctuation">,</span> reg<span class="token punctuation">.</span>scope<span class="token punctuation">)</span><span class="token punctuation">)</span>\n    <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">\'Service Worker registered unsuccessfully !\'</span><span class="token punctuation">,</span> err<span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<pre v-pre class="language-js"><code><span class="token comment">// service-worker.js</span>\n<span class="token keyword">const</span> cacheName <span class="token operator">=</span> <span class="token string">\'PWA-application\'</span>\n<span class="token keyword">const</span> filesToCache <span class="token operator">=</span> <span class="token punctuation">[</span>\n  <span class="token string">\'/\'</span><span class="token punctuation">,</span>\n  <span class="token string">\'/index.html\'</span><span class="token punctuation">,</span>\n  <span class="token comment">// ...</span>\n<span class="token punctuation">]</span>\n\nself<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'install\'</span><span class="token punctuation">,</span> evt <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'[ServiceWorker] Install\'</span><span class="token punctuation">)</span>\n  <span class="token comment">// ExtendableEvent.waitUntil() 用于延长时间的寿命从而阻止浏览器在事件中的异步操作</span>\n  <span class="token comment">// 完成之前终止服务工作线程</span>\n  evt<span class="token punctuation">.</span><span class="token function">waitUntil</span><span class="token punctuation">(</span>\n    <span class="token comment">// caches 对象是用于开辟存储容器。另注，是调用 caches 开辟容器而不是 Cache 或 cache</span>\n    <span class="token comment">// caches.open 返回匹配 cacheName 的 cache 对象的 Promise。</span>\n    caches<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span>cacheName<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>cache <span class="token operator">=></span> <span class="token punctuation">{</span>\n\n      <span class="token comment">// cache 参数即为匹配的 cache 对象</span>\n      console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">\'[ServiceWorker] Caching app shell\'</span><span class="token punctuation">)</span>\n\n      <span class="token comment">// addAll 用于缓存当前 URL 数组（即 request[]）中每一项。</span>\n      <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">addAll</span><span class="token punctuation">(</span>filesToCache<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>在示例代码中 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache" target="_blank" rel="noopener noreferrer">cache<OutboundLink/></a> 对象为缓存的 <code>Request / Response</code> 对象提供 <em><strong>存储容器</strong></em>。<code>cache.addAll</code> 方法具有原子性，任意一个文件缓存失败，整个缓存步骤也将失败。</p>\n<h3 id="activate-event"><a class="header-anchor" href="#activate-event" aria-hidden="true">#</a> Activate event</h3>\n<p>该事件主要用于更新 <code>cache</code> 容器。</p>\n<ul>\n<li>在安装事件完成后，会触发一个 <a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle?hl=zh-cn#activate_1" target="_blank" rel="noopener noreferrer">activate<OutboundLink/></a> 激活事件，<code>activate</code> 事件会在新的 <code>Service Worker</code> 启动时触发（旧版本 <code>Service Worker</code> 不触发该事件）。它触发时会清理与之前版本的 <code>Service Worker</code> 相关联的旧资源与旧缓存。</li>\n</ul>\n<pre v-pre class="language-js"><code><span class="token comment">// service-worker.js</span>\n<span class="token comment">// 只在不存在或旧版本 `Service Worker` 不再与任何页面关联时触发，否则进入 `waiting</span>\n<span class="token comment">// to activate` 阶段。</span>\nself<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'activate\'</span><span class="token punctuation">,</span> e <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'[ServiceWorker] Activate\'</span><span class="token punctuation">)</span>\n  e<span class="token punctuation">.</span><span class="token function">waitUntil</span><span class="token punctuation">(</span>\n    <span class="token comment">// 循环所有的 cache 容器</span>\n    caches<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>keyList <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span>keyList<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>key <span class="token operator">=></span> <span class="token punctuation">{</span>\n        <span class="token comment">// 删除所有除当前 cache 容器以外的所有容器，又因为 activate 事件仅在新版本</span>\n        <span class="token comment">// `Service Worker` 使用时才被调用，即可保证 Service Worker 在 App shell 更</span>\n        <span class="token comment">// 改时更新 cache 容器，删除旧容器</span>\n        <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">!==</span> cacheName<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'[Service worker] Removing old cache\'</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span>\n          <span class="token comment">// caches.delete 用于删除开辟的 cache 容器</span>\n          <span class="token keyword">return</span> caches<span class="token punctuation">.</span><span class="token keyword">delete</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span>\n        <span class="token punctuation">}</span>\n      <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">)</span>\n  <span class="token keyword">return</span> self<span class="token punctuation">.</span>clients<span class="token punctuation">.</span><span class="token function">claim</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token comment">// 以上代码保证在 App shell 更新时，即启用新的 `Service Worker` 时更新 cache 缓存容器。</span>\n<span class="token comment">// 另外必须在 `Service Worker` 文件顶部重新定义 `cacheName` 变量。</span>\n</code></pre>\n<p><em><strong>Notice</strong></em>: 如果现有的 <code>Service Worker</code> 已启用，那么新版本仅会在后台安装，但 <em><strong>不会</strong></em> 被激活，此时被称为 <a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle?hl=zh-cn#waiting" target="_blank" rel="noopener noreferrer">worker in waiting<OutboundLink/></a>。直到已加载的页面不再使用旧的 <code>Service Worker</code> 才会激活新的 <code>Service Worker</code>。只要旧版本的 <code>Service Worker</code> 不再与任何页面关联。那么新版本就会替代旧版本的 <code>Service Worker</code> 成为 <code>active worker</code>。旧版本及其关联资源（缓存）就会被清除。</p>\n<h2 id="读取-app-shell-缓存"><a class="header-anchor" href="#读取-app-shell-缓存" aria-hidden="true">#</a> 读取 App shell 缓存</h2>\n<p><code>Service Worker</code> 通过拦截 <code>PWA</code> 请求来决定从缓存中读取 <code>App shell</code>。仅当缓存中不存在 <code>App shell</code> 时，<code>Service Worker</code> 才会默认使用原生 <code>fetch</code> API 来请求源服务器获得一个副本。</p>\n<pre v-pre class="language-js"><code>self<span class="token punctuation">.</span><span class="token function">addEventListener</span><span class="token punctuation">(</span><span class="token string">\'fetch\'</span><span class="token punctuation">,</span> evt <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'[ServiceWorker] Fetch\'</span><span class="token punctuation">,</span> evt<span class="token punctuation">.</span>request<span class="token punctuation">.</span>url<span class="token punctuation">)</span>\n  evt<span class="token punctuation">.</span><span class="token function">respondWith</span><span class="token punctuation">(</span>\n    <span class="token comment">// caches.match 评估是否存在 evt.request 缓存</span>\n    caches<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>evt<span class="token punctuation">.</span>request<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=></span> <span class="token punctuation">{</span>\n      <span class="token keyword">return</span> response <span class="token operator">||</span> <span class="token function">fetch</span><span class="token punctuation">(</span>evt<span class="token punctuation">.</span>request<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p><img src="https://assets.set.sh/2018/180707-pwa-fundamentals/sw-fetch.png" alt="sw-fetch"></p>\n<p>当 <code>Cache storage</code> 中不存在指定 <code>cacheName</code> 的 <code>cache</code> 容器时，将发起网络请求，最终将缓存新的 <code>App shell</code> 于指定的 <code>cache</code> 容器中。</p>\n<p><img src="https://assets.set.sh/2018/180707-pwa-fundamentals/sw-offline.png" alt="sw-offline"></p>\n<p><code>Service Worker</code> 存在指定的 <code>App shell</code> 时，将从指定的 <code>cache</code> 容器中读取。</p>\n<h3 id="边界情况"><a class="header-anchor" href="#边界情况" aria-hidden="true">#</a> 边界情况</h3>\n<ol>\n<li>缓存取决于为每次更改更新缓存容器键名</li>\n</ol>\n<p>以上 <code>Service Worker</code> 读取 <code>App shell</code> 时，仅当 <code>cacheName</code> 发生改变时，才会更新 <code>App shell</code>。否则将保持使用旧的缓存。即缓存取决于缓存键名。</p>\n<ol start="2">\n<li>更新容器却更新了整个缓存容器</li>\n</ol>\n<p>这样有一个缺点，就是只要一个文件发生变化时，为了更新缓存就不得不使整个 <code>cache</code> 容器失效，而重新下载新的 <code>App shell</code>。这样是有很大的性能浪费的。</p>\n<p>解决方案可以是将 <code>cacheName</code> 指定为根据内容而生成的文件名。即 <code>content hash</code> 文件名。</p>\n<ol start="3">\n<li>浏览器自身缓存可能阻止 <code>Service Worker</code> 的缓存更新</li>\n</ol>\n<p>在初次安装处理程序时（<code>install handler</code>）浏览器将不会返回从浏览器缓存中返回数据，而是一定会执行 <code>HTTPS</code> 请求（补充：<code>Service Worker</code> 除本地服务器外仅支持 <code>HTTPS</code> 协议。）。这样做的目的就是为了保证安装的 <code>App shell</code> 一定是最新版。否则，浏览器将在初次安装 <code>App shell</code> 时使用旧版本 <code>App shell</code>。这将导致 <code>Service Worker</code> 永远得不到更新。因为浏览器在该情境下在一直循环使用旧版本。</p>\n<p>推荐的方案是在安装 <code>App shell</code> 时总是请求源服务器。</p>\n<ol start="4">\n<li>谨慎地在生产环境中执行缓存优先策略（<code>cache-first</code>）</li>\n</ol>\n<p>在生产环境中执行缓存优先策略时，将导致任何读取缓存的时候都不会查询网络。这将导致只要本地有缓存，就几乎不可能更新本地的 <code>Service Worker</code> 配置中的 <code>App shell</code>。</p>\n<p>因为 <code>Service Worker</code> 配置是取决于定义注册该 <code>Service Worker</code> 的 <em><strong>那个</strong></em> 文件，而不是服务器。（本文中指的是当时注册该 <code>Service Worker</code> 的 <code>./service-worker.js</code>）（此处原文为 <code>Since the configuration depends on where it was defined</code>）</p>\n<p>处理以上四点边界情况推荐使用 <a href="https://github.com/GoogleChrome/sw-precache" target="_blank" rel="noopener noreferrer">sw-precache<OutboundLink/></a> 或 <a href="https://github.com/GoogleChrome/workbox" target="_blank" rel="noopener noreferrer">workbox<OutboundLink/></a>（Google 推荐 <code>workbox</code>） 之类的内容库来管理缓存。</p>\n<h2 id="reference"><a class="header-anchor" href="#reference" aria-hidden="true">#</a> Reference</h2>\n<ul>\n<li>\n<p><a href="https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/" target="_blank" rel="noopener noreferrer">Your first progressive web app<OutboundLink/></a>（Google Developers）</p>\n</li>\n<li>\n<p><a href="https://developers.google.com/web/fundamentals/primers/service-workers/" target="_blank" rel="noopener noreferrer">Service Worker<OutboundLink/></a>（Google Developers）</p>\n</li>\n<li>\n<p><a href="https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle" target="_blank" rel="noopener noreferrer">Service Worker lifecycle<OutboundLink/></a>（Google Developers）</p>\n</li>\n<li>\n<p><a href="https://codelabs.developers.google.com/codelabs/debugging-service-workers/#0" target="_blank" rel="noopener noreferrer">Debugging service workers<OutboundLink/></a>（Google Developers）</p>\n</li>\n<li>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers" target="_blank" rel="noopener noreferrer">Using service worker<OutboundLink/></a>（MDN）</p>\n</li>\n<li>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage/open" target="_blank" rel="noopener noreferrer">CacheStorage.open<OutboundLink/></a>（MDN）</p>\n</li>\n<li>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage/delete" target="_blank" rel="noopener noreferrer">CacheStorage.delete<OutboundLink/></a>（MDN）</p>\n</li>\n<li>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage/keys" target="_blank" rel="noopener noreferrer">CacheStorage.keys<OutboundLink/></a>（MDN）</p>\n</li>\n<li>\n<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache/addAll" target="_blank" rel="noopener noreferrer">Cache.addAll<OutboundLink/></a>（MDN）</p>\n</li>\n</ul>\n'}],error:null,serverRendered:!0}</script><script defer src="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js"></script><script defer src="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js"></script><script defer src="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js"></script><script defer src="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js"></script><script defer src="/_nuxt/vendor.13de21511613edf061b2.js"></script><script defer src="/_nuxt/app.5a4fa6b8fcf73db97515.js"></script>