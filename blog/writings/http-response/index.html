<!doctype html><html data-n-head="lang" data-n-head-ssr lang="zh"><meta data-n-head="true" content="IE=edge,chrome=1" http-equiv='"X-UA-Compatible'><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" name="viewport"><meta data-n-head="true" content="bowen blog, bowen 博客, vuejs, reactjs, ssr, 前端开发, 前端 , web开发, nodejs, github" name="keywords"><meta data-n-head="true" content="一个分享代码经历的地方" name="description" data-hid="description"><meta data-n-head="true" content="yes" name="apple-mobile-web-app-capable"><meta data-n-head="true" content="black" name="apple-mobile-web-app-status-bar-style"><meta data-n-head="true" content="yes" name="mobile-web-app-capable" data-hid="mobile-web-app-capable"><meta data-n-head="true" content="Bowen Blog" name="apple-mobile-web-app-title" data-hid="apple-mobile-web-app-title"><meta data-n-head="true" content="Bowen" name="author" data-hid="author"><meta data-n-head="true" content="#24292e" name="theme-color" data-hid="theme-color"><meta data-n-head="true" content="website" name="og:type" data-hid="og:type" property="og:type"><meta data-n-head="true" content="Bowen Blog" name="og:title" data-hid="og:title" property="og:title"><meta data-n-head="true" content="A place which is used to share programming experiences" name="og:description" data-hid="og:description" property="og:description"><title data-n-head="true">HTTP 协议响应首部 | Bowen Blog</title><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="/_nuxt/manifest.2108b1d4.json" rel="manifest" data-n-head="true"><link href="/_nuxt/icons/icon_64.e20A200w20w.png" rel="shortcut icon" data-n-head="true"><link href="/_nuxt/icons/icon_512.e20A200w20w.png" rel="apple-touch-icon" data-n-head="true" sizes="512x512"><link href="https://set.sh/blog/writings/http-response/" rel="alternate" data-n-head="true" hreflang="zh"><link href="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js" rel="preload" as="script"><link href="/_nuxt/vendor.13de21511613edf061b2.js" rel="preload" as="script"><link href="/_nuxt/app.5a4fa6b8fcf73db97515.js" rel="preload" as="script"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="preload" as="style"><link href="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js" rel="preload" as="script"><link href="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/tags/_id/index.edb9dbabb1b9c2ef81f2.js" rel="prefetch"><link href="/_nuxt/pages/index.1d0ac68e309be0e86168.js" rel="prefetch"><link href="/_nuxt/pages/blog/tags/index.2659d358b69abdfd34bf.js" rel="prefetch"><link href="/_nuxt/pages/blog/projects/index.3ff8e031c3cb4f25eaed.js" rel="prefetch"><link href="/_nuxt/pages/blog/writings/index.b016af22016e152b7231.js" rel="prefetch"><link href="/_nuxt/layouts/home.dd55e95df1c2109ebde6.js" rel="prefetch"><link href="/_nuxt/layouts/default.89ffa224d3d7769e4fbb.js" rel="prefetch"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="stylesheet"><body data-n-head=""><div id="__nuxt" data-server-rendered="true"><div class="nuxt-progress" style="width:0%;height:2px;background-color:#3eaf7c;opacity:0"></div><div id="__layout"><section class="blog sf__parent__clearfix" data-v-cac63c14><header class="header __position components-animation" data-v-13c46026 data-v-cac63c14><nav class="mobile-navigator" data-v-13c46026 data-v-d4cae7a6><label class="label-line" data-v-d4cae7a6><span class="__position label-line line-top" data-v-d4cae7a6><span class="__position line-crust line-crust-top" data-v-d4cae7a6></span></span><span class="__position label-line line-bottom" data-v-d4cae7a6><span class="__position line-crust line-crust-bottom" data-v-d4cae7a6></span></span></label></nav><nav class="navigator __position grid" data-v-13c46026 role="navigation"><a href="/" class="navigator-link hover-animation grid-cell" data-v-13c46026>HOME</a><a href="/blog/writings/" class="navigator-link hover-animation grid-cell" data-v-13c46026>WRITINGS</a><a href="/blog/projects/" class="navigator-link hover-animation grid-cell" data-v-13c46026>PROJECTS</a><a href="/blog/tags/" class="navigator-link hover-animation grid-cell" data-v-13c46026>TAGS</a><a href="https://github.com/lbwa" class="navigator-link hover-animation grid-cell" data-v-13c46026 rel="noopener" target="_blank">GITHUB</a></nav><div class="background-helper __position" data-v-13c46026></div></header><main class="articles-container wrapper sf__reference__layout" data-v-cac63c14 role="main"><article class="articles-main"><div class="article-header"><h1 class="article-title">HTTP 协议响应首部</h1><span class="article-author">Bowen</span><span class="article-date">2018 JUN 07</span><div class="article-tags"><a href="/blog/tags/前端开发" class="article-tag">前端开发</a><a href="/blog/tags/网络请求" class="article-tag">网络请求</a></div></div><div class="article-content"><p><code>HTTP</code> 响应首部即 <code>Response Headers</code>。它将与 <code>HTTP</code> 请求首部内容协商（<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation" rel="noopener noreferrer" target="_blank">source<outboundlink></a>），再根据 <code>server</code> 端的内部实现并依托 <code>HTTP</code> 响应首部来返回实际的协商结果。故返回的值可能不匹配 <code>HTTP</code> 请求头的值。<h2 id="access-control-allow-origin"><a href="#access-control-allow-origin" class="header-anchor" aria-hidden="true">#</a> Access-Control-Allow-Origin</h2><ul><li><p>常用于 HTTP 请求跨域解决方案之一 —— <code>CORS</code> 。表示指定了该响应资源只允许被给定的 <code>Origin</code> 共享。该值设置为 <code>*</code> 时，表示允许所有源都具有访问该资源的权限（<a href="https://fetch.spec.whatwg.org/#http-access-control-allow-origin" rel="noopener noreferrer" target="_blank">source<outboundlink></a>）。<li><p>该属性只能指定一个 <em><strong>唯一值</strong></em>，不接受多个值。<ul><li>若有多个源需要通过 CORS 跨域，那么可配置一个模块。该模块在 <code>server</code> 端设置该头部前配置筛选出 URL 是否为白名单内源，若是白名单内源，那么就配置头部 <code>Access-Control-Allow-Origin</code>，否则不配置该头部。</ul></ul><p>详见我的另一篇博文👉<a href="/blog/writings/cross-domain-solution/">客户端跨域解决方案</a><h2 id="access-control-allow-headers"><a href="#access-control-allow-headers" class="header-anchor" aria-hidden="true">#</a> Access-Control-Allow-Headers</h2><ul><li>常用于标记超出 <code>CORS</code> 限定配置的 <code>request headers</code> 是否合法。表示指定在 <code>CORS</code> 请求中除限定配置外额外被允许的请求头（<a href="https://fetch.spec.whatwg.org/#http-access-control-allow-headers" rel="noopener noreferrer" target="_blank">source<outboundlink></a>）。</ul><h3 id="cors-请求限制"><a href="#cors-请求限制" class="header-anchor" aria-hidden="true">#</a> CORS 请求限制</h3><ul><li><p>默认允许的 <code>CORS</code> 请求方法（<a href="https://fetch.spec.whatwg.org/#methods" rel="noopener noreferrer" target="_blank">source<outboundlink></a>）<ul><li>只允许 <code>GET</code>、<code>POST</code>、<code>HEAD</code> 方法。使用其他请求方法都需要经过 <code>CORS</code> 预请求。</ul><li><p>默认允许的 <code>CORS</code> 请求头（<a href="https://fetch.spec.whatwg.org/#cors-safelisted-request-header" rel="noopener noreferrer" target="_blank">source<outboundlink></a>）<ul><li><code>Accept</code><li><code>Accept-Language</code><li><code>Content-Language</code><li><code>Content-Type</code> 中仅包含 <code>text/plain</code>、<code>multipart/form-data</code>、<code>application/x-www-form-urlencoded</code> 三种 <code>MIME</code> 类型值。</ul><li><p>其他限制<ol><li><p><code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听程序。<li><p>请求中没有使用 <code>ReadableStream</code> 对象。</ol></ul><p><em><strong>总结</strong></em>:使用其他超出以上 <code>CORS</code> 请求所限定的配置都将需要经过 <code>CORS</code> 预请求检测 <code>CORS</code> 请求头的合法性。<h3 id="cors-预请求"><a href="#cors-预请求" class="header-anchor" aria-hidden="true">#</a> CORS 预请求</h3><p><code>CORS</code> 预请求的 <code>Request Method</code> 值为 <code>OPTIONS</code>。<p>在浏览器即将发起超过 1 中限定配置的 <code>CORS</code> 请求时，将触发浏览器 <code>CORS</code> 预请求策略。该策略用于在发起正式的 <code>CORS</code> 请求之前确认 <code>CORS</code> 请求中超出限定配置的部分是否合法。仅当超出默认配置的默认配置被 <code>server</code> 端认可时，浏览器才会真正 <em><strong>解析</strong></em> CORS 正式请求返回的数据。<ul><li>不论 <code>CORS</code> 预请求是否合法，浏览器均会发出正式的 <code>CORS</code> 请求，合法性检测的意义在于浏览器 <em><strong>是否解析</strong></em> 返回的数据（该原理类似浏览器对跨域资源的解析策略（<a href="/blog/writings/cross-domain-solution/#%E5%AF%B9%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%90%86%E8%A7%A3">extension</a>））。</ul><pre class="language-js" v-pre><code><span class="token comment">// server1.js</span>
<span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span>

http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'request.url :'</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>url<span class="token punctuation">)</span>

  <span class="token keyword">const</span> html <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">'cross-domain-solution.html'</span><span class="token punctuation">,</span> <span class="token string">'utf8'</span><span class="token punctuation">)</span>
  response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token string">'Content-type'</span><span class="token punctuation">:</span> <span class="token string">'text/html'</span><span class="token punctuation">,</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">'server listening at port 8888'</span><span class="token punctuation">)</span>
</code></pre><pre class="language-js" v-pre><code><span class="token comment">// client.html</span>
<span class="token comment">// client 跨域请求 server2 数据</span>
<span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'http://127.0.0.1:8800'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  method<span class="token punctuation">:</span> <span class="token string">'POST'</span><span class="token punctuation">,</span>
  headers<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 请求头类型不在 CORS 请求限定配置内，触发 CORS 预请求检测该请求头合法性</span>
    <span class="token string">'X-Test-Cors'</span><span class="token punctuation">:</span> <span class="token string">'test custom headers in CORS preflight'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=></span> <span class="token punctuation">{</span>
    target<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">'check your network tag in console drawer'</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token comment">// 不论 CORS 预请求是否合法，client 均会发起 CORS 正式请求。</span>
</code></pre><p>当被请求的 <code>server2</code> 没有配置 <code>Access-Control-Allow-Headers</code> 或目标值不在该值中时，<code>client</code> 将在预请求响应后报错，但仍发起正式 <code>CORS</code> 请求，但拒绝解析正式 <code>CORS</code> 请求返回的数据。<pre class="language-js" v-pre><code><span class="token comment">// server2.js</span>
<span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'http'</span><span class="token punctuation">)</span>

http<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'request.url :'</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>url<span class="token punctuation">)</span>

  response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token comment">// 允许跨域请求</span>
    <span class="token string">'Access-Control-Allow-Origin'</span><span class="token punctuation">:</span> <span class="token string">'*'</span><span class="token punctuation">,</span>
    <span class="token comment">// 允许除限定配置外额外的合法请求头的值</span>
    <span class="token string">'Access-Control-Allow-Headers'</span><span class="token punctuation">:</span> <span class="token string">'X-Test-Cors'</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'server response'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8800</span><span class="token punctuation">)</span>

console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'server listening at port 8800'</span><span class="token punctuation">)</span>
</code></pre><h2 id="access-control-allow-methods"><a href="#access-control-allow-methods" class="header-anchor" aria-hidden="true">#</a> Access-Control-Allow-Methods</h2><p>该响应头的使用方法与原理于 <code>Access-Control-Allow-Headers</code> 相似。<ul><li><p>常用于标记超出 <code>CORS</code> 限定配置情况下的 <code>Request Method</code> 是否合法（<a href="https://fetch.spec.whatwg.org/#http-access-control-allow-methods" rel="noopener noreferrer" target="_blank">source<outboundlink></a>）。<pre class="language-js" v-pre><code>response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token comment">// 允许跨域请求</span>
  <span class="token string">'Access-Control-Allow-Origin'</span><span class="token punctuation">:</span> <span class="token string">'*'</span><span class="token punctuation">,</span>
  <span class="token comment">// 允许除限定配置外额外的合法 `Request Method` 的值</span>
  <span class="token string">'Access-Control-Allow-Methods'</span><span class="token punctuation">:</span> <span class="token string">'PUT, DELETE'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></ul><h2 id="access-control-max-age"><a href="#access-control-max-age" class="header-anchor" aria-hidden="true">#</a> Access-Control-Max-Age</h2><ul><li>表示当次预请求检测 <code>Access-Control-Allow-Methods</code> 和 <code>Access-Control-Allow-Headers</code> 的缓存有效期，即在有效期内，即使有超出限定配置的 <code>CORS</code> 请求也不需要再进行 <code>CORS</code> 预请求来检测其合法性（<a href="https://fetch.spec.whatwg.org/#http-access-control-max-age" rel="noopener noreferrer" target="_blank">source<outboundlink></a>）。</ul><h2 id="cache-control-缓存头"><a href="#cache-control-缓存头" class="header-anchor" aria-hidden="true">#</a> Cache-Control/缓存头</h2><ul><li>用于指定在 <code>request</code> 或 <code>response</code> 链中缓存当前请求数据，该指令是单向指令（<a href="https://tools.ietf.org/html/rfc7234#section-5.2" rel="noopener noreferrer" target="_blank">source<outboundlink></a>）。</ul><h3 id="可缓存性"><a href="#可缓存性" class="header-anchor" aria-hidden="true">#</a> 可缓存性</h3><ol><li><p><code>public</code> 表示响应链中所有缓存都可存储当前响应数据，如发送客户端，中转服务器等。<li><p><code>private</code> 表示当前响应数据只能单个用户缓存，即中转服务器不能缓存该响应数据。<li><p><code>no-cache</code> 表示在使用本地缓存之前，必须首先请求原 <code>server</code> 端验证当前缓存的数据是否可用。</ol><p><img alt="cache-control" src="https://assets.set.sh/2018/180607-http-response/cache-control.svg"><h3 id="缓存有效期"><a href="#缓存有效期" class="header-anchor" aria-hidden="true">#</a> 缓存有效期</h3><ol><li><p><code>max-age=&lt;seconds></code> 于 <code>server</code> 端设置响应数据在 <code>client</code> 端的缓存有效期，始于请求时间点。在有效期内，<code>client</code> 将读取缓存数据而不是请求数据。即使在 <code>server</code> 端该数据已经被更新，也不会改变 <code>client</code> 在有效期内读取缓存的策略，因为 <code>client</code> 在有效期内当前请求 URL 未改变的情况下就不会去请求该数据，所以 <code>client</code> 并不知道该数据已经在 <code>server</code> 端被更新了。<ul><li><em><strong>拓展应用</strong></em>：根据静态资源的 <em><strong>内容</strong></em> 打包生成的 <code>contentHash</code> 码来命名常缓存文件。只要 <code>server</code> 端该静态资源文件被更新，那么该资源的 <code>contentHash</code> 一定变化，即请求 URL 改变，那么 <code>client</code> 知晓当前静态资源请求 URL 改变后，即使在缓存有效期内，也会重新请求该资源。这样做的目的是最大限度使用缓存文件，且规避在有效期内即使 <code>server</code> 端数据被更新但仍使用缓存文件的问题。</ul></ol><pre class="language-js" v-pre><code>response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token string">'Content-type'</span><span class="token punctuation">:</span> <span class="token string">'text/javascript'</span><span class="token punctuation">,</span>
  <span class="token string">'Cache-Control'</span><span class="token punctuation">:</span> <span class="token string">'max-age=200, public'</span> <span class="token comment">// 以秒为单位</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'console.log("script loaded")'</span><span class="token punctuation">)</span>
</code></pre><ol start="2"><li><p><code>s-maxage=&lt;seconds></code> 覆盖 <code>max-age=&lt;seconds></code>，只在共享缓存中（如中转服务器）有效。<li><p><code>max-stale[=&lt;seconds>]</code> 表示即使缓存过期，仍可接受一个（在指定时间内）已过期资源，只在发起端设置才有效，在 <code>server</code> 端响应数据中设置是无效的。</ol><h3 id="验证"><a href="#验证" class="header-anchor" aria-hidden="true">#</a> 验证</h3><ol><li><p><code>must-revalidate</code> 在使用之前的旧资源时，必须请求原 <code>server</code> 端来验证当前旧资源是否已经过期。<li><p><code>proxy-revalidate</code> 与 <code>must-revalidate</code> 作用相同，但仅适用于共享缓存，如中转服务器。</ol><h3 id="其他"><a href="#其他" class="header-anchor" aria-hidden="true">#</a> 其他</h3><ol><li><p><code>no-store</code> 表示所有的链中节点的缓存都不可存储当前响应数据。<li><p><code>no-transform</code> 表示不能对当前响应数据进行转换或变化。</ol><p><em><strong>注</strong></em>：以上所有指令都不具有强制力，仅表示一种约束期望。<h2 id="last-modified-缓存验证"><a href="#last-modified-缓存验证" class="header-anchor" aria-hidden="true">#</a> Last-Modified/缓存验证</h2><ul><li><p>用于 <code>server</code> 端标记响应数据上次修改的时间，据此来判断本地缓存是否需要更新。<ul><li><p>一般在使用对应的数据缓存之前，<code>client</code> 首先通过配合 <code>If-Modified-Since</code> 或 <code>If-Unmodified-Since</code> <em><strong>请求头</strong></em> 来向 <code>server</code> 端传输之前的 <code>Last-Modified</code> 值。<code>server</code> 端据此可以来判断 <code>client</code> 端与 <code>server</code> 端的数据是否是同步的，即验证本地缓存是否需要更新。<ul><li>注：在 <code>Cache-Control</code> 配置了 <code>no-store</code> 时，<code>client</code> 将不会携带 <code>If-Modified-Since</code> 或 <code>If-Unmodified-Since</code> 请求头。</ul></ul></ul><h2 id="etag-缓存验证"><a href="#etag-缓存验证" class="header-anchor" aria-hidden="true">#</a> Etag/缓存验证</h2><p>用于通过数据签名（如根据内容的 <code>contentHash</code> 计算）来 <em><strong>严格验证</strong></em> 数据是否需要更新。<ul><li><code>client</code> 在下次使用该缓存之前，一般配合 <code>If-Match</code> 或 <code>If-Non-Match</code> <em><strong>请求头</strong></em> 来向 <code>server</code> 传输本地缓存的数据签名。<code>server</code> 端据此判断数据签名是否一致，即<code>server</code> 是应该向 <code>client</code> 返回新的数据，还是可以直接使用 <code>client</code> 端本地缓存。</ul><pre class="language-js" v-pre><code>response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token string">'Content-type'</span><span class="token punctuation">:</span> <span class="token string">'text/javascript'</span><span class="token punctuation">,</span>
  <span class="token string">'Cache-Control'</span><span class="token punctuation">:</span> <span class="token string">'max-age=20000000, no-cache'</span><span class="token punctuation">,</span>
  <span class="token string">'Last-Modified'</span><span class="token punctuation">:</span> <span class="token string">'18/06/06 00:00:00'</span><span class="token punctuation">,</span> <span class="token comment">// 上次修改日期</span>
  <span class="token string">'Etag'</span><span class="token punctuation">:</span> <span class="token string">'777'</span> <span class="token comment">// 指定数字签名</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 读取请求头</span>
<span class="token keyword">const</span> etag <span class="token operator">=</span> request<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">'If-None-Match'</span><span class="token punctuation">]</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>etag <span class="token operator">&&</span> etag <span class="token operator">===</span> <span class="token string">'777'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">304</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token string">'Content-type'</span><span class="token punctuation">:</span> <span class="token string">'text/javascript'</span><span class="token punctuation">,</span>
    <span class="token string">'Cache-Control'</span><span class="token punctuation">:</span> <span class="token string">'max-age=20000000, no-cache'</span><span class="token punctuation">,</span>
    <span class="token string">'Last-Modified'</span><span class="token punctuation">:</span> <span class="token string">'18/06/06 00:00:00'</span><span class="token punctuation">,</span>
    <span class="token string">'Etag'</span><span class="token punctuation">:</span> <span class="token string">'777'</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 即使此处返回内容，client 也会忽略该内容而使用本地缓存。</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token string">'Content-type'</span><span class="token punctuation">:</span> <span class="token string">'text/javascript'</span><span class="token punctuation">,</span>
    <span class="token comment">/**
     * 1. 配置 no-cache 用于在每次使用本地缓存之前，强制向 server 端验证是否可使
     * 用本地缓存
     */</span>
    <span class="token string">'Cache-Control'</span><span class="token punctuation">:</span> <span class="token string">'max-age=20000000, no-cache'</span><span class="token punctuation">,</span>
    <span class="token string">'Last-Modified'</span><span class="token punctuation">:</span> <span class="token string">'18/06/06 00:00:00'</span><span class="token punctuation">,</span>
    <span class="token string">'Etag'</span><span class="token punctuation">:</span> <span class="token string">'777'</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
  response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'console.log("script updated")'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">'console.log("script loaded")'</span><span class="token punctuation">)</span>
</code></pre><ul><li>注：在 <code>Cache-Control</code> 配置了 <code>no-store</code> 时，<code>client</code> 将不会携带 <code>If-Match</code> 或 <code>If-Non-Match</code> 请求头。</ul><h2 id="set-cookie"><a href="#set-cookie" class="header-anchor" aria-hidden="true">#</a> Set-Cookie</h2><p>用于 <code>server</code> 端通过 <code>Set-Cookie</code> 设置 <code>client</code> 端的 <code>HTTP Cookie</code>。<h3 id="特点"><a href="#特点" class="header-anchor" aria-hidden="true">#</a> 特点</h3><p><code>Set-Cookie</code> 响应首部不同于 <code>Cookie</code> 请求首部，它 <em><strong>不具有唯一性</strong></em>。在 <code>Node.js</code> 中它通过一个数组来设置多个<code>Set-Cookie</code> 响应头。<pre class="language-js" v-pre><code>response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token string">'Content-type'</span><span class="token punctuation">:</span> <span class="token string">'text/html'</span><span class="token punctuation">,</span>
  <span class="token string">'Set-Cookie'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'username=John_Wick'</span><span class="token punctuation">,</span> <span class="token string">'gender=male'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>（以下 <code>Cookie</code> 都是指 <code>HTTP Cookie</code>，除非特别指明是 <code>Cookie</code> 请求首部（<a href="/blog/writings/http-request/#cookie">extension</a>）。）<pre class="language-markup" v-pre><code># 创建 client 端 Cookie
Set-Cookie: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cookie-name</span><span class="token punctuation">></span></span>=<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cookie-value</span><span class="token punctuation">></span></span>
</code></pre><p><code>HTTP Cookie</code> （<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" rel="noopener noreferrer" target="_blank">extension<outboundlink></a>）通常用于:<ol><li><p>会话管理，如登录状态，购物车等需要记录的信息。<li><p>用户个性化设置，如用户自定义设置等。<li><p>浏览器行为追踪，如跟踪分析用户行为等。</ol><p>注：不推荐再使用 <code>Cookie</code> 作用为本地存储介质，推荐使用 <code>localStorage</code>、<code>sessionStorage</code>、<code>IndexedDB</code> 代替。 因为每次请求时，在没有禁用 <code>Cookie</code> 的情况下都会携带 <code>Cookie</code> 请求首部传输至 <code>server</code>。如果使用了，将会带来额外的性能开销，尤其是在移动端下。<h3 id="cookie-属性"><a href="#cookie-属性" class="header-anchor" aria-hidden="true">#</a> Cookie 属性</h3><ol><li><p><code>max-age</code>（时长）和 <code>expires</code>（时间点）设置过期时间。<ul><li><p>会话期 <code>Cookie</code>，若设置 <code>Cookie</code> 时未指定过期时间，那么它在浏览器关闭后就会被自动删除。<li><p>持久性 <code>Cookie</code>，在设置 <code>Cookie</code> 时指定了过期时间后，<code>Cookie</code> 将保存至特定的过期时间，除非手动删除。</ul></ol><pre class="language-js" v-pre><code>response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token string">'Content-type'</span><span class="token punctuation">:</span> <span class="token string">'text/html'</span><span class="token punctuation">,</span>
  <span class="token comment">// 使用逗号分隔不同的 Cookie 键值对，分号连接 Cookie 属性</span>
  <span class="token string">'Set-Cookie'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'username=John_Wick'</span><span class="token punctuation">,</span> <span class="token string">'gender=male; Max-Age=5'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><ol start="2"><li><p><code>Secure</code> 只在 <code>HTTPS</code> 协议下发送。<li><p>配置 <code>HttpOnly</code> 可阻止通过 <code>document.cookie</code> 访问指定 <code>Cookie</code>。<li><p><code>domain</code> 属性，用于在访问一级域名设置指定 <code>Cookie</code> 时（前提），授权给所有子级域名指定 <code>Cookie</code> 使用权。</ol><pre class="language-js" v-pre><code>response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token string">'Content-type'</span><span class="token punctuation">:</span> <span class="token string">'text/html'</span><span class="token punctuation">,</span>
  <span class="token string">'Set-Cookie'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'username=John_Wick; domain=github.com'</span><span class="token punctuation">,</span> <span class="token string">'gender=male'</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">/**
 * 1. domain=github.com 表示所有 github.com 的子域名都被授权访问
 * github.com 下的 cookie
 * 2. 必须首先访问一级域名才能设置（被共享的）Cookie
 * 3. 只有设置了 domain 属性的 Cookie 才被共享
 */</span>
</code></pre><p><em><strong>注</strong></em>：<code>Cookie</code> 属性是作用于个体，而非全体。<h2 id="connection-长连接"><a href="#connection-长连接" class="header-anchor" aria-hidden="true">#</a> Connection/长连接</h2><ul><li><p>值为 <code>keep-alive</code> 或 <code>close</code>。<li><p>用于构建 <code>HTTP</code> 长连接，复用同一客户端下的 <code>TCP</code> 通道。即用于告知 <code>client</code> 端在完成本次响应后，<code>server</code> 端是否会关闭当前 <code>TCP</code> 通道。即返回 <code>Connection</code> 请求头的执行结果，并设置为 <code>Connection</code> 响应头。<li><p>在 <code>server</code> 端构建 <code>HTTP</code> 长连接之后，可设置长连接的 <em><strong>有效时间</strong></em>，即在一定时间内没有新的请求时，关闭当前 <code>HTTP</code> 长连接。</ul><p>更多信息，查看本文 <code>HTTP 请求首部</code><a href="/blog/writings/http-request/#connection-%E9%95%BF%E8%BF%9E%E6%8E%A5">章节 - Connection</a>。<h2 id="content-type-内容协商"><a href="#content-type-内容协商" class="header-anchor" aria-hidden="true">#</a> Content-Type/内容协商</h2><p>与 <code>Accept</code> 请求首部对应。<p>用于标注 <code>server</code> 端在与请求首部内容协商（<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation" rel="noopener noreferrer" target="_blank">source<outboundlink></a>）后，实际 <code>server</code> 端返回内容的 <code>MIME</code> 类型。<p><code>MIME</code> 类型对应的文件拓展名：<a href="http://tool.oschina.net/commons" rel="noopener noreferrer" target="_blank">source<outboundlink></a><h2 id="content-encoding-内容压缩"><a href="#content-encoding-内容压缩" class="header-anchor" aria-hidden="true">#</a> Content-Encoding/内容压缩</h2><p>与 <code>Accept-Encoding</code> 请求首部对应。<p>用于标注 <code>server</code> 端在与请求首部内容协商后，实际 <code>server</code> 端返回内容的内容编码类型（即实际使用的压缩算法）。<h3 id="值"><a href="#值" class="header-anchor" aria-hidden="true">#</a> 值</h3><p><code>gzip</code> 表示采用 <code>Lempel-Ziv coding (LZ77)</code> 压缩算法，以及32位CRC校验的编码方式。<p><code>deflate</code> 采用 <code>zlib</code> 结构和 <code>deflate</code> 压缩算法。<p><code>br</code> 表示采用 <code>Brotli</code> 算法的编码方式。<p><code>;q=</code> 表示 <em><strong>权重</strong></em>，即编码方式的优先顺序。<p><code>*</code> 匹配任意未在请求首部中列出的编码方式。<p>以下为不常使用的编码方式：<p><code>compress</code> 采用 <code>Lempel-Ziv-Welch (LZW)</code> 压缩算法，已被大部分浏览器弃用。<p><code>identity</code> 用于指代自身，如未经过压缩或修改。<pre class="language-js" v-pre><code><span class="token comment">// Node.js 编码数据内容的模块</span>
<span class="token keyword">const</span> zlib <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'zlib'</span><span class="token punctuation">)</span>

<span class="token comment">// ...</span>

response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token string">'Content-Type'</span><span class="token punctuation">:</span> <span class="token string">'text/html'</span><span class="token punctuation">,</span>
  <span class="token string">'Content-Encoding'</span><span class="token punctuation">:</span> <span class="token string">'gzip'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>zlib<span class="token punctuation">.</span><span class="token function">gzipSync</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><p><img alt="content-encoding" src="https://assets.set.sh/2018/180607-http-response/content-encoding.png"><p>上图中，<code>420B</code> 则是表示传输的数据内容经过 <code>server</code> 的编码后，传输时的大小。它的大小与内容的实际编码方式有关，即 <code>Content-Encoding</code> 响应首部。<code>476B</code> 为数据内容在 <code>client</code> 端解压后的大小，除非内容变化，否则该值不变。<h2 id="content-language"><a href="#content-language" class="header-anchor" aria-hidden="true">#</a> Content-Language</h2><p>与 <code>Accept-Language</code> 请求首部对应。<p>用于标注 <code>server</code> 端在与请求首部内容协商后，实际 <code>server</code> 端返回的数据内容的自然语言类型。<h2 id="x-content-type-options"><a href="#x-content-type-options" class="header-anchor" aria-hidden="true">#</a> X-Content-Type-Options</h2><p>标注 <code>client</code> 一定要遵循 <code>Content-Type</code> 响应头中的 <code>MIME</code> 类型，不应推测（修改）返回数据 <code>MIME</code> 类型。<ul><li>早期 <code>IE</code> 会因错误的 <code>Content-Type</code> 或未声明该值而根据返回内容推测数据类型。此举极易导致文本代码被执行，那么 <code>client</code> 就可能被恶意注入。</ul><h2 id="location-重定向"><a href="#location-重定向" class="header-anchor" aria-hidden="true">#</a> Location/重定向</h2><p>表示请求当前 URL 时，<code>server</code> 端向 <code>client</code> 端告知之前请求的数据资源转移后的 <code>URL</code>，<code>client</code> 端应该去重定向请求（<code>Redi</code>）这个转移后的 URL。其中，重定向由 <code>client</code> 自动完成完成，不需要人工干预。<ul><li><em><strong>注</strong></em>：必须向 <code>client</code> 端指定 <code>301</code> 或 <code>302</code> 重定向代码，否则浏览器不会自主进行重定向，此刻，将页面空白。</ul><pre class="language-js" v-pre><code><span class="token comment">// server.js</span>
<span class="token keyword">const</span> data <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">'data.html'</span><span class="token punctuation">)</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 必须设置为 302（推荐）或 301 代码，否则客户端无法正常跳转</span>
  response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">302</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token string">'Location'</span><span class="token punctuation">:</span> <span class="token string">'/new-url'</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">'/new-url'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token string">'Content-Type'</span><span class="token punctuation">:</span> <span class="token string">'text/html'</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>

  response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p><code>301</code> 与 <code>302</code> 的区别：<ul><li><p><code>301</code> 表示永久重定向。例如，在请求 <code>url-0</code> 并完成当次重定向 <code>url-1</code> 后，缓存当前 <code>url-1</code>。之后发起的所有 <code>url-0</code> 请求直接在 <code>client</code> <em><strong>本地读取缓存</strong></em> 读取重定向地址 <code>url-1</code> ，此时并不会先向 <code>server</code> 请求重定向的目标地址。<ol><li><p>该存储的 <code>url-1</code> 会在缓存中尽可能长的存储。除非清除了 <code>client</code> 缓存。<li><p>因为是从本地缓存读取重定向 URL，故应谨慎使用 <code>301</code> 代码。因为若在 <code>server</code> 端进行 URL 更新后，本地是无法感知更新的，本地仍将重定向至之前的 URL。</ol><li><p><code>302</code> 表示临时重定向。即每次请求都会请求 <code>server</code> 来得到重定向的目标地址。只有指定了 <code>Cache-Control</code> 或 <code>Expires</code> 时，该重定向地址才是缓存的。</ul><h2 id="content-security-policy-内容安全策略"><a href="#content-security-policy-内容安全策略" class="header-anchor" aria-hidden="true">#</a> Content-Security-Policy/内容安全策略</h2><p>用于限制资源获取，报告（<code>report-uri</code> 指令）资源获取越权（<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" rel="noopener noreferrer" target="_blank">source<outboundlink></a>）。如，限制 HTML 中外部资源的加载（执行）。<p>API:<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy__by_cnvoid" rel="noopener noreferrer" target="_blank">source<outboundlink></a><p>注：<code>connect-src</code>（<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/connect-src" rel="noopener noreferrer" target="_blank">source<outboundlink></a>）指令可以限制当前站的 <code>Ajax</code> 请求。<p>实现方法一（推荐）：<pre class="language-js" v-pre><code><span class="token comment">// server.js</span>
response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token string">'Content-Type'</span><span class="token punctuation">:</span> <span class="token string">'text/html;'</span>

  <span class="token comment">/**
   * 1. default-src 指定了所有资源的备用策略，即在形如 img-src 等策略未指定的时候被应用。
   * 2. 以下限制了只能通过 http 或 https 的方式来加载所有资源，那么嵌入式 JS 代码将被
   * 忽视执行。
   * 3. 值为 'default-src \'self\'' 时，将只限 `同域的资源（即本站）` 加载执行，那么
   * 所有非同域外部资源将被 `block`
   * 4. form 表单不受 'default-src \'self\'' 的限制。必须设置为
   * 'form-action: \'self\''
   */</span>
  <span class="token string">'Content-Security-Policy'</span><span class="token punctuation">:</span> <span class="token string">'default-src http: https:'</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>实现方法二：<pre class="language-html" v-pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Content-Security-Policy<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>default-src <span class="token punctuation">'</span>self<span class="token punctuation">'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
</code></pre><p>结果：<pre class="language-html" v-pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>
  <span class="token comment">&lt;!-- 以下外部 JS 脚本将被执行 --></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://example.com/data.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
  <span class="token comment">&lt;!-- 以下嵌入式代码将被忽略 --></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hello World !'</span><span class="token punctuation">)</span>
  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>
</code></pre></div></article><button data-v-e85d20b2 data-v-e85d20b2 class="floating-btn __position" style="display:none"><svg class="icon-rocket" data-v-e85d20b2 viewBox="0 0 512 512"><path d="M256 421.6c-18.1 0-33.2-6.8-42.9-10.9-5.4-2.3-11.3 1.8-10.9 7.6l3.5 51c.2 3.1 3.8 4.7 6.3 2.8l14.5-11c1.8-1.4 4.5-.9 5.7 1l20.5 32.1c1.5 2.4 5.1 2.4 6.6 0l20.5-32.1c1.2-1.9 3.9-2.4 5.7-1l14.5 11c2.5 1.9 6.1.3 6.3-2.8l3.5-51c.4-5.8-5.5-10-10.9-7.6-9.8 4.1-24.8 10.9-42.9 10.9z" data-v-e85d20b2></path><path d="M397.7 293.1l-48-49.1c0-158-93.2-228-93.2-228s-94.1 70-94.1 228l-48 49.1c-1.8 1.8-2.6 4.5-2.2 7.1L130.6 412c.9 5.7 7.1 8.5 11.8 5.4l67.1-45.4s20.7 20 47.1 20c26.4 0 46.1-20 46.1-20l67.1 45.4c4.6 3.1 10.8.3 11.8-5.4l18.5-111.9c.2-2.6-.6-5.2-2.4-7zM256.5 192c-17 0-30.7-14.3-30.7-32s13.8-32 30.7-32c17 0 30.7 14.3 30.7 32s-13.7 32-30.7 32z" data-v-e85d20b2></path></svg></button></main><footer class="blog-footer sf__main__layout grid col grid-jc-center" data-v-1044ad0a data-v-cac63c14><div class="footer-info" data-v-1044ad0a>Copyright © 2018 <a href="https://github.com/lbwa" class="author" rel="noopener" target="_blank" data-v-1044ad0a>Bowen</a></div></footer><section class="loading-wrapper grid col grid-center grid-jc-center" data-v-cac63c14 style="display:none"><div class="loading"><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div></div><a class="loading-tips">Loading</a></section></section></div></div><script type="text/javascript">window.__NUXT__={layout:"blog",data:[{menu:[{errno:0,to:"writings/dom-location",title:"获取 Element 在 document 中的位置信息",author:"Bowen",date:"2018 SEP 01",tags:["前端开发","CSS"]},{errno:0,to:"writings/spa-and-mpa",title:"SPA 与 MPA 的比较与优化",author:"Bowen",date:"2018 AUG 04",tags:["前端开发","SPA","MPA","skeleton"]},{errno:0,to:"writings/async-function-in-js",title:"Event loops 中的 AsyncFunction",author:"Bowen",date:"2018 JUL 26",tags:["JavaScript","async","事件循环"]},{errno:0,to:"writings/pwa-fundamentals",title:"PWA 基础",author:"Bowen",date:"2018 JUL 07",tags:["前端开发","PWA"]},{errno:0,to:"writings/js-design-pattern",title:"JS 设计模式",author:"Bowen",date:"2018 JUN 12",tags:["前端开发","设计模式"]},{errno:0,to:"writings/http-request",title:"HTTP 协议请求首部",author:"Bowen",date:"2018 JUN 08",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-response",title:"HTTP 协议响应首部",author:"Bowen",date:"2018 JUN 07",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-protocol",title:"HTTP 协议",author:"Bowen",date:"2018 JUN 06",tags:["前端开发","网络请求"]},{errno:0,to:"writings/execution-context",title:"JS 执行上下文",author:"Bowen",date:"2018 MAY 07",tags:["前端开发","JavaScript","执行上下文"]},{errno:0,to:"writings/vue-lifecycle-and-slots",title:"对 Vue 插槽和生命周期的一点思考",author:"Bowen",date:"2018 APR 24",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/learning-vue-unit-test",title:"总结如何进行单元测试",author:"Bowen",date:"2018 APR 21",tags:["前端开发","Vue.js","应用测试"]},{errno:0,to:"writings/cross-domain-solution",title:"客户端跨域解决方案",author:"Bowen",date:"2018 APR 19",tags:["前端开发","网络请求"]},{errno:0,to:"writings/css-bfc",title:"探究 BFC 以及闭合浮动原理",author:"Bowen",date:"2018 MAR 29",tags:["前端开发","CSS"]},{errno:0,to:"writings/vue.js-reusability-and-composition",title:"学习 Vue.js 可复用性和组合",author:"Bowen",date:"2018 MAR 12",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/event-loop",title:"解析 event loops",author:"Bowen",date:"2018 MAR 08",tags:["前端开发","JavaScript","事件循环"]},{errno:0,to:"writings/learning-vuex",title:"学习 vuex 基础",author:"Bowen",date:"2018 MAR 06",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/compare-commonjs-with-esm",title:"比较 CommonJS 与 ES6 Module 语法",author:"Bowen",date:"2018 FEB 27",tags:["前端开发","JavaScript","模块"]},{errno:0,to:"writings/learning-vuejs-essentials",title:"学习 Vue.js 基础",author:"Bowen",date:"2018 FEB 24",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/keyword-this",title:"理解 this 的指向",author:"Bowen",date:"2018 FEB 06",tags:["前端开发","JavaScript"]}]},{title:"HTTP 协议响应首部",date:"2018 JUN 07",author:"Bowen",tags:["前端开发","网络请求"],content:'<p><code>HTTP</code> 响应首部即 <code>Response Headers</code>。它将与 <code>HTTP</code> 请求首部内容协商（<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation" target="_blank" rel="noopener noreferrer">source<OutboundLink/></a>），再根据 <code>server</code> 端的内部实现并依托 <code>HTTP</code> 响应首部来返回实际的协商结果。故返回的值可能不匹配 <code>HTTP</code> 请求头的值。</p>\n<h2 id="access-control-allow-origin"><a class="header-anchor" href="#access-control-allow-origin" aria-hidden="true">#</a> Access-Control-Allow-Origin</h2>\n<ul>\n<li>\n<p>常用于 HTTP 请求跨域解决方案之一 —— <code>CORS</code> 。表示指定了该响应资源只允许被给定的 <code>Origin</code> 共享。该值设置为 <code>*</code> 时，表示允许所有源都具有访问该资源的权限（<a href="https://fetch.spec.whatwg.org/#http-access-control-allow-origin" target="_blank" rel="noopener noreferrer">source<OutboundLink/></a>）。</p>\n</li>\n<li>\n<p>该属性只能指定一个 <em><strong>唯一值</strong></em>，不接受多个值。</p>\n<ul>\n<li>若有多个源需要通过 CORS 跨域，那么可配置一个模块。该模块在 <code>server</code> 端设置该头部前配置筛选出 URL 是否为白名单内源，若是白名单内源，那么就配置头部 <code>Access-Control-Allow-Origin</code>，否则不配置该头部。</li>\n</ul>\n</li>\n</ul>\n<p>详见我的另一篇博文👉<a href="/blog/writings/cross-domain-solution/">客户端跨域解决方案</a></p>\n<h2 id="access-control-allow-headers"><a class="header-anchor" href="#access-control-allow-headers" aria-hidden="true">#</a> Access-Control-Allow-Headers</h2>\n<ul>\n<li>常用于标记超出 <code>CORS</code> 限定配置的 <code>request headers</code> 是否合法。表示指定在 <code>CORS</code> 请求中除限定配置外额外被允许的请求头（<a href="https://fetch.spec.whatwg.org/#http-access-control-allow-headers" target="_blank" rel="noopener noreferrer">source<OutboundLink/></a>）。</li>\n</ul>\n<h3 id="cors-请求限制"><a class="header-anchor" href="#cors-请求限制" aria-hidden="true">#</a> CORS 请求限制</h3>\n<ul>\n<li>\n<p>默认允许的 <code>CORS</code> 请求方法（<a href="https://fetch.spec.whatwg.org/#methods" target="_blank" rel="noopener noreferrer">source<OutboundLink/></a>）</p>\n<ul>\n<li>只允许 <code>GET</code>、<code>POST</code>、<code>HEAD</code> 方法。使用其他请求方法都需要经过 <code>CORS</code> 预请求。</li>\n</ul>\n</li>\n<li>\n<p>默认允许的 <code>CORS</code> 请求头（<a href="https://fetch.spec.whatwg.org/#cors-safelisted-request-header" target="_blank" rel="noopener noreferrer">source<OutboundLink/></a>）</p>\n<ul>\n<li><code>Accept</code></li>\n<li><code>Accept-Language</code></li>\n<li><code>Content-Language</code></li>\n<li><code>Content-Type</code> 中仅包含 <code>text/plain</code>、<code>multipart/form-data</code>、<code>application/x-www-form-urlencoded</code> 三种 <code>MIME</code> 类型值。</li>\n</ul>\n</li>\n<li>\n<p>其他限制</p>\n<ol>\n<li>\n<p><code>XMLHttpRequestUpload</code> 对象均没有注册任何事件监听程序。</p>\n</li>\n<li>\n<p>请求中没有使用 <code>ReadableStream</code> 对象。</p>\n</li>\n</ol>\n</li>\n</ul>\n<p><em><strong>总结</strong></em>:使用其他超出以上 <code>CORS</code> 请求所限定的配置都将需要经过 <code>CORS</code> 预请求检测 <code>CORS</code> 请求头的合法性。</p>\n<h3 id="cors-预请求"><a class="header-anchor" href="#cors-预请求" aria-hidden="true">#</a> CORS 预请求</h3>\n<p><code>CORS</code> 预请求的 <code>Request Method</code> 值为 <code>OPTIONS</code>。</p>\n<p>在浏览器即将发起超过 1 中限定配置的 <code>CORS</code> 请求时，将触发浏览器 <code>CORS</code> 预请求策略。该策略用于在发起正式的 <code>CORS</code> 请求之前确认 <code>CORS</code> 请求中超出限定配置的部分是否合法。仅当超出默认配置的默认配置被 <code>server</code> 端认可时，浏览器才会真正 <em><strong>解析</strong></em> CORS 正式请求返回的数据。</p>\n<ul>\n<li>不论 <code>CORS</code> 预请求是否合法，浏览器均会发出正式的 <code>CORS</code> 请求，合法性检测的意义在于浏览器 <em><strong>是否解析</strong></em> 返回的数据（该原理类似浏览器对跨域资源的解析策略（<a href="/blog/writings/cross-domain-solution/#%E5%AF%B9%E8%B7%A8%E5%9F%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%90%86%E8%A7%A3">extension</a>））。</li>\n</ul>\n<pre v-pre class="language-js"><code><span class="token comment">// server1.js</span>\n<span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'http\'</span><span class="token punctuation">)</span>\n<span class="token keyword">const</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'fs\'</span><span class="token punctuation">)</span>\n\nhttp<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'request.url :\'</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>url<span class="token punctuation">)</span>\n\n  <span class="token keyword">const</span> html <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">\'cross-domain-solution.html\'</span><span class="token punctuation">,</span> <span class="token string">\'utf8\'</span><span class="token punctuation">)</span>\n  response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    <span class="token string">\'Content-type\'</span><span class="token punctuation">:</span> <span class="token string">\'text/html\'</span><span class="token punctuation">,</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8888</span><span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">\'server listening at port 8888\'</span><span class="token punctuation">)</span>\n</code></pre>\n<pre v-pre class="language-js"><code><span class="token comment">// client.html</span>\n<span class="token comment">// client 跨域请求 server2 数据</span>\n<span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">\'http://127.0.0.1:8800\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  method<span class="token punctuation">:</span> <span class="token string">\'POST\'</span><span class="token punctuation">,</span>\n  headers<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 请求头类型不在 CORS 请求限定配置内，触发 CORS 预请求检测该请求头合法性</span>\n    <span class="token string">\'X-Test-Cors\'</span><span class="token punctuation">:</span> <span class="token string">\'test custom headers in CORS preflight\'</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=></span> <span class="token punctuation">{</span>\n    target<span class="token punctuation">.</span>innerText <span class="token operator">=</span> <span class="token string">\'check your network tag in console drawer\'</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span><span class="token punctuation">)</span>\n<span class="token comment">// 不论 CORS 预请求是否合法，client 均会发起 CORS 正式请求。</span>\n</code></pre>\n<p>当被请求的 <code>server2</code> 没有配置 <code>Access-Control-Allow-Headers</code> 或目标值不在该值中时，<code>client</code> 将在预请求响应后报错，但仍发起正式 <code>CORS</code> 请求，但拒绝解析正式 <code>CORS</code> 请求返回的数据。</p>\n<pre v-pre class="language-js"><code><span class="token comment">// server2.js</span>\n<span class="token keyword">const</span> http <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'http\'</span><span class="token punctuation">)</span>\n\nhttp<span class="token punctuation">.</span><span class="token function">createServer</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>request<span class="token punctuation">,</span> response<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'request.url :\'</span><span class="token punctuation">,</span> request<span class="token punctuation">.</span>url<span class="token punctuation">)</span>\n\n  response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 允许跨域请求</span>\n    <span class="token string">\'Access-Control-Allow-Origin\'</span><span class="token punctuation">:</span> <span class="token string">\'*\'</span><span class="token punctuation">,</span>\n    <span class="token comment">// 允许除限定配置外额外的合法请求头的值</span>\n    <span class="token string">\'Access-Control-Allow-Headers\'</span><span class="token punctuation">:</span> <span class="token string">\'X-Test-Cors\'</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">\'server response\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span><span class="token number">8800</span><span class="token punctuation">)</span>\n\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'server listening at port 8800\'</span><span class="token punctuation">)</span>\n</code></pre>\n<h2 id="access-control-allow-methods"><a class="header-anchor" href="#access-control-allow-methods" aria-hidden="true">#</a> Access-Control-Allow-Methods</h2>\n<p>该响应头的使用方法与原理于 <code>Access-Control-Allow-Headers</code> 相似。</p>\n<ul>\n<li>\n<p>常用于标记超出 <code>CORS</code> 限定配置情况下的 <code>Request Method</code> 是否合法（<a href="https://fetch.spec.whatwg.org/#http-access-control-allow-methods" target="_blank" rel="noopener noreferrer">source<OutboundLink/></a>）。</p>\n<pre v-pre class="language-js"><code>response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 允许跨域请求</span>\n  <span class="token string">\'Access-Control-Allow-Origin\'</span><span class="token punctuation">:</span> <span class="token string">\'*\'</span><span class="token punctuation">,</span>\n  <span class="token comment">// 允许除限定配置外额外的合法 `Request Method` 的值</span>\n  <span class="token string">\'Access-Control-Allow-Methods\'</span><span class="token punctuation">:</span> <span class="token string">\'PUT, DELETE\'</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n</li>\n</ul>\n<h2 id="access-control-max-age"><a class="header-anchor" href="#access-control-max-age" aria-hidden="true">#</a> Access-Control-Max-Age</h2>\n<ul>\n<li>表示当次预请求检测 <code>Access-Control-Allow-Methods</code> 和 <code>Access-Control-Allow-Headers</code> 的缓存有效期，即在有效期内，即使有超出限定配置的 <code>CORS</code> 请求也不需要再进行 <code>CORS</code> 预请求来检测其合法性（<a href="https://fetch.spec.whatwg.org/#http-access-control-max-age" target="_blank" rel="noopener noreferrer">source<OutboundLink/></a>）。</li>\n</ul>\n<h2 id="cache-control-缓存头"><a class="header-anchor" href="#cache-control-缓存头" aria-hidden="true">#</a> Cache-Control/缓存头</h2>\n<ul>\n<li>用于指定在 <code>request</code> 或 <code>response</code> 链中缓存当前请求数据，该指令是单向指令（<a href="https://tools.ietf.org/html/rfc7234#section-5.2" target="_blank" rel="noopener noreferrer">source<OutboundLink/></a>）。</li>\n</ul>\n<h3 id="可缓存性"><a class="header-anchor" href="#可缓存性" aria-hidden="true">#</a> 可缓存性</h3>\n<ol>\n<li>\n<p><code>public</code> 表示响应链中所有缓存都可存储当前响应数据，如发送客户端，中转服务器等。</p>\n</li>\n<li>\n<p><code>private</code> 表示当前响应数据只能单个用户缓存，即中转服务器不能缓存该响应数据。</p>\n</li>\n<li>\n<p><code>no-cache</code> 表示在使用本地缓存之前，必须首先请求原 <code>server</code> 端验证当前缓存的数据是否可用。</p>\n</li>\n</ol>\n<p><img src="https://assets.set.sh/2018/180607-http-response/cache-control.svg" alt="cache-control"></p>\n<h3 id="缓存有效期"><a class="header-anchor" href="#缓存有效期" aria-hidden="true">#</a> 缓存有效期</h3>\n<ol>\n<li>\n<p><code>max-age=&lt;seconds&gt;</code> 于 <code>server</code> 端设置响应数据在 <code>client</code> 端的缓存有效期，始于请求时间点。在有效期内，<code>client</code> 将读取缓存数据而不是请求数据。即使在 <code>server</code> 端该数据已经被更新，也不会改变 <code>client</code> 在有效期内读取缓存的策略，因为 <code>client</code> 在有效期内当前请求 URL 未改变的情况下就不会去请求该数据，所以 <code>client</code> 并不知道该数据已经在 <code>server</code> 端被更新了。</p>\n<ul>\n<li><em><strong>拓展应用</strong></em>：根据静态资源的 <em><strong>内容</strong></em> 打包生成的 <code>contentHash</code> 码来命名常缓存文件。只要 <code>server</code> 端该静态资源文件被更新，那么该资源的 <code>contentHash</code> 一定变化，即请求 URL 改变，那么 <code>client</code> 知晓当前静态资源请求 URL 改变后，即使在缓存有效期内，也会重新请求该资源。这样做的目的是最大限度使用缓存文件，且规避在有效期内即使 <code>server</code> 端数据被更新但仍使用缓存文件的问题。</li>\n</ul>\n</li>\n</ol>\n<pre v-pre class="language-js"><code>response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token string">\'Content-type\'</span><span class="token punctuation">:</span> <span class="token string">\'text/javascript\'</span><span class="token punctuation">,</span>\n  <span class="token string">\'Cache-Control\'</span><span class="token punctuation">:</span> <span class="token string">\'max-age=200, public\'</span> <span class="token comment">// 以秒为单位</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\nresponse<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">\'console.log("script loaded")\'</span><span class="token punctuation">)</span>\n</code></pre>\n<ol start="2">\n<li>\n<p><code>s-maxage=&lt;seconds&gt;</code> 覆盖 <code>max-age=&lt;seconds&gt;</code>，只在共享缓存中（如中转服务器）有效。</p>\n</li>\n<li>\n<p><code>max-stale[=&lt;seconds&gt;]</code> 表示即使缓存过期，仍可接受一个（在指定时间内）已过期资源，只在发起端设置才有效，在 <code>server</code> 端响应数据中设置是无效的。</p>\n</li>\n</ol>\n<h3 id="验证"><a class="header-anchor" href="#验证" aria-hidden="true">#</a> 验证</h3>\n<ol>\n<li>\n<p><code>must-revalidate</code> 在使用之前的旧资源时，必须请求原 <code>server</code> 端来验证当前旧资源是否已经过期。</p>\n</li>\n<li>\n<p><code>proxy-revalidate</code> 与 <code>must-revalidate</code> 作用相同，但仅适用于共享缓存，如中转服务器。</p>\n</li>\n</ol>\n<h3 id="其他"><a class="header-anchor" href="#其他" aria-hidden="true">#</a> 其他</h3>\n<ol>\n<li>\n<p><code>no-store</code> 表示所有的链中节点的缓存都不可存储当前响应数据。</p>\n</li>\n<li>\n<p><code>no-transform</code> 表示不能对当前响应数据进行转换或变化。</p>\n</li>\n</ol>\n<p><em><strong>注</strong></em>：以上所有指令都不具有强制力，仅表示一种约束期望。</p>\n<h2 id="last-modified-缓存验证"><a class="header-anchor" href="#last-modified-缓存验证" aria-hidden="true">#</a> Last-Modified/缓存验证</h2>\n<ul>\n<li>\n<p>用于 <code>server</code> 端标记响应数据上次修改的时间，据此来判断本地缓存是否需要更新。</p>\n<ul>\n<li>\n<p>一般在使用对应的数据缓存之前，<code>client</code> 首先通过配合 <code>If-Modified-Since</code> 或 <code>If-Unmodified-Since</code> <em><strong>请求头</strong></em> 来向 <code>server</code> 端传输之前的 <code>Last-Modified</code> 值。<code>server</code> 端据此可以来判断 <code>client</code> 端与 <code>server</code> 端的数据是否是同步的，即验证本地缓存是否需要更新。</p>\n<ul>\n<li>注：在 <code>Cache-Control</code> 配置了 <code>no-store</code> 时，<code>client</code> 将不会携带 <code>If-Modified-Since</code> 或 <code>If-Unmodified-Since</code> 请求头。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id="etag-缓存验证"><a class="header-anchor" href="#etag-缓存验证" aria-hidden="true">#</a> Etag/缓存验证</h2>\n<p>用于通过数据签名（如根据内容的 <code>contentHash</code> 计算）来 <em><strong>严格验证</strong></em> 数据是否需要更新。</p>\n<ul>\n<li><code>client</code> 在下次使用该缓存之前，一般配合 <code>If-Match</code> 或 <code>If-Non-Match</code> <em><strong>请求头</strong></em> 来向 <code>server</code> 传输本地缓存的数据签名。<code>server</code> 端据此判断数据签名是否一致，即<code>server</code> 是应该向 <code>client</code> 返回新的数据，还是可以直接使用 <code>client</code> 端本地缓存。</li>\n</ul>\n<pre v-pre class="language-js"><code>response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token string">\'Content-type\'</span><span class="token punctuation">:</span> <span class="token string">\'text/javascript\'</span><span class="token punctuation">,</span>\n  <span class="token string">\'Cache-Control\'</span><span class="token punctuation">:</span> <span class="token string">\'max-age=20000000, no-cache\'</span><span class="token punctuation">,</span>\n  <span class="token string">\'Last-Modified\'</span><span class="token punctuation">:</span> <span class="token string">\'18/06/06 00:00:00\'</span><span class="token punctuation">,</span> <span class="token comment">// 上次修改日期</span>\n  <span class="token string">\'Etag\'</span><span class="token punctuation">:</span> <span class="token string">\'777\'</span> <span class="token comment">// 指定数字签名</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 读取请求头</span>\n<span class="token keyword">const</span> etag <span class="token operator">=</span> request<span class="token punctuation">.</span>headers<span class="token punctuation">[</span><span class="token string">\'If-None-Match\'</span><span class="token punctuation">]</span>\n<span class="token keyword">if</span> <span class="token punctuation">(</span>etag <span class="token operator">&amp;&amp;</span> etag <span class="token operator">===</span> <span class="token string">\'777\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">304</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    <span class="token string">\'Content-type\'</span><span class="token punctuation">:</span> <span class="token string">\'text/javascript\'</span><span class="token punctuation">,</span>\n    <span class="token string">\'Cache-Control\'</span><span class="token punctuation">:</span> <span class="token string">\'max-age=20000000, no-cache\'</span><span class="token punctuation">,</span>\n    <span class="token string">\'Last-Modified\'</span><span class="token punctuation">:</span> <span class="token string">\'18/06/06 00:00:00\'</span><span class="token punctuation">,</span>\n    <span class="token string">\'Etag\'</span><span class="token punctuation">:</span> <span class="token string">\'777\'</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 即使此处返回内容，client 也会忽略该内容而使用本地缓存。</span>\n<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n  response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    <span class="token string">\'Content-type\'</span><span class="token punctuation">:</span> <span class="token string">\'text/javascript\'</span><span class="token punctuation">,</span>\n    <span class="token comment">/**\n     * 1. 配置 no-cache 用于在每次使用本地缓存之前，强制向 server 端验证是否可使\n     * 用本地缓存\n     */</span>\n    <span class="token string">\'Cache-Control\'</span><span class="token punctuation">:</span> <span class="token string">\'max-age=20000000, no-cache\'</span><span class="token punctuation">,</span>\n    <span class="token string">\'Last-Modified\'</span><span class="token punctuation">:</span> <span class="token string">\'18/06/06 00:00:00\'</span><span class="token punctuation">,</span>\n    <span class="token string">\'Etag\'</span><span class="token punctuation">:</span> <span class="token string">\'777\'</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">\'console.log("script updated")\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\nresponse<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span><span class="token string">\'console.log("script loaded")\'</span><span class="token punctuation">)</span>\n</code></pre>\n<ul>\n<li>注：在 <code>Cache-Control</code> 配置了 <code>no-store</code> 时，<code>client</code> 将不会携带 <code>If-Match</code> 或 <code>If-Non-Match</code> 请求头。</li>\n</ul>\n<h2 id="set-cookie"><a class="header-anchor" href="#set-cookie" aria-hidden="true">#</a> Set-Cookie</h2>\n<p>用于 <code>server</code> 端通过 <code>Set-Cookie</code> 设置 <code>client</code> 端的 <code>HTTP Cookie</code>。</p>\n<h3 id="特点"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h3>\n<p><code>Set-Cookie</code> 响应首部不同于 <code>Cookie</code> 请求首部，它 <em><strong>不具有唯一性</strong></em>。在 <code>Node.js</code> 中它通过一个数组来设置多个<code>Set-Cookie</code> 响应头。</p>\n<pre v-pre class="language-js"><code>response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token string">\'Content-type\'</span><span class="token punctuation">:</span> <span class="token string">\'text/html\'</span><span class="token punctuation">,</span>\n  <span class="token string">\'Set-Cookie\'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">\'username=John_Wick\'</span><span class="token punctuation">,</span> <span class="token string">\'gender=male\'</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>（以下 <code>Cookie</code> 都是指 <code>HTTP Cookie</code>，除非特别指明是 <code>Cookie</code> 请求首部（<a href="/blog/writings/http-request/#cookie">extension</a>）。）</p>\n<pre v-pre class="language-markup"><code># 创建 client 端 Cookie\nSet-Cookie: <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cookie-name</span><span class="token punctuation">></span></span>=<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cookie-value</span><span class="token punctuation">></span></span>\n</code></pre>\n<p><code>HTTP Cookie</code> （<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies" target="_blank" rel="noopener noreferrer">extension<OutboundLink/></a>）通常用于:</p>\n<ol>\n<li>\n<p>会话管理，如登录状态，购物车等需要记录的信息。</p>\n</li>\n<li>\n<p>用户个性化设置，如用户自定义设置等。</p>\n</li>\n<li>\n<p>浏览器行为追踪，如跟踪分析用户行为等。</p>\n</li>\n</ol>\n<p>注：不推荐再使用 <code>Cookie</code> 作用为本地存储介质，推荐使用 <code>localStorage</code>、<code>sessionStorage</code>、<code>IndexedDB</code> 代替。 因为每次请求时，在没有禁用 <code>Cookie</code> 的情况下都会携带 <code>Cookie</code> 请求首部传输至 <code>server</code>。如果使用了，将会带来额外的性能开销，尤其是在移动端下。</p>\n<h3 id="cookie-属性"><a class="header-anchor" href="#cookie-属性" aria-hidden="true">#</a> Cookie 属性</h3>\n<ol>\n<li>\n<p><code>max-age</code>（时长）和 <code>expires</code>（时间点）设置过期时间。</p>\n<ul>\n<li>\n<p>会话期 <code>Cookie</code>，若设置 <code>Cookie</code> 时未指定过期时间，那么它在浏览器关闭后就会被自动删除。</p>\n</li>\n<li>\n<p>持久性 <code>Cookie</code>，在设置 <code>Cookie</code> 时指定了过期时间后，<code>Cookie</code> 将保存至特定的过期时间，除非手动删除。</p>\n</li>\n</ul>\n</li>\n</ol>\n<pre v-pre class="language-js"><code>response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token string">\'Content-type\'</span><span class="token punctuation">:</span> <span class="token string">\'text/html\'</span><span class="token punctuation">,</span>\n  <span class="token comment">// 使用逗号分隔不同的 Cookie 键值对，分号连接 Cookie 属性</span>\n  <span class="token string">\'Set-Cookie\'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">\'username=John_Wick\'</span><span class="token punctuation">,</span> <span class="token string">\'gender=male; Max-Age=5\'</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<ol start="2">\n<li>\n<p><code>Secure</code> 只在 <code>HTTPS</code> 协议下发送。</p>\n</li>\n<li>\n<p>配置 <code>HttpOnly</code> 可阻止通过 <code>document.cookie</code> 访问指定 <code>Cookie</code>。</p>\n</li>\n<li>\n<p><code>domain</code> 属性，用于在访问一级域名设置指定 <code>Cookie</code> 时（前提），授权给所有子级域名指定 <code>Cookie</code> 使用权。</p>\n</li>\n</ol>\n<pre v-pre class="language-js"><code>response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token string">\'Content-type\'</span><span class="token punctuation">:</span> <span class="token string">\'text/html\'</span><span class="token punctuation">,</span>\n  <span class="token string">\'Set-Cookie\'</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">\'username=John_Wick; domain=github.com\'</span><span class="token punctuation">,</span> <span class="token string">\'gender=male\'</span><span class="token punctuation">]</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token comment">/**\n * 1. domain=github.com 表示所有 github.com 的子域名都被授权访问\n * github.com 下的 cookie\n * 2. 必须首先访问一级域名才能设置（被共享的）Cookie\n * 3. 只有设置了 domain 属性的 Cookie 才被共享\n */</span>\n</code></pre>\n<p><em><strong>注</strong></em>：<code>Cookie</code> 属性是作用于个体，而非全体。</p>\n<h2 id="connection-长连接"><a class="header-anchor" href="#connection-长连接" aria-hidden="true">#</a> Connection/长连接</h2>\n<ul>\n<li>\n<p>值为 <code>keep-alive</code> 或 <code>close</code>。</p>\n</li>\n<li>\n<p>用于构建 <code>HTTP</code> 长连接，复用同一客户端下的 <code>TCP</code> 通道。即用于告知 <code>client</code> 端在完成本次响应后，<code>server</code> 端是否会关闭当前 <code>TCP</code> 通道。即返回 <code>Connection</code> 请求头的执行结果，并设置为 <code>Connection</code> 响应头。</p>\n</li>\n<li>\n<p>在 <code>server</code> 端构建 <code>HTTP</code> 长连接之后，可设置长连接的 <em><strong>有效时间</strong></em>，即在一定时间内没有新的请求时，关闭当前 <code>HTTP</code> 长连接。</p>\n</li>\n</ul>\n<p>更多信息，查看本文 <code>HTTP 请求首部</code><a href="/blog/writings/http-request/#connection-%E9%95%BF%E8%BF%9E%E6%8E%A5">章节 - Connection</a>。</p>\n<h2 id="content-type-内容协商"><a class="header-anchor" href="#content-type-内容协商" aria-hidden="true">#</a> Content-Type/内容协商</h2>\n<p>与 <code>Accept</code> 请求首部对应。</p>\n<p>用于标注 <code>server</code> 端在与请求首部内容协商（<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation" target="_blank" rel="noopener noreferrer">source<OutboundLink/></a>）后，实际 <code>server</code> 端返回内容的 <code>MIME</code> 类型。</p>\n<p><code>MIME</code> 类型对应的文件拓展名：<a href="http://tool.oschina.net/commons" target="_blank" rel="noopener noreferrer">source<OutboundLink/></a></p>\n<h2 id="content-encoding-内容压缩"><a class="header-anchor" href="#content-encoding-内容压缩" aria-hidden="true">#</a> Content-Encoding/内容压缩</h2>\n<p>与 <code>Accept-Encoding</code> 请求首部对应。</p>\n<p>用于标注 <code>server</code> 端在与请求首部内容协商后，实际 <code>server</code> 端返回内容的内容编码类型（即实际使用的压缩算法）。</p>\n<h3 id="值"><a class="header-anchor" href="#值" aria-hidden="true">#</a> 值</h3>\n<p><code>gzip</code> 表示采用 <code>Lempel-Ziv coding (LZ77)</code> 压缩算法，以及32位CRC校验的编码方式。</p>\n<p><code>deflate</code> 采用 <code>zlib</code> 结构和 <code>deflate</code> 压缩算法。</p>\n<p><code>br</code> 表示采用 <code>Brotli</code> 算法的编码方式。</p>\n<p><code>;q=</code> 表示 <em><strong>权重</strong></em>，即编码方式的优先顺序。</p>\n<p><code>*</code> 匹配任意未在请求首部中列出的编码方式。</p>\n<p>以下为不常使用的编码方式：</p>\n<p><code>compress</code> 采用 <code>Lempel-Ziv-Welch (LZW)</code> 压缩算法，已被大部分浏览器弃用。</p>\n<p><code>identity</code> 用于指代自身，如未经过压缩或修改。</p>\n<pre v-pre class="language-js"><code><span class="token comment">// Node.js 编码数据内容的模块</span>\n<span class="token keyword">const</span> zlib <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'zlib\'</span><span class="token punctuation">)</span>\n\n<span class="token comment">// ...</span>\n\nresponse<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token string">\'Content-Type\'</span><span class="token punctuation">:</span> <span class="token string">\'text/html\'</span><span class="token punctuation">,</span>\n  <span class="token string">\'Content-Encoding\'</span><span class="token punctuation">:</span> <span class="token string">\'gzip\'</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\nresponse<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>zlib<span class="token punctuation">.</span><span class="token function">gzipSync</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span><span class="token punctuation">)</span>\n</code></pre>\n<p><img src="https://assets.set.sh/2018/180607-http-response/content-encoding.png" alt="content-encoding"></p>\n<p>上图中，<code>420B</code> 则是表示传输的数据内容经过 <code>server</code> 的编码后，传输时的大小。它的大小与内容的实际编码方式有关，即 <code>Content-Encoding</code> 响应首部。<code>476B</code> 为数据内容在 <code>client</code> 端解压后的大小，除非内容变化，否则该值不变。</p>\n<h2 id="content-language"><a class="header-anchor" href="#content-language" aria-hidden="true">#</a> Content-Language</h2>\n<p>与 <code>Accept-Language</code> 请求首部对应。</p>\n<p>用于标注 <code>server</code> 端在与请求首部内容协商后，实际 <code>server</code> 端返回的数据内容的自然语言类型。</p>\n<h2 id="x-content-type-options"><a class="header-anchor" href="#x-content-type-options" aria-hidden="true">#</a> X-Content-Type-Options</h2>\n<p>标注 <code>client</code> 一定要遵循 <code>Content-Type</code> 响应头中的 <code>MIME</code> 类型，不应推测（修改）返回数据 <code>MIME</code> 类型。</p>\n<ul>\n<li>早期 <code>IE</code> 会因错误的 <code>Content-Type</code> 或未声明该值而根据返回内容推测数据类型。此举极易导致文本代码被执行，那么 <code>client</code> 就可能被恶意注入。</li>\n</ul>\n<h2 id="location-重定向"><a class="header-anchor" href="#location-重定向" aria-hidden="true">#</a> Location/重定向</h2>\n<p>表示请求当前 URL 时，<code>server</code> 端向 <code>client</code> 端告知之前请求的数据资源转移后的 <code>URL</code>，<code>client</code> 端应该去重定向请求（<code>Redi</code>）这个转移后的 URL。其中，重定向由 <code>client</code> 自动完成完成，不需要人工干预。</p>\n<ul>\n<li><em><strong>注</strong></em>：必须向 <code>client</code> 端指定 <code>301</code> 或 <code>302</code> 重定向代码，否则浏览器不会自主进行重定向，此刻，将页面空白。</li>\n</ul>\n<pre v-pre class="language-js"><code><span class="token comment">// server.js</span>\n<span class="token keyword">const</span> data <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync</span><span class="token punctuation">(</span><span class="token string">\'data.html\'</span><span class="token punctuation">)</span>\n\n<span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">\'/\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 必须设置为 302（推荐）或 301 代码，否则客户端无法正常跳转</span>\n  response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">302</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    <span class="token string">\'Location\'</span><span class="token punctuation">:</span> <span class="token string">\'/new-url\'</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n  response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>html<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">if</span> <span class="token punctuation">(</span>request<span class="token punctuation">.</span>url <span class="token operator">===</span> <span class="token string">\'/new-url\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  response<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    <span class="token string">\'Content-Type\'</span><span class="token punctuation">:</span> <span class="token string">\'text/html\'</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n  response<span class="token punctuation">.</span><span class="token function">end</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p><code>301</code> 与 <code>302</code> 的区别：</p>\n<ul>\n<li>\n<p><code>301</code> 表示永久重定向。例如，在请求 <code>url-0</code> 并完成当次重定向 <code>url-1</code> 后，缓存当前 <code>url-1</code>。之后发起的所有 <code>url-0</code> 请求直接在 <code>client</code> <em><strong>本地读取缓存</strong></em> 读取重定向地址 <code>url-1</code> ，此时并不会先向 <code>server</code> 请求重定向的目标地址。</p>\n<ol>\n<li>\n<p>该存储的 <code>url-1</code> 会在缓存中尽可能长的存储。除非清除了 <code>client</code> 缓存。</p>\n</li>\n<li>\n<p>因为是从本地缓存读取重定向 URL，故应谨慎使用 <code>301</code> 代码。因为若在 <code>server</code> 端进行 URL 更新后，本地是无法感知更新的，本地仍将重定向至之前的 URL。</p>\n</li>\n</ol>\n</li>\n<li>\n<p><code>302</code> 表示临时重定向。即每次请求都会请求 <code>server</code> 来得到重定向的目标地址。只有指定了 <code>Cache-Control</code> 或 <code>Expires</code> 时，该重定向地址才是缓存的。</p>\n</li>\n</ul>\n<h2 id="content-security-policy-内容安全策略"><a class="header-anchor" href="#content-security-policy-内容安全策略" aria-hidden="true">#</a> Content-Security-Policy/内容安全策略</h2>\n<p>用于限制资源获取，报告（<code>report-uri</code> 指令）资源获取越权（<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP" target="_blank" rel="noopener noreferrer">source<OutboundLink/></a>）。如，限制 HTML 中外部资源的加载（执行）。</p>\n<p>API:<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy__by_cnvoid" target="_blank" rel="noopener noreferrer">source<OutboundLink/></a></p>\n<p>注：<code>connect-src</code>（<a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/connect-src" target="_blank" rel="noopener noreferrer">source<OutboundLink/></a>）指令可以限制当前站的 <code>Ajax</code> 请求。</p>\n<p>实现方法一（推荐）：</p>\n<pre v-pre class="language-js"><code><span class="token comment">// server.js</span>\nresponse<span class="token punctuation">.</span><span class="token function">writeHead</span><span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n  <span class="token string">\'Content-Type\'</span><span class="token punctuation">:</span> <span class="token string">\'text/html;\'</span>\n\n  <span class="token comment">/**\n   * 1. default-src 指定了所有资源的备用策略，即在形如 img-src 等策略未指定的时候被应用。\n   * 2. 以下限制了只能通过 http 或 https 的方式来加载所有资源，那么嵌入式 JS 代码将被\n   * 忽视执行。\n   * 3. 值为 \'default-src \\\'self\\\'\' 时，将只限 `同域的资源（即本站）` 加载执行，那么\n   * 所有非同域外部资源将被 `block`\n   * 4. form 表单不受 \'default-src \\\'self\\\'\' 的限制。必须设置为\n   * \'form-action: \\\'self\\\'\'\n   */</span>\n  <span class="token string">\'Content-Security-Policy\'</span><span class="token punctuation">:</span> <span class="token string">\'default-src http: https:\'</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>实现方法二：</p>\n<pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">http-equiv</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Content-Security-Policy<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>default-src <span class="token punctuation">\'</span>self<span class="token punctuation">\'</span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n</code></pre>\n<p>结果：</p>\n<pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>\n  <span class="token comment">&lt;!-- 以下外部 JS 脚本将被执行 --\x3e</span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>https://example.com/data.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n  <span class="token comment">&lt;!-- 以下嵌入式代码将被忽略 --\x3e</span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'Hello World !\'</span><span class="token punctuation">)</span>\n  </span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span>\n</code></pre>\n'}],error:null,serverRendered:!0}</script><script defer src="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js"></script><script defer src="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js"></script><script defer src="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js"></script><script defer src="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js"></script><script defer src="/_nuxt/vendor.13de21511613edf061b2.js"></script><script defer src="/_nuxt/app.5a4fa6b8fcf73db97515.js"></script>