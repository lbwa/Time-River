<!doctype html><html data-n-head="lang" data-n-head-ssr lang="zh"><meta data-n-head="true" content="IE=edge,chrome=1" http-equiv='"X-UA-Compatible'><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" name="viewport"><meta data-n-head="true" content="bowen blog, bowen 博客, vuejs, reactjs, ssr, 前端开发, 前端 , web开发, nodejs, github" name="keywords"><meta data-n-head="true" content="一个分享代码经历的地方" name="description" data-hid="description"><meta data-n-head="true" content="yes" name="apple-mobile-web-app-capable"><meta data-n-head="true" content="black" name="apple-mobile-web-app-status-bar-style"><meta data-n-head="true" content="yes" name="mobile-web-app-capable" data-hid="mobile-web-app-capable"><meta data-n-head="true" content="Bowen Blog" name="apple-mobile-web-app-title" data-hid="apple-mobile-web-app-title"><meta data-n-head="true" content="Bowen" name="author" data-hid="author"><meta data-n-head="true" content="#24292e" name="theme-color" data-hid="theme-color"><meta data-n-head="true" content="website" name="og:type" data-hid="og:type" property="og:type"><meta data-n-head="true" content="Bowen Blog" name="og:title" data-hid="og:title" property="og:title"><meta data-n-head="true" content="A place which is used to share programming experiences" name="og:description" data-hid="og:description" property="og:description"><title data-n-head="true">对 Vue 插槽和生命周期的一点思考 | Bowen Blog</title><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="/_nuxt/manifest.2108b1d4.json" rel="manifest" data-n-head="true"><link href="/_nuxt/icons/icon_64.e20A200w20w.png" rel="shortcut icon" data-n-head="true"><link href="/_nuxt/icons/icon_512.e20A200w20w.png" rel="apple-touch-icon" data-n-head="true" sizes="512x512"><link href="https://set.sh/blog/writings/vue-lifecycle-and-slots/" rel="alternate" data-n-head="true" hreflang="zh"><link href="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js" rel="preload" as="script"><link href="/_nuxt/vendor.13de21511613edf061b2.js" rel="preload" as="script"><link href="/_nuxt/app.5a4fa6b8fcf73db97515.js" rel="preload" as="script"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="preload" as="style"><link href="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js" rel="preload" as="script"><link href="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/tags/_id/index.edb9dbabb1b9c2ef81f2.js" rel="prefetch"><link href="/_nuxt/pages/index.1d0ac68e309be0e86168.js" rel="prefetch"><link href="/_nuxt/pages/blog/tags/index.2659d358b69abdfd34bf.js" rel="prefetch"><link href="/_nuxt/pages/blog/projects/index.3ff8e031c3cb4f25eaed.js" rel="prefetch"><link href="/_nuxt/pages/blog/writings/index.b016af22016e152b7231.js" rel="prefetch"><link href="/_nuxt/layouts/home.dd55e95df1c2109ebde6.js" rel="prefetch"><link href="/_nuxt/layouts/default.89ffa224d3d7769e4fbb.js" rel="prefetch"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="stylesheet"><body data-n-head=""><div id="__nuxt" data-server-rendered="true"><div class="nuxt-progress" style="width:0%;height:2px;background-color:#3eaf7c;opacity:0"></div><div id="__layout"><section class="blog sf__parent__clearfix" data-v-cac63c14><header class="header __position components-animation" data-v-13c46026 data-v-cac63c14><nav class="mobile-navigator" data-v-13c46026 data-v-d4cae7a6><label class="label-line" data-v-d4cae7a6><span class="__position label-line line-top" data-v-d4cae7a6><span class="__position line-crust line-crust-top" data-v-d4cae7a6></span></span><span class="__position label-line line-bottom" data-v-d4cae7a6><span class="__position line-crust line-crust-bottom" data-v-d4cae7a6></span></span></label></nav><nav class="navigator __position grid" data-v-13c46026 role="navigation"><a class="navigator-link hover-animation grid-cell" href="/" data-v-13c46026>HOME</a><a class="navigator-link hover-animation grid-cell" href="/blog/writings/" data-v-13c46026>WRITINGS</a><a class="navigator-link hover-animation grid-cell" href="/blog/projects/" data-v-13c46026>PROJECTS</a><a class="navigator-link hover-animation grid-cell" href="/blog/tags/" data-v-13c46026>TAGS</a><a class="navigator-link hover-animation grid-cell" href="https://github.com/lbwa" data-v-13c46026 rel="noopener" target="_blank">GITHUB</a></nav><div class="background-helper __position" data-v-13c46026></div></header><main class="articles-container wrapper sf__reference__layout" data-v-cac63c14 role="main"><article class="articles-main"><div class="article-header"><h1 class="article-title">对 Vue 插槽和生命周期的一点思考</h1><span class="article-author">Bowen</span><span class="article-date">2018 APR 24</span><div class="article-tags"><a class="article-tag" href="/blog/tags/前端开发">前端开发</a><a class="article-tag" href="/blog/tags/vue.js">Vue.js</a></div></div><div class="article-content"><h2 id="vue-js-生命周期钩子"><a class="header-anchor" href="#vue-js-生命周期钩子" aria-hidden="true">#</a> Vue.js 生命周期钩子</h2><p>在 Vue 组件的生命周期内，<code>mounted</code> 之前（包括自身）的所有钩子都只会调用<strong>唯一的一次</strong>。<p>在服务端渲染 Vue.js 组件时，不会调用 <code>beforeMount</code> 和 <code>mounted</code> 的钩子的，因为没有操作 DOM 的环境。<p>尽管在 <code>beforeCreate</code> 时期，事件与生命周期已完成初始化，但是初始化注入和交互都是在 <code>beforeCreate</code> 之后，<code>created</code>之前。那么在组件中的数据操作，如 <code>ajax 请求</code> 最早不能早于 <code>created</code> 时期。<h2 id="渲染"><a class="header-anchor" href="#渲染" aria-hidden="true">#</a> 渲染</h2><p><code>render</code> 函数不能写成 箭头函数，否则其中的 this 将指向错误的对象，而非 vue 实例。<h2 id="实例对象"><a class="header-anchor" href="#实例对象" aria-hidden="true">#</a> 实例对象</h2><p><code>$el</code> 只存在始于 <code>created</code> 之后，即在 <code>beforeMount</code> 才能被探测到。在 <code>beforeMount</code> 时期值为将被替换的节点，如原 DOM 中 <code>&lt;div class="app">&lt;/div></code>；在 <code>mounted</code> 时期的值为已经替换的 DOM 节点，原节点已经被新节点替换。<p><code>$refs</code> 是对 DOM 的引用，那么它的存在只能在 <code>mounted</code> 才能被探测到<p><code>$options</code> 是当前 Vue 实例化时的选项对象，即 <code>new Vue()</code> 时的参数对象<h2 id="在-vue-js-中监听对象属性的方法"><a class="header-anchor" href="#在-vue-js-中监听对象属性的方法" aria-hidden="true">#</a> 在 Vue.js 中监听对象属性的方法</h2><p>在常规情况下， Vue.js 只监听数据<strong>对象本身</strong>，即只监听指向某对象的<strong>指针是否变化</strong>。它对于该对象的内部属性变化并不能做到响应其变化。<p>原因是，据 <a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E6%A3%80%E6%B5%8B%E5%8F%98%E5%8C%96%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" rel="noopener noreferrer" target="_blank">官方文档<outboundlink></a>响应式原理，Vue.js 在初始化实例时，对 data 对象中的每一项都执行 <code>getter/setter</code> 的转化过程。这里的转化过程<strong>并没有进行深度遍历</strong>，即 data 对象中的某项是一个对象 A，对象 A 下的属性是<strong>不会</strong>受到监听的，受到 Vue.js 监听的是对象 A 这个整体。<p>示例如下：<pre class="language-js" v-pre><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    obj<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      a<span class="token punctuation">:</span> <span class="token number">0</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">inputEvt</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">.</span>a <span class="token operator">+=</span> <span class="token number">1</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">.</span>a<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 监听 obj 时是无法响应 obj.a 的变化的。修改为 'obj.a' 的监听即可</span>
    <span class="token function">obj</span> <span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'running'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token function">render</span> <span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'input'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      on<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        input<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>inputEvt
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><h3 id="解决方案"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h3><pre class="language-js" v-pre><code>watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  <span class="token comment">// 法一</span>
  <span class="token string">'obj.a'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token comment">// 对象属性的样式一定要是字符串形式</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj.a changed'</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token comment">// 法二</span>
  <span class="token function">obj</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">handler</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 一般省略了 handler 写法，直接写内部代码块内容</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'obj.a changed'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>

    immediate<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 该回调将会在侦听开始之后被立即调用</span>
    deep<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token comment">// 是否深度监听对象属性，性能开销大，慎用</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><blockquote><p>因 JavaScript 的限制，Vue.js 无法监听对象的属性的添加和删除。</blockquote><p><code>Vue.set()</code> 用于建立非初始化（没有在 data 项中声明的数据对象）对象属性的响应式监听，以触发视图更新。这个方法的目的是要去<strong>触发响应式的视图更新</strong>，而不是数据处理，若需要对对象的变化做出对应的数据处理，请使用 <code>watcher</code>。<h2 id="由-props-联系到子组件的通信行为"><a class="header-anchor" href="#由-props-联系到子组件的通信行为" aria-hidden="true">#</a> 由 props 联系到子组件的通信行为</h2><p>前提：一般地，我们将子组件分为业务子组件和基础（展示性）子组件。其中，基础组件是（展示性组件）由父组件向其通过 props 来传递数据并展示数据内容，仅仅具有展示功能，不具有处理数据功能。我们要遵循的原则是保持父子组件间的<code>单向数据流</code>。<p>子组件（业务和基础子组件）中不应有修改 props 的语句出现。因为 props 本身定位是<strong>规范约束</strong>子组件的显示行为。如果在这时在子组件中出现了修改 props 的语句。那么这破坏了传递 props 来约束子组件的原则。作为一个子组件不应该修改父组件的数据。<p>如果要在子组件内修改 props ，那么导致该子组件的职责不清晰。即该组件的<strong>职责定位</strong>有问题，要么派发事件让父组件处理数据，要么本应将数据处理完毕后再传给子组件。至于父组件会不会处理以及如何处理子组件传递的载荷，这不是子组件的职责所在。<p>至于基础子组件和业务子组件的划分，个人认为是通过组件本身内部功能实现（是否仅仅是展示数据），<strong>组件复用性</strong>来划分。一般地，复用性子组件我们定义为基础子组件，其中<strong>不应有</strong>处理数据的语句出现。因为复用性高，那么其在不同的使用环境可能对应不同的数据处理方法。所以，复用性组件应该作为基础组件的存在，其职责主要是展示数据。处理数据这一行为交由子组件的父组件处理。<h2 id="对增强组件复用性的思考"><a class="header-anchor" href="#对增强组件复用性的思考" aria-hidden="true">#</a> 对增强组件复用性的思考</h2><ol><li><p>划分明确的组件职责<li><p>slot 插槽<li><p>slot 插槽 + slot-scope 插槽</ol><h3 id="slot-scope-插槽原理"><a class="header-anchor" href="#slot-scope-插槽原理" aria-hidden="true">#</a> slot-scope 插槽原理</h3><p>一般情况下，每个组件都有自己的作用域，父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。典型示例就是，子组件中的 <code>slot 插槽</code> 内容引用的是<strong>父组件</strong>的数据对象。即 <code>slot 插槽</code> 的内容引用的数据对象是<strong>跟随</strong>父组件作用域的。<p>作用域插槽用于在子组件 <code>slot 插槽</code> 中调用自身的数据对象。父组件中的 <code>slot-scope 插槽</code> <strong>指定</strong>了要引用的 props 对象。这里就像是子组件的作用域插到父组件中一样。<pre class="language-html" v-pre><code><span class="token comment">&lt;!-- child component --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>child<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token comment">&lt;!-- 在父组件没有使用 slot-scope 时，插槽内容中的 props.text 值为父组件内的 props 值 --></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>

<span class="token comment">&lt;!-- parent component --></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-awesome-list</span> <span class="token attr-name">:items</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>items<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
<span class="token comment">&lt;!-- 此时，slot 插槽内容调用 props.text 值将优先调用子组件的 props.text --></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span>
    <span class="token attr-name">slot-scope</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>props<span class="token punctuation">"</span></span>
    <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>my-fancy-item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    {{ props.text }}
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-awesome-list</span><span class="token punctuation">></span></span>
</code></pre><p>在父组件中，指定了传给子组件的 slot-scope 值，那么在子组件中此时调用的 props 即为父组件的 props 值。<h3 id="slot-scope-插槽实现"><a class="header-anchor" href="#slot-scope-插槽实现" aria-hidden="true">#</a> slot-scope 插槽实现</h3><p>示例如下：<pre class="language-js" v-pre><code><span class="token keyword">const</span> ChildComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
      childText<span class="token punctuation">:</span> <span class="token string">'child text'</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token comment">// 子组件中的 text 将经过 slot-scope 传递给父组件</span>
  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`
  &lt;div class="child">
    &lt;slot :text="childText">&lt;/slot>
  &lt;/div>
  `</span></span>
<span class="token punctuation">}</span>

<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>

  components<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    ChildComponent
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token comment">// 父组件以 props 对象的属性的形式接收子组件传递的 text 值</span>
  <span class="token comment">// 同时，在插槽内仍可调用父组件的 data 对象</span>
  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`
  &lt;div class="app">
    &lt;child-component>
      &lt;span slot-scope="props">{{props.text}}&lt;/span>
    &lt;/child-component>
  &lt;/div>
  `</span></span><span class="token punctuation">,</span>

  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    text<span class="token punctuation">:</span> <span class="token string">'parent text'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>此时，渲染的 DOM 树如下：<pre class="language-html" v-pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>child<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>
    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>child text<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>
  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>
</code></pre><p>由以上实例，<code>slot-scope 插槽</code> 提供了一种经过 props 对象<strong>子组件向父组件传递数据</strong>的<strong>机会</strong>。它一般配合 <code>slot 插槽</code> 一起使用，这样，可以有不同的 <code>slot 插槽</code> 内容，但是使用的是<strong>同一数据对象</strong>，即***子组件作为一个能传递数据的重用模板***。此时，子组件的作用域好像插在父组件一样。<h3 id="slot-scope-插槽与-slot-插槽的不同"><a class="header-anchor" href="#slot-scope-插槽与-slot-插槽的不同" aria-hidden="true">#</a> slot-scope 插槽与 slot 插槽的不同</h3><p><code>slot-scope 插槽</code> <strong>侧重</strong>指定渲染时的<strong>数据对象</strong>的调用，它实现了一种经过 props 对象子组件向父组件传递数据的机会。<code>slot 插槽</code> 侧重指定渲染时的<strong>内容</strong>，即内容分发。<p>另外值得注意的是，<code>slot-scope 插槽</code> 定位并不是向父组件传递数据，它<strong>仅仅</strong>只能指定 <code>slot 插槽</code> 中内容区域的数据对象，那么 <code>slot-scope 插槽</code> 是不能与 <code>vm.$emit()</code> 来相提并论的。<h2 id="在渲染函数中使用-slot"><a class="header-anchor" href="#在渲染函数中使用-slot" aria-hidden="true">#</a> 在渲染函数中使用 $slot</h2><pre class="language-js" v-pre><code><span class="token keyword">const</span> ChildComponent <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">render</span> <span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      <span class="token keyword">class</span><span class="token punctuation">:</span> <span class="token string">'child'</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$slots<span class="token punctuation">.</span>header<span class="token punctuation">)</span> <span class="token comment">// 在子组件中通过 vm.$slot 来访问插槽内容</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>

  components<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    ChildComponent
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token function">render</span> <span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'div'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
      attrs<span class="token punctuation">:</span> <span class="token punctuation">{</span>
        id<span class="token punctuation">:</span> <span class="token string">'app'</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
      <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'child-component'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>
        <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">'span'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
          slot<span class="token punctuation">:</span> <span class="token string">'header'</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>text<span class="token punctuation">)</span>
      <span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token punctuation">]</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    text<span class="token punctuation">:</span> <span class="token string">'parent text'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>在渲染函数中，使用 <code>vm.$slot</code> 在子组件中（接收方）访问插槽内容，匿名插槽为 <code>vm.$slot.default</code>，具名插槽为 <code>vm.$slot.name</code>。</div></article><button data-v-e85d20b2 data-v-e85d20b2 class="floating-btn __position" style="display:none"><svg class="icon-rocket" data-v-e85d20b2 viewBox="0 0 512 512"><path d="M256 421.6c-18.1 0-33.2-6.8-42.9-10.9-5.4-2.3-11.3 1.8-10.9 7.6l3.5 51c.2 3.1 3.8 4.7 6.3 2.8l14.5-11c1.8-1.4 4.5-.9 5.7 1l20.5 32.1c1.5 2.4 5.1 2.4 6.6 0l20.5-32.1c1.2-1.9 3.9-2.4 5.7-1l14.5 11c2.5 1.9 6.1.3 6.3-2.8l3.5-51c.4-5.8-5.5-10-10.9-7.6-9.8 4.1-24.8 10.9-42.9 10.9z" data-v-e85d20b2></path><path d="M397.7 293.1l-48-49.1c0-158-93.2-228-93.2-228s-94.1 70-94.1 228l-48 49.1c-1.8 1.8-2.6 4.5-2.2 7.1L130.6 412c.9 5.7 7.1 8.5 11.8 5.4l67.1-45.4s20.7 20 47.1 20c26.4 0 46.1-20 46.1-20l67.1 45.4c4.6 3.1 10.8.3 11.8-5.4l18.5-111.9c.2-2.6-.6-5.2-2.4-7zM256.5 192c-17 0-30.7-14.3-30.7-32s13.8-32 30.7-32c17 0 30.7 14.3 30.7 32s-13.7 32-30.7 32z" data-v-e85d20b2></path></svg></button></main><footer class="blog-footer sf__main__layout grid col grid-jc-center" data-v-1044ad0a data-v-cac63c14><div class="footer-info" data-v-1044ad0a>Copyright © 2018 <a class="author" href="https://github.com/lbwa" rel="noopener" target="_blank" data-v-1044ad0a>Bowen</a></div></footer><section class="loading-wrapper grid col grid-center grid-jc-center" data-v-cac63c14 style="display:none"><div class="loading"><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div></div><a class="loading-tips">Loading</a></section></section></div></div><script type="text/javascript">window.__NUXT__={layout:"blog",data:[{menu:[{errno:0,to:"writings/dom-location",title:"获取 Element 在 document 中的位置信息",author:"Bowen",date:"2018 SEP 01",tags:["前端开发","CSS"]},{errno:0,to:"writings/spa-and-mpa",title:"SPA 与 MPA 的比较与优化",author:"Bowen",date:"2018 AUG 04",tags:["前端开发","SPA","MPA","skeleton"]},{errno:0,to:"writings/async-function-in-js",title:"Event loops 中的 AsyncFunction",author:"Bowen",date:"2018 JUL 26",tags:["JavaScript","async","事件循环"]},{errno:0,to:"writings/pwa-fundamentals",title:"PWA 基础",author:"Bowen",date:"2018 JUL 07",tags:["前端开发","PWA"]},{errno:0,to:"writings/js-design-pattern",title:"JS 设计模式",author:"Bowen",date:"2018 JUN 12",tags:["前端开发","设计模式"]},{errno:0,to:"writings/http-request",title:"HTTP 协议请求首部",author:"Bowen",date:"2018 JUN 08",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-response",title:"HTTP 协议响应首部",author:"Bowen",date:"2018 JUN 07",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-protocol",title:"HTTP 协议",author:"Bowen",date:"2018 JUN 06",tags:["前端开发","网络请求"]},{errno:0,to:"writings/execution-context",title:"JS 执行上下文",author:"Bowen",date:"2018 MAY 07",tags:["前端开发","JavaScript","执行上下文"]},{errno:0,to:"writings/vue-lifecycle-and-slots",title:"对 Vue 插槽和生命周期的一点思考",author:"Bowen",date:"2018 APR 24",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/learning-vue-unit-test",title:"总结如何进行单元测试",author:"Bowen",date:"2018 APR 21",tags:["前端开发","Vue.js","应用测试"]},{errno:0,to:"writings/cross-domain-solution",title:"客户端跨域解决方案",author:"Bowen",date:"2018 APR 19",tags:["前端开发","网络请求"]},{errno:0,to:"writings/css-bfc",title:"探究 BFC 以及闭合浮动原理",author:"Bowen",date:"2018 MAR 29",tags:["前端开发","CSS"]},{errno:0,to:"writings/vue.js-reusability-and-composition",title:"学习 Vue.js 可复用性和组合",author:"Bowen",date:"2018 MAR 12",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/event-loop",title:"解析 event loops",author:"Bowen",date:"2018 MAR 08",tags:["前端开发","JavaScript","事件循环"]},{errno:0,to:"writings/learning-vuex",title:"学习 vuex 基础",author:"Bowen",date:"2018 MAR 06",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/compare-commonjs-with-esm",title:"比较 CommonJS 与 ES6 Module 语法",author:"Bowen",date:"2018 FEB 27",tags:["前端开发","JavaScript","模块"]},{errno:0,to:"writings/learning-vuejs-essentials",title:"学习 Vue.js 基础",author:"Bowen",date:"2018 FEB 24",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/keyword-this",title:"理解 this 的指向",author:"Bowen",date:"2018 FEB 06",tags:["前端开发","JavaScript"]}]},{title:"对 Vue 插槽和生命周期的一点思考",date:"2018 APR 24",author:"Bowen",tags:["前端开发","Vue.js"],content:'<h2 id="vue-js-生命周期钩子"><a class="header-anchor" href="#vue-js-生命周期钩子" aria-hidden="true">#</a> Vue.js 生命周期钩子</h2>\n<p>在 Vue 组件的生命周期内，<code>mounted</code> 之前（包括自身）的所有钩子都只会调用<strong>唯一的一次</strong>。</p>\n<p>在服务端渲染 Vue.js 组件时，不会调用 <code>beforeMount</code> 和 <code>mounted</code> 的钩子的，因为没有操作 DOM 的环境。</p>\n<p>尽管在 <code>beforeCreate</code> 时期，事件与生命周期已完成初始化，但是初始化注入和交互都是在 <code>beforeCreate</code> 之后，<code>created</code>之前。那么在组件中的数据操作，如 <code>ajax 请求</code> 最早不能早于 <code>created</code> 时期。</p>\n<h2 id="渲染"><a class="header-anchor" href="#渲染" aria-hidden="true">#</a> 渲染</h2>\n<p><code>render</code> 函数不能写成 箭头函数，否则其中的 this 将指向错误的对象，而非 vue 实例。</p>\n<h2 id="实例对象"><a class="header-anchor" href="#实例对象" aria-hidden="true">#</a> 实例对象</h2>\n<p><code>$el</code> 只存在始于 <code>created</code> 之后，即在 <code>beforeMount</code> 才能被探测到。在 <code>beforeMount</code> 时期值为将被替换的节点，如原 DOM 中 <code>&lt;div class=&quot;app&quot;&gt;&lt;/div&gt;</code>；在 <code>mounted</code> 时期的值为已经替换的 DOM 节点，原节点已经被新节点替换。</p>\n<p><code>$refs</code> 是对 DOM 的引用，那么它的存在只能在 <code>mounted</code> 才能被探测到</p>\n<p><code>$options</code> 是当前 Vue 实例化时的选项对象，即 <code>new Vue()</code> 时的参数对象</p>\n<h2 id="在-vue-js-中监听对象属性的方法"><a class="header-anchor" href="#在-vue-js-中监听对象属性的方法" aria-hidden="true">#</a> 在 Vue.js 中监听对象属性的方法</h2>\n<p>在常规情况下， Vue.js 只监听数据<strong>对象本身</strong>，即只监听指向某对象的<strong>指针是否变化</strong>。它对于该对象的内部属性变化并不能做到响应其变化。</p>\n<p>原因是，据 <a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E6%A3%80%E6%B5%8B%E5%8F%98%E5%8C%96%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9" target="_blank" rel="noopener noreferrer">官方文档<OutboundLink/></a> 响应式原理，Vue.js 在初始化实例时，对 data 对象中的每一项都执行 <code>getter/setter</code> 的转化过程。这里的转化过程<strong>并没有进行深度遍历</strong>，即 data 对象中的某项是一个对象 A，对象 A 下的属性是<strong>不会</strong>受到监听的，受到 Vue.js 监听的是对象 A 这个整体。</p>\n<p>示例如下：</p>\n<pre v-pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  el<span class="token punctuation">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    obj<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      a<span class="token punctuation">:</span> <span class="token number">0</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token function">inputEvt</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">.</span>a <span class="token operator">+=</span> <span class="token number">1</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>obj<span class="token punctuation">.</span>a<span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n  watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 监听 obj 时是无法响应 obj.a 的变化的。修改为 \'obj.a\' 的监听即可</span>\n    <span class="token function">obj</span> <span class="token punctuation">(</span>newValue<span class="token punctuation">,</span> oldValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'running\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n  <span class="token function">render</span> <span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">\'input\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n      on<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n        input<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>inputEvt\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h3 id="解决方案"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h3>\n<pre v-pre class="language-js"><code>watch<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n  <span class="token comment">// 法一</span>\n  <span class="token string">\'obj.a\'</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token comment">// 对象属性的样式一定要是字符串形式</span>\n    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'obj.a changed\'</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n  <span class="token comment">// 法二</span>\n  <span class="token function">obj</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token function">handler</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">// 一般省略了 handler 写法，直接写内部代码块内容</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'obj.a changed\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n    immediate<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span> <span class="token comment">// 该回调将会在侦听开始之后被立即调用</span>\n    deep<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token comment">// 是否深度监听对象属性，性能开销大，慎用</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<blockquote>\n<p>因 JavaScript 的限制，Vue.js 无法监听对象的属性的添加和删除。</p>\n</blockquote>\n<p><code>Vue.set()</code> 用于建立非初始化（没有在 data 项中声明的数据对象）对象属性的响应式监听，以触发视图更新。这个方法的目的是要去<strong>触发响应式的视图更新</strong>，而不是数据处理，若需要对对象的变化做出对应的数据处理，请使用 <code>watcher</code>。</p>\n<h2 id="由-props-联系到子组件的通信行为"><a class="header-anchor" href="#由-props-联系到子组件的通信行为" aria-hidden="true">#</a> 由 props 联系到子组件的通信行为</h2>\n<p>前提：一般地，我们将子组件分为业务子组件和基础（展示性）子组件。其中，基础组件是（展示性组件）由父组件向其通过 props 来传递数据并展示数据内容，仅仅具有展示功能，不具有处理数据功能。我们要遵循的原则是保持父子组件间的<code>单向数据流</code>。</p>\n<p>子组件（业务和基础子组件）中不应有修改 props 的语句出现。因为 props 本身定位是<strong>规范约束</strong>子组件的显示行为。如果在这时在子组件中出现了修改 props 的语句。那么这破坏了传递 props 来约束子组件的原则。作为一个子组件不应该修改父组件的数据。</p>\n<p>如果要在子组件内修改 props ，那么导致该子组件的职责不清晰。即该组件的<strong>职责定位</strong>有问题，要么派发事件让父组件处理数据，要么本应将数据处理完毕后再传给子组件。至于父组件会不会处理以及如何处理子组件传递的载荷，这不是子组件的职责所在。</p>\n<p>至于基础子组件和业务子组件的划分，个人认为是通过组件本身内部功能实现（是否仅仅是展示数据），<strong>组件复用性</strong>来划分。一般地，复用性子组件我们定义为基础子组件，其中<strong>不应有</strong>处理数据的语句出现。因为复用性高，那么其在不同的使用环境可能对应不同的数据处理方法。所以，复用性组件应该作为基础组件的存在，其职责主要是展示数据。处理数据这一行为交由子组件的父组件处理。</p>\n<h2 id="对增强组件复用性的思考"><a class="header-anchor" href="#对增强组件复用性的思考" aria-hidden="true">#</a> 对增强组件复用性的思考</h2>\n<ol>\n<li>\n<p>划分明确的组件职责</p>\n</li>\n<li>\n<p>slot 插槽</p>\n</li>\n<li>\n<p>slot 插槽 + slot-scope 插槽</p>\n</li>\n</ol>\n<h3 id="slot-scope-插槽原理"><a class="header-anchor" href="#slot-scope-插槽原理" aria-hidden="true">#</a> slot-scope 插槽原理</h3>\n<p>一般情况下，每个组件都有自己的作用域，父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。典型示例就是，子组件中的 <code>slot 插槽</code> 内容引用的是<strong>父组件</strong>的数据对象。即 <code>slot 插槽</code> 的内容引用的数据对象是<strong>跟随</strong>父组件作用域的。</p>\n<p>作用域插槽用于在子组件 <code>slot 插槽</code> 中调用自身的数据对象。父组件中的 <code>slot-scope 插槽</code> <strong>指定</strong>了要引用的 props 对象。这里就像是子组件的作用域插到父组件中一样。</p>\n<pre v-pre class="language-html"><code><span class="token comment">&lt;!-- child component --\x3e</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>child<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n<span class="token comment">&lt;!-- 在父组件没有使用 slot-scope 时，插槽内容中的 props.text 值为父组件内的 props 值 --\x3e</span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>slot</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>slot</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n\n<span class="token comment">&lt;!-- parent component --\x3e</span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>my-awesome-list</span> <span class="token attr-name">:items</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>items<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n<span class="token comment">&lt;!-- 此时，slot 插槽内容调用 props.text 值将优先调用子组件的 props.text --\x3e</span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span>\n    <span class="token attr-name">slot-scope</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>props<span class="token punctuation">"</span></span>\n    <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>my-fancy-item<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    {{ props.text }}\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>my-awesome-list</span><span class="token punctuation">></span></span>\n</code></pre>\n<p>在父组件中，指定了传给子组件的 slot-scope 值，那么在子组件中此时调用的 props 即为父组件的 props 值。</p>\n<h3 id="slot-scope-插槽实现"><a class="header-anchor" href="#slot-scope-插槽实现" aria-hidden="true">#</a> slot-scope 插槽实现</h3>\n<p>示例如下：</p>\n<pre v-pre class="language-js"><code><span class="token keyword">const</span> ChildComponent <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function">data</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token punctuation">{</span>\n      childText<span class="token punctuation">:</span> <span class="token string">\'child text\'</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n  <span class="token comment">// 子组件中的 text 将经过 slot-scope 传递给父组件</span>\n  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`\n  &lt;div class="child">\n    &lt;slot :text="childText">&lt;/slot>\n  &lt;/div>\n  `</span></span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  el<span class="token punctuation">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n\n  components<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    ChildComponent\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n  <span class="token comment">// 父组件以 props 对象的属性的形式接收子组件传递的 text 值</span>\n  <span class="token comment">// 同时，在插槽内仍可调用父组件的 data 对象</span>\n  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`\n  &lt;div class="app">\n    &lt;child-component>\n      &lt;span slot-scope="props">{{props.text}}&lt;/span>\n    &lt;/child-component>\n  &lt;/div>\n  `</span></span><span class="token punctuation">,</span>\n\n  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    text<span class="token punctuation">:</span> <span class="token string">\'parent text\'</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>此时，渲染的 DOM 树如下：</p>\n<pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>app<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>child<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>\n    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span>child text<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>\n  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>\n</code></pre>\n<p>由以上实例，<code>slot-scope 插槽</code> 提供了一种经过 props 对象<strong>子组件向父组件传递数据</strong>的<strong>机会</strong>。它一般配合 <code>slot 插槽</code> 一起使用，这样，可以有不同的 <code>slot 插槽</code> 内容，但是使用的是<strong>同一数据对象</strong>，即***子组件作为一个能传递数据的重用模板***。此时，子组件的作用域好像插在父组件一样。</p>\n<h3 id="slot-scope-插槽与-slot-插槽的不同"><a class="header-anchor" href="#slot-scope-插槽与-slot-插槽的不同" aria-hidden="true">#</a> slot-scope 插槽与 slot 插槽的不同</h3>\n<p><code>slot-scope 插槽</code> <strong>侧重</strong>指定渲染时的<strong>数据对象</strong>的调用，它实现了一种经过 props 对象子组件向父组件传递数据的机会。<code>slot 插槽</code> 侧重指定渲染时的<strong>内容</strong>，即内容分发。</p>\n<p>另外值得注意的是，<code>slot-scope 插槽</code> 定位并不是向父组件传递数据，它<strong>仅仅</strong>只能指定 <code>slot 插槽</code> 中内容区域的数据对象，那么 <code>slot-scope 插槽</code> 是不能与 <code>vm.$emit()</code> 来相提并论的。</p>\n<h2 id="在渲染函数中使用-slot"><a class="header-anchor" href="#在渲染函数中使用-slot" aria-hidden="true">#</a> 在渲染函数中使用 $slot</h2>\n<pre v-pre class="language-js"><code><span class="token keyword">const</span> ChildComponent <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function">render</span> <span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">\'div\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n      <span class="token keyword">class</span><span class="token punctuation">:</span> <span class="token string">\'child\'</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>$slots<span class="token punctuation">.</span>header<span class="token punctuation">)</span> <span class="token comment">// 在子组件中通过 vm.$slot 来访问插槽内容</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  el<span class="token punctuation">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n\n  components<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    ChildComponent\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n  <span class="token function">render</span> <span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">\'div\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n      attrs<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n        id<span class="token punctuation">:</span> <span class="token string">\'app\'</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>\n      <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">\'child-component\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>\n        <span class="token function">h</span><span class="token punctuation">(</span><span class="token string">\'span\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n          slot<span class="token punctuation">:</span> <span class="token string">\'header\'</span>\n        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>text<span class="token punctuation">)</span>\n      <span class="token punctuation">]</span><span class="token punctuation">)</span>\n    <span class="token punctuation">]</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    text<span class="token punctuation">:</span> <span class="token string">\'parent text\'</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>在渲染函数中，使用 <code>vm.$slot</code> 在子组件中（接收方）访问插槽内容，匿名插槽为 <code>vm.$slot.default</code>，具名插槽为 <code>vm.$slot.name</code>。</p>\n'}],error:null,serverRendered:!0}</script><script defer src="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js"></script><script defer src="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js"></script><script defer src="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js"></script><script defer src="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js"></script><script defer src="/_nuxt/vendor.13de21511613edf061b2.js"></script><script defer src="/_nuxt/app.5a4fa6b8fcf73db97515.js"></script>