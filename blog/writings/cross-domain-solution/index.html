<!doctype html><html data-n-head="lang" data-n-head-ssr lang="zh"><meta data-n-head="true" content="IE=edge,chrome=1" http-equiv='"X-UA-Compatible'><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" name="viewport"><meta data-n-head="true" content="bowen blog, bowen 博客, vuejs, reactjs, ssr, 前端开发, 前端 , web开发, nodejs, github" name="keywords"><meta data-n-head="true" content="一个分享代码经历的地方" name="description" data-hid="description"><meta data-n-head="true" content="yes" name="apple-mobile-web-app-capable"><meta data-n-head="true" content="black" name="apple-mobile-web-app-status-bar-style"><meta data-n-head="true" content="yes" name="mobile-web-app-capable" data-hid="mobile-web-app-capable"><meta data-n-head="true" content="Bowen Blog" name="apple-mobile-web-app-title" data-hid="apple-mobile-web-app-title"><meta data-n-head="true" content="Bowen" name="author" data-hid="author"><meta data-n-head="true" content="#24292e" name="theme-color" data-hid="theme-color"><meta data-n-head="true" content="website" name="og:type" data-hid="og:type" property="og:type"><meta data-n-head="true" content="Bowen Blog" name="og:title" data-hid="og:title" property="og:title"><meta data-n-head="true" content="A place which is used to share programming experiences" name="og:description" data-hid="og:description" property="og:description"><title data-n-head="true">客户端跨域解决方案 | Bowen Blog</title><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="/_nuxt/manifest.2108b1d4.json" rel="manifest" data-n-head="true"><link href="/_nuxt/icons/icon_64.e20A200w20w.png" rel="shortcut icon" data-n-head="true"><link href="/_nuxt/icons/icon_512.e20A200w20w.png" rel="apple-touch-icon" data-n-head="true" sizes="512x512"><link href="https://set.sh/blog/writings/cross-domain-solution/" rel="alternate" data-n-head="true" hreflang="zh"><link href="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js" rel="preload" as="script"><link href="/_nuxt/vendor.13de21511613edf061b2.js" rel="preload" as="script"><link href="/_nuxt/app.5a4fa6b8fcf73db97515.js" rel="preload" as="script"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="preload" as="style"><link href="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js" rel="preload" as="script"><link href="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/tags/_id/index.edb9dbabb1b9c2ef81f2.js" rel="prefetch"><link href="/_nuxt/pages/index.1d0ac68e309be0e86168.js" rel="prefetch"><link href="/_nuxt/pages/blog/tags/index.2659d358b69abdfd34bf.js" rel="prefetch"><link href="/_nuxt/pages/blog/projects/index.3ff8e031c3cb4f25eaed.js" rel="prefetch"><link href="/_nuxt/pages/blog/writings/index.b016af22016e152b7231.js" rel="prefetch"><link href="/_nuxt/layouts/home.dd55e95df1c2109ebde6.js" rel="prefetch"><link href="/_nuxt/layouts/default.89ffa224d3d7769e4fbb.js" rel="prefetch"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="stylesheet"><body data-n-head=""><div id="__nuxt" data-server-rendered="true"><div class="nuxt-progress" style="width:0%;height:2px;background-color:#3eaf7c;opacity:0"></div><div id="__layout"><section class="blog sf__parent__clearfix" data-v-cac63c14><header class="header __position components-animation" data-v-13c46026 data-v-cac63c14><nav class="mobile-navigator" data-v-13c46026 data-v-d4cae7a6><label class="label-line" data-v-d4cae7a6><span class="__position label-line line-top" data-v-d4cae7a6><span class="__position line-crust line-crust-top" data-v-d4cae7a6></span></span><span class="__position label-line line-bottom" data-v-d4cae7a6><span class="__position line-crust line-crust-bottom" data-v-d4cae7a6></span></span></label></nav><nav class="navigator __position grid" data-v-13c46026 role="navigation"><a href="/" class="navigator-link hover-animation grid-cell" data-v-13c46026>HOME</a><a href="/blog/writings/" class="navigator-link hover-animation grid-cell" data-v-13c46026>WRITINGS</a><a href="/blog/projects/" class="navigator-link hover-animation grid-cell" data-v-13c46026>PROJECTS</a><a href="/blog/tags/" class="navigator-link hover-animation grid-cell" data-v-13c46026>TAGS</a><a href="https://github.com/lbwa" class="navigator-link hover-animation grid-cell" data-v-13c46026 rel="noopener" target="_blank">GITHUB</a></nav><div class="background-helper __position" data-v-13c46026></div></header><main class="articles-container wrapper sf__reference__layout" data-v-cac63c14 role="main"><article class="articles-main"><div class="article-header"><h1 class="article-title">客户端跨域解决方案</h1><span class="article-author">Bowen</span><span class="article-date">2018 APR 19</span><div class="article-tags"><a href="/blog/tags/前端开发" class="article-tag">前端开发</a><a href="/blog/tags/网络请求" class="article-tag">网络请求</a></div></div><div class="article-content"><h2 id="什么是跨域"><a href="#什么是跨域" class="header-anchor" aria-hidden="true">#</a> 什么是跨域</h2><p>跨域，指的是浏览器当前页面不能执行其他网站的脚本。它是由浏览器的<strong>同源策略</strong>造成的，是浏览器对 JavaScript 脚本施加的安全限制。<p>所谓<code>同源</code>是指，<strong>域名，协议，端口</strong>都相同。浏览器执行 JavaScript 脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。<h2 id="对跨域的基本理解"><a href="#对跨域的基本理解" class="header-anchor" aria-hidden="true">#</a> 对跨域的基本理解</h2><ol><li><p>跨域只存在于浏览器客户端，在服务端是不存在跨域的。<li><p>跨域时的 ajax 请求并不是没有发出去，此时跨域请求<strong>仍能发出</strong>，且服务端能够收到请求，并返回相应的结果，只是结果在客户端解析时，<strong>被拦截</strong>了。这一点可在请求后的控制台 <code>network</code> 选项卡验证，在报错跨域时，仍然能够看到返回的数据结果 <code>response</code>。</ol><p>浏览器在数据返回时会验证是否是同源数据，若不是同源数据，将会进一步<strong>验证数据头部</strong>是否带有 <code>access-control-allow-origin: *</code> ，以此来判断返回数据的服务器是否开启了 <code>CORS</code> ，并且检查当前源中<strong>允许的源</strong>是否包括了请求源，并作出解析或拒绝解析返回数据的判断。<p><img alt="跨域请求" src="https://assets.set.sh/2018/180419-cross-domain-solution/detect-cors.png"><h2 id="解决方案"><a href="#解决方案" class="header-anchor" aria-hidden="true">#</a> 解决方案</h2><p>跨域的常见解决方法:<p>目前为止，跨域请求都必须依靠服务端进行相关配置来处理跨域请求。<ol><li>window.name + iframe 需要目标服务器响应 window.name。<li>window.location.hash + iframe 同样需要目标服务器作处理。<li>html5 的 postMessage + iframe 这个也是需要目标服务器或者说是目标页面写一个 postMessage，主要侧重于前端通讯。<li>JSONP 需要目标服务器配合一个 callback 函数。<li>CORS 需要服务器设置 header：Access-Control-Allow-Origin。<li>服务器（如，自建 nginx 服务器）反向代理，这种方法可以不用目标服务器配合，但是必须搭建一个<strong>中转服务器</strong>，用于转发请求。此法亦可伪造 header 来绕过 JSONP 的 header 验证</ol><p>现在一般常用的是方法是 4，5，6。<h2 id="拓展：关于-ajax-的同源限制"><a href="#拓展：关于-ajax-的同源限制" class="header-anchor" aria-hidden="true">#</a> 拓展：关于 ajax 的同源限制</h2><p>简短来说，客户端的 ajax 请求只能请求同源数据。<p>举例来说，a 网站有一个 ajax 请求 x，a 在没有配置后端的情况下，b网站是不能直接使用 ajax 跨域请求 a 网站的请求 x（浏览器同源策略），只有当 a 网站的请求 x 是 JSONP 请求时，b 网站才能通过 ajax 代理 JSONP 请求并伪造 header 请求 x。或将b网站的 ajax 请求由中转服务器转发去请求 x。<h2 id="反向代理解决需要跨域的-ajax"><a href="#反向代理解决需要跨域的-ajax" class="header-anchor" aria-hidden="true">#</a> 反向代理解决需要跨域的 ajax</h2><p>反向代理原理：浏览器有同源限制，但<strong>服务器没有同源限制</strong>，那么可以利用这一特性来使用本地服务器来转发请求<p>前后端分离开发过程中，webpack-dev-server （基于 express 的实现）设置 <a href="https://doc.webpack-china.org/configuration/dev-server/#devserver-before" rel="noopener noreferrer" target="_blank">devServer.before<outboundlink></a>来实现反向代理，示例配置<a href="https://github.com/lbwa/vue-sonar/blob/master/build/webpack.dev.conf.js#L28-L116" rel="noopener noreferrer" target="_blank">点我<outboundlink></a><h2 id="反向代理解决需要验证-header-的-jsonp"><a href="#反向代理解决需要验证-header-的-jsonp" class="header-anchor" aria-hidden="true">#</a> 反向代理解决需要验证 header 的 JSONP</h2><p>现象：JSONP 本身是不具有模拟 headers 的功能的。<p>原理：当目标是需要验证 header 的 JSONP 请求时。使用中转服务器的 axios 请求模拟目标 JSONP 请求及其 header。返回的数据格式是携带有目标数据的回调函数。<p>典型的需要验证 header 的 JSONP 请求模拟<a href="https://github.com/lbwa/vue-sonar/blob/master/src/api/the-recommend.js#L33-L59" rel="noopener noreferrer" target="_blank">示例<outboundlink></a><pre class="language-js" v-pre><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getJSONPData</span> <span class="token punctuation">(</span>recommendId<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token operator">...</span>commonParams<span class="token punctuation">,</span>
    <span class="token operator">...</span><span class="token punctuation">{</span>
      type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
      json<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
      utf8<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>
      <span class="token comment">// ... some request params</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>

  <span class="token comment">// 在没有 header 验证的情况下直接使用 jsonp 请求 url，否则使用后端 ajax 代理转发 JSONP 请求</span>
  <span class="token comment">// return jsonp(TARGET_URL, data, {</span>
  <span class="token comment">//   ...options,</span>
  <span class="token comment">//   // https://github.com/webmodules/jsonp/blob/master/index.js#L50</span>
  <span class="token comment">//   prefix: '', // 回调函数前缀，默认值为 __jp</span>
  <span class="token comment">//   name: 'playlistinfoCallback' // 回调函数名，默认值为从 0 开始的计数器</span>
  <span class="token comment">// })</span>

  <span class="token keyword">return</span> axios<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token constant">TARGET_URL</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    params<span class="token punctuation">:</span> data
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=></span> res<span class="token punctuation">.</span>data<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre><p>中转服务器示例配置(express 为例)<a href="https://github.com/lbwa/vue-sonar/blob/master/build/webpack.dev.conf.js#L74-L100" rel="noopener noreferrer" target="_blank">点我<outboundlink></a><pre class="language-js" v-pre><code><span class="token comment">// devServer.before(它是一个 express API)</span>

app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/api/getJSONPData'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token string">'https://example.com'</span>

  axios<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token comment">// 伪造 JSONP 的 headers</span>
    headers<span class="token punctuation">:</span> <span class="token punctuation">{</span>
      referer<span class="token punctuation">:</span> <span class="token string">'https://example.com'</span><span class="token punctuation">,</span>
      host<span class="token punctuation">:</span> <span class="token string">'https://example.com'</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    params<span class="token punctuation">:</span> req<span class="token punctuation">.</span>query
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">let</span> ret <span class="token operator">=</span> response<span class="token punctuation">.</span>data

    <span class="token comment">// 提取返回的 JSONP 数据中的回调函数中的参数（即目标数据）</span>

    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> ret <span class="token operator">===</span> <span class="token string">'string'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token comment">// 该正则不具有普适性</span>
      <span class="token keyword">const</span> reg <span class="token operator">=</span> <span class="token regex">/^\w+\(({.+})\)$/</span>
      <span class="token keyword">const</span> matches <span class="token operator">=</span> ret<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span>

      <span class="token keyword">if</span> <span class="token punctuation">(</span>matches<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        ret <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>matches<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> err <span class="token operator">=></span> <span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Proxy failed, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>err<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>以上两个配置对比普通的 JSONP 请求，可看出，当（<strong>前提条件</strong>） JSONP 有 header 验证时，转为使用 后端代理 ajax 请求 JSONP 数据，（<strong>返回数据的处理方法</strong>）返回的数据是包含之前 JSONP 的回调函数名的，可在 <a href="https://github.com/lbwa/vue-sonar/blob/master/build/webpack.dev.conf.js#L85-L95" rel="noopener noreferrer" target="_blank">剔除回调函数<outboundlink></a>看出，需要对返回的数据剔除回调函数名，并转为 JSON 正确格式<h2 id="反向代理适用场景"><a href="#反向代理适用场景" class="header-anchor" aria-hidden="true">#</a> 反向代理适用场景</h2><h3 id="场景一：目标服务器返回-json-格式"><a href="#场景一：目标服务器返回-json-格式" class="header-anchor" aria-hidden="true">#</a> 场景一：目标服务器返回 JSON 格式</h3><p>在后端代理请求返回数据格式为 JSON 的情况下，api 不要使用 JSONP 访问后端中转服务器的 url ，尽管 api 能收到正确的数据内容，但格式是错误 <code>(Uncaught SyntaxError: Unexpected token :)</code> 的！！因为中转服务器 axios 请求目标服务器返回的数据是 JSON 格式。中转服务器会将目标服务器返回的数据转发回 api ，那么 JSONP 是<strong>无法正确解析</strong> JSON 格式的（JSON 格式没有回调函数）。即请求的类型数据格式要对应相应的请求类型。<h3 id="场景二：目标服务器返回-jsonp-格式"><a href="#场景二：目标服务器返回-jsonp-格式" class="header-anchor" aria-hidden="true">#</a> 场景二：目标服务器返回 JSONP 格式</h3><p>当目标服务器返回的是 JSONP 格式时，<em><strong>仍然使用 axios 请求中转服务器</strong></em>，不同于场景一的是，在返回的 JSONP 数据中需要<strong>剔除回调函数并转化为 JSON 格式</strong>。<p>那么可总结为，使用 axios 转发模拟带 headers 验证的 JSONP 时，<em><strong>必须以 ajax 请求中转服务器</strong></em>。我们根据目标服务器返回给中转服务器的数据类型来决定是否在中转服务器中添加<strong>剔除回调函数并转化为 JSON 格式</strong>这一数据处理的步骤。<h3 id="易错点：反向代理转发请求时返回错误格式"><a href="#易错点：反向代理转发请求时返回错误格式" class="header-anchor" aria-hidden="true">#</a> 易错点：反向代理转发请求时返回错误格式</h3><p>现象：<a href="https://github.com/lbwa/vue-sonar/blob/master/src/api/the-recommend.js#L49-L55" rel="noopener noreferrer" target="_blank">链接<outboundlink></a>高亮处 JSONP 请求中转服务器，返回格式错误<p>原因：目标服务器只接受 ajax 请求（返回的数据不会有回调函数包裹）时，我们的网页也只能以 ajax 请求中转服务器，中转服务器转发 ajax 请求。若我们的网页使用 JSONP 来请求中转服务器，那么我们最后收到的是 ajax 类型的返回数据，并没有一个回调函数来包裹返回数据，那么就没有可执行的回调函数。即造成了格式错误。<p>解决方案：<a href="https://github.com/lbwa/vue-sonar/blob/master/src/api/the-recommend.js#L56-L59" rel="noopener noreferrer" target="_blank">使用 axios 请求<outboundlink></a>后端中转服务器，返回正确格式<h2 id="jsonp"><a href="#jsonp" class="header-anchor" aria-hidden="true">#</a> JSONP</h2><p>JOSNP 意为 <code>JSON with padding</code>，本质是动态创建 script 标签的 src 属性来请求数据，因为 <code>&lt;script></code> 的 <code>src</code> 属性是可以<strong>跨域的。</strong><p>原理：<ol><li><p>首先是利用 <code>&lt;script></code> 的 <code>src</code> 属性来实现跨域。<li><p>通过将前端方法作为<strong>参数</strong>传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信。客户端在收到返回数据时，就会执行被回调函数包裹的目标数据。<li><p>由于使用 script 标签的 src 属性，因此<strong>只支持get方法</strong></ol><p><strong>直接</strong>使用 jsonp 方法访问源地址，这在<strong>没有 referer 验证的情况下</strong>可返回正确的数据，若需要 referer 验证(在 Chrome Devtool network 选项直接点击链接是否能返回正确数据)，那么使用 axios 后端代理转发请求。因为 JSONP 本身不能伪造 headers ，反向代理的目的是<strong>伪造 header。</strong><p>典型的 JSONP 请求<a href="https://github.com/lbwa/vue-sonar/blob/master/src/api/the-artist.js#L4-L20" rel="noopener noreferrer" target="_blank">点我<outboundlink></a><h3 id="jsonp-的局限性"><a href="#jsonp-的局限性" class="header-anchor" aria-hidden="true">#</a> JSONP 的局限性</h3><ol><li><p>只支持 GET 请求<li><p>因为是通过 <code>&lt;script></code> 的 <code>src</code> 属性来实现跨域的，那么我们是无法验证请求数据的安全性，那么我们必须确保请求的域的安全性<li><p>必须另外添加计时器来判断是否请求成功</ol><h2 id="参考"><a href="#参考" class="header-anchor" aria-hidden="true">#</a> 参考</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy" rel="noopener noreferrer" target="_blank">MDN Same-Origin Policy<outboundlink></a><p><a href="https://html.spec.whatwg.org/multipage/origin.html#concept-origin" rel="noopener noreferrer" target="_blank">HTML Standard Concept-origin<outboundlink></a><p><a href="https://juejin.im/post/5a6320d56fb9a01cb64ee191" rel="noopener noreferrer" target="_blank">我知道的跨域与安全<outboundlink></a><p><a href="https://segmentfault.com/a/1190000012469713#articleHeader12" rel="noopener noreferrer" target="_blank">ajax 跨域解决方案<outboundlink></a><p><a href="https://www.zhihu.com/question/265985355" rel="noopener noreferrer" target="_blank">如何解决前后端分离中的 ajax 跨域问题<outboundlink></a><p><a href="https://www.zhihu.com/question/264546160" rel="noopener noreferrer" target="_blank">常见 jsonp 出现格式错误的原因<outboundlink></a></div></article><button data-v-e85d20b2 data-v-e85d20b2 class="floating-btn __position" style="display:none"><svg class="icon-rocket" data-v-e85d20b2 viewBox="0 0 512 512"><path d="M256 421.6c-18.1 0-33.2-6.8-42.9-10.9-5.4-2.3-11.3 1.8-10.9 7.6l3.5 51c.2 3.1 3.8 4.7 6.3 2.8l14.5-11c1.8-1.4 4.5-.9 5.7 1l20.5 32.1c1.5 2.4 5.1 2.4 6.6 0l20.5-32.1c1.2-1.9 3.9-2.4 5.7-1l14.5 11c2.5 1.9 6.1.3 6.3-2.8l3.5-51c.4-5.8-5.5-10-10.9-7.6-9.8 4.1-24.8 10.9-42.9 10.9z" data-v-e85d20b2></path><path d="M397.7 293.1l-48-49.1c0-158-93.2-228-93.2-228s-94.1 70-94.1 228l-48 49.1c-1.8 1.8-2.6 4.5-2.2 7.1L130.6 412c.9 5.7 7.1 8.5 11.8 5.4l67.1-45.4s20.7 20 47.1 20c26.4 0 46.1-20 46.1-20l67.1 45.4c4.6 3.1 10.8.3 11.8-5.4l18.5-111.9c.2-2.6-.6-5.2-2.4-7zM256.5 192c-17 0-30.7-14.3-30.7-32s13.8-32 30.7-32c17 0 30.7 14.3 30.7 32s-13.7 32-30.7 32z" data-v-e85d20b2></path></svg></button></main><footer class="blog-footer sf__main__layout grid col grid-jc-center" data-v-1044ad0a data-v-cac63c14><div class="footer-info" data-v-1044ad0a>Copyright © 2018 <a href="https://github.com/lbwa" class="author" rel="noopener" target="_blank" data-v-1044ad0a>Bowen</a></div></footer><section class="loading-wrapper grid col grid-center grid-jc-center" data-v-cac63c14 style="display:none"><div class="loading"><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div></div><a class="loading-tips">Loading</a></section></section></div></div><script type="text/javascript">window.__NUXT__={layout:"blog",data:[{menu:[{errno:0,to:"writings/dom-location",title:"获取 Element 在 document 中的位置信息",author:"Bowen",date:"2018 SEP 01",tags:["前端开发","CSS"]},{errno:0,to:"writings/spa-and-mpa",title:"SPA 与 MPA 的比较与优化",author:"Bowen",date:"2018 AUG 04",tags:["前端开发","SPA","MPA","skeleton"]},{errno:0,to:"writings/async-function-in-js",title:"Event loops 中的 AsyncFunction",author:"Bowen",date:"2018 JUL 26",tags:["JavaScript","async","事件循环"]},{errno:0,to:"writings/pwa-fundamentals",title:"PWA 基础",author:"Bowen",date:"2018 JUL 07",tags:["前端开发","PWA"]},{errno:0,to:"writings/js-design-pattern",title:"JS 设计模式",author:"Bowen",date:"2018 JUN 12",tags:["前端开发","设计模式"]},{errno:0,to:"writings/http-request",title:"HTTP 协议请求首部",author:"Bowen",date:"2018 JUN 08",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-response",title:"HTTP 协议响应首部",author:"Bowen",date:"2018 JUN 07",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-protocol",title:"HTTP 协议",author:"Bowen",date:"2018 JUN 06",tags:["前端开发","网络请求"]},{errno:0,to:"writings/execution-context",title:"JS 执行上下文",author:"Bowen",date:"2018 MAY 07",tags:["前端开发","JavaScript","执行上下文"]},{errno:0,to:"writings/vue-lifecycle-and-slots",title:"对 Vue 插槽和生命周期的一点思考",author:"Bowen",date:"2018 APR 24",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/learning-vue-unit-test",title:"总结如何进行单元测试",author:"Bowen",date:"2018 APR 21",tags:["前端开发","Vue.js","应用测试"]},{errno:0,to:"writings/cross-domain-solution",title:"客户端跨域解决方案",author:"Bowen",date:"2018 APR 19",tags:["前端开发","网络请求"]},{errno:0,to:"writings/css-bfc",title:"探究 BFC 以及闭合浮动原理",author:"Bowen",date:"2018 MAR 29",tags:["前端开发","CSS"]},{errno:0,to:"writings/vue.js-reusability-and-composition",title:"学习 Vue.js 可复用性和组合",author:"Bowen",date:"2018 MAR 12",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/event-loop",title:"解析 event loops",author:"Bowen",date:"2018 MAR 08",tags:["前端开发","JavaScript","事件循环"]},{errno:0,to:"writings/learning-vuex",title:"学习 vuex 基础",author:"Bowen",date:"2018 MAR 06",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/compare-commonjs-with-esm",title:"比较 CommonJS 与 ES6 Module 语法",author:"Bowen",date:"2018 FEB 27",tags:["前端开发","JavaScript","模块"]},{errno:0,to:"writings/learning-vuejs-essentials",title:"学习 Vue.js 基础",author:"Bowen",date:"2018 FEB 24",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/keyword-this",title:"理解 this 的指向",author:"Bowen",date:"2018 FEB 06",tags:["前端开发","JavaScript"]}]},{title:"客户端跨域解决方案",date:"2018 APR 19",author:"Bowen",tags:["前端开发","网络请求"],content:'<h2 id="什么是跨域"><a class="header-anchor" href="#什么是跨域" aria-hidden="true">#</a> 什么是跨域</h2>\n<p>跨域，指的是浏览器当前页面不能执行其他网站的脚本。它是由浏览器的<strong>同源策略</strong>造成的，是浏览器对 JavaScript 脚本施加的安全限制。</p>\n<p>所谓<code>同源</code>是指，<strong>域名，协议，端口</strong>都相同。浏览器执行 JavaScript 脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。</p>\n<h2 id="对跨域的基本理解"><a class="header-anchor" href="#对跨域的基本理解" aria-hidden="true">#</a> 对跨域的基本理解</h2>\n<ol>\n<li>\n<p>跨域只存在于浏览器客户端，在服务端是不存在跨域的。</p>\n</li>\n<li>\n<p>跨域时的 ajax 请求并不是没有发出去，此时跨域请求<strong>仍能发出</strong>，且服务端能够收到请求，并返回相应的结果，只是结果在客户端解析时，<strong>被拦截</strong>了。这一点可在请求后的控制台 <code>network</code> 选项卡验证，在报错跨域时，仍然能够看到返回的数据结果 <code>response</code>。</p>\n</li>\n</ol>\n<p>浏览器在数据返回时会验证是否是同源数据，若不是同源数据，将会进一步<strong>验证数据头部</strong>是否带有 <code>access-control-allow-origin: *</code> ，以此来判断返回数据的服务器是否开启了 <code>CORS</code> ，并且检查当前源中<strong>允许的源</strong>是否包括了请求源，并作出解析或拒绝解析返回数据的判断。</p>\n<p><img src="https://assets.set.sh/2018/180419-cross-domain-solution/detect-cors.png" alt="跨域请求"></p>\n<h2 id="解决方案"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h2>\n<p>跨域的常见解决方法:</p>\n<p>目前为止，跨域请求都必须依靠服务端进行相关配置来处理跨域请求。</p>\n<ol>\n<li>window.name + iframe 需要目标服务器响应 window.name。</li>\n<li>window.location.hash + iframe 同样需要目标服务器作处理。</li>\n<li>html5 的 postMessage + iframe 这个也是需要目标服务器或者说是目标页面写一个 postMessage，主要侧重于前端通讯。</li>\n<li>JSONP 需要目标服务器配合一个 callback 函数。</li>\n<li>CORS 需要服务器设置 header：Access-Control-Allow-Origin。</li>\n<li>服务器（如，自建 nginx 服务器）反向代理，这种方法可以不用目标服务器配合，但是必须搭建一个<strong>中转服务器</strong>，用于转发请求。此法亦可伪造 header 来绕过 JSONP 的 header 验证</li>\n</ol>\n<p>现在一般常用的是方法是 4，5，6。</p>\n<h2 id="拓展：关于-ajax-的同源限制"><a class="header-anchor" href="#拓展：关于-ajax-的同源限制" aria-hidden="true">#</a> 拓展：关于 ajax 的同源限制</h2>\n<p>简短来说，客户端的 ajax 请求只能请求同源数据。</p>\n<p>举例来说，a 网站有一个 ajax 请求 x，a 在没有配置后端的情况下，b网站是不能直接使用 ajax 跨域请求 a 网站的请求 x（浏览器同源策略），只有当 a 网站的请求 x 是 JSONP 请求时，b 网站才能通过 ajax 代理 JSONP 请求并伪造 header 请求 x。或将b网站的 ajax 请求由中转服务器转发去请求 x。</p>\n<h2 id="反向代理解决需要跨域的-ajax"><a class="header-anchor" href="#反向代理解决需要跨域的-ajax" aria-hidden="true">#</a> 反向代理解决需要跨域的 ajax</h2>\n<p>反向代理原理：浏览器有同源限制，但<strong>服务器没有同源限制</strong>，那么可以利用这一特性来使用本地服务器来转发请求</p>\n<p>前后端分离开发过程中，webpack-dev-server （基于 express 的实现）设置 <a href="https://doc.webpack-china.org/configuration/dev-server/#devserver-before" target="_blank" rel="noopener noreferrer">devServer.before<OutboundLink/></a> 来实现反向代理，示例配置<a href="https://github.com/lbwa/vue-sonar/blob/master/build/webpack.dev.conf.js#L28-L116" target="_blank" rel="noopener noreferrer">点我<OutboundLink/></a></p>\n<h2 id="反向代理解决需要验证-header-的-jsonp"><a class="header-anchor" href="#反向代理解决需要验证-header-的-jsonp" aria-hidden="true">#</a> 反向代理解决需要验证 header 的 JSONP</h2>\n<p>现象：JSONP 本身是不具有模拟 headers 的功能的。</p>\n<p>原理：当目标是需要验证 header 的 JSONP 请求时。使用中转服务器的 axios 请求模拟目标 JSONP 请求及其 header。返回的数据格式是携带有目标数据的回调函数。</p>\n<p>典型的需要验证 header 的 JSONP 请求模拟<a href="https://github.com/lbwa/vue-sonar/blob/master/src/api/the-recommend.js#L33-L59" target="_blank" rel="noopener noreferrer">示例<OutboundLink/></a></p>\n<pre v-pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">getJSONPData</span> <span class="token punctuation">(</span>recommendId<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> data <span class="token operator">=</span> <span class="token punctuation">{</span>\n    <span class="token operator">...</span>commonParams<span class="token punctuation">,</span>\n    <span class="token operator">...</span><span class="token punctuation">{</span>\n      type<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n      json<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n      utf8<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>\n      <span class="token comment">// ... some request params</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n\n  <span class="token comment">// 在没有 header 验证的情况下直接使用 jsonp 请求 url，否则使用后端 ajax 代理转发 JSONP 请求</span>\n  <span class="token comment">// return jsonp(TARGET_URL, data, {</span>\n  <span class="token comment">//   ...options,</span>\n  <span class="token comment">//   // https://github.com/webmodules/jsonp/blob/master/index.js#L50</span>\n  <span class="token comment">//   prefix: \'\', // 回调函数前缀，默认值为 __jp</span>\n  <span class="token comment">//   name: \'playlistinfoCallback\' // 回调函数名，默认值为从 0 开始的计数器</span>\n  <span class="token comment">// })</span>\n\n  <span class="token keyword">return</span> axios<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token constant">TARGET_URL</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    params<span class="token punctuation">:</span> data\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=></span> res<span class="token punctuation">.</span>data<span class="token punctuation">)</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<p>中转服务器示例配置(express 为例)<a href="https://github.com/lbwa/vue-sonar/blob/master/build/webpack.dev.conf.js#L74-L100" target="_blank" rel="noopener noreferrer">点我<OutboundLink/></a></p>\n<pre v-pre class="language-js"><code><span class="token comment">// devServer.before(它是一个 express API)</span>\n\napp<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">\'/api/getJSONPData\'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  <span class="token keyword">const</span> url <span class="token operator">=</span> <span class="token string">\'https://example.com\'</span>\n\n  axios<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span>url<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 伪造 JSONP 的 headers</span>\n    headers<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n      referer<span class="token punctuation">:</span> <span class="token string">\'https://example.com\'</span><span class="token punctuation">,</span>\n      host<span class="token punctuation">:</span> <span class="token string">\'https://example.com\'</span>\n    <span class="token punctuation">}</span><span class="token punctuation">,</span>\n    params<span class="token punctuation">:</span> req<span class="token punctuation">.</span>query\n  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>response <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">let</span> ret <span class="token operator">=</span> response<span class="token punctuation">.</span>data\n\n    <span class="token comment">// 提取返回的 JSONP 数据中的回调函数中的参数（即目标数据）</span>\n\n    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> ret <span class="token operator">===</span> <span class="token string">\'string\'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      <span class="token comment">// 该正则不具有普适性</span>\n      <span class="token keyword">const</span> reg <span class="token operator">=</span> <span class="token regex">/^\\w+\\(({.+})\\)$/</span>\n      <span class="token keyword">const</span> matches <span class="token operator">=</span> ret<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span>reg<span class="token punctuation">)</span>\n\n      <span class="token keyword">if</span> <span class="token punctuation">(</span>matches<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n        ret <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>matches<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span>\n    res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span> err <span class="token operator">=></span> <span class="token punctuation">{</span>\n    <span class="token keyword">throw</span> <span class="token function">Error</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`Proxy failed, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>err<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>以上两个配置对比普通的 JSONP 请求，可看出，当（<strong>前提条件</strong>） JSONP 有 header 验证时，转为使用 后端代理 ajax 请求 JSONP 数据，（<strong>返回数据的处理方法</strong>）返回的数据是包含之前 JSONP 的回调函数名的，可在 <a href="https://github.com/lbwa/vue-sonar/blob/master/build/webpack.dev.conf.js#L85-L95" target="_blank" rel="noopener noreferrer">剔除回调函数<OutboundLink/></a> 看出，需要对返回的数据剔除回调函数名，并转为 JSON 正确格式</p>\n<h2 id="反向代理适用场景"><a class="header-anchor" href="#反向代理适用场景" aria-hidden="true">#</a> 反向代理适用场景</h2>\n<h3 id="场景一：目标服务器返回-json-格式"><a class="header-anchor" href="#场景一：目标服务器返回-json-格式" aria-hidden="true">#</a> 场景一：目标服务器返回 JSON 格式</h3>\n<p>在后端代理请求返回数据格式为 JSON 的情况下，api 不要使用 JSONP 访问后端中转服务器的 url ，尽管 api 能收到正确的数据内容，但格式是错误 <code>(Uncaught SyntaxError: Unexpected token :)</code> 的！！因为中转服务器 axios 请求目标服务器返回的数据是 JSON 格式。中转服务器会将目标服务器返回的数据转发回 api ，那么 JSONP 是<strong>无法正确解析</strong> JSON 格式的（JSON 格式没有回调函数）。即请求的类型数据格式要对应相应的请求类型。</p>\n<h3 id="场景二：目标服务器返回-jsonp-格式"><a class="header-anchor" href="#场景二：目标服务器返回-jsonp-格式" aria-hidden="true">#</a> 场景二：目标服务器返回 JSONP 格式</h3>\n<p>当目标服务器返回的是 JSONP 格式时，<em><strong>仍然使用 axios 请求中转服务器</strong></em>，不同于场景一的是，在返回的 JSONP 数据中需要<strong>剔除回调函数并转化为 JSON 格式</strong>。</p>\n<p>那么可总结为，使用 axios 转发模拟带 headers 验证的 JSONP 时，<em><strong>必须以 ajax 请求中转服务器</strong></em>。我们根据目标服务器返回给中转服务器的数据类型来决定是否在中转服务器中添加<strong>剔除回调函数并转化为 JSON 格式</strong>这一数据处理的步骤。</p>\n<h3 id="易错点：反向代理转发请求时返回错误格式"><a class="header-anchor" href="#易错点：反向代理转发请求时返回错误格式" aria-hidden="true">#</a> 易错点：反向代理转发请求时返回错误格式</h3>\n<p>现象：<a href="https://github.com/lbwa/vue-sonar/blob/master/src/api/the-recommend.js#L49-L55" target="_blank" rel="noopener noreferrer">链接<OutboundLink/></a>高亮处 JSONP 请求中转服务器，返回格式错误</p>\n<p>原因：目标服务器只接受 ajax 请求（返回的数据不会有回调函数包裹）时，我们的网页也只能以 ajax 请求中转服务器，中转服务器转发 ajax 请求。若我们的网页使用 JSONP 来请求中转服务器，那么我们最后收到的是 ajax 类型的返回数据，并没有一个回调函数来包裹返回数据，那么就没有可执行的回调函数。即造成了格式错误。</p>\n<p>解决方案：<a href="https://github.com/lbwa/vue-sonar/blob/master/src/api/the-recommend.js#L56-L59" target="_blank" rel="noopener noreferrer">使用 axios 请求<OutboundLink/></a>后端中转服务器，返回正确格式</p>\n<h2 id="jsonp"><a class="header-anchor" href="#jsonp" aria-hidden="true">#</a> JSONP</h2>\n<p>JOSNP 意为 <code>JSON with padding</code>，本质是动态创建 script 标签的 src 属性来请求数据，因为 <code>&lt;script&gt;</code> 的 <code>src</code> 属性是可以<strong>跨域的。</strong></p>\n<p>原理：</p>\n<ol>\n<li>\n<p>首先是利用 <code>&lt;script&gt;</code> 的 <code>src</code> 属性来实现跨域。</p>\n</li>\n<li>\n<p>通过将前端方法作为<strong>参数</strong>传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信。客户端在收到返回数据时，就会执行被回调函数包裹的目标数据。</p>\n</li>\n<li>\n<p>由于使用 script 标签的 src 属性，因此<strong>只支持get方法</strong></p>\n</li>\n</ol>\n<p><strong>直接</strong>使用 jsonp 方法访问源地址，这在<strong>没有 referer 验证的情况下</strong>可返回正确的数据，若需要 referer 验证(在 Chrome Devtool network 选项直接点击链接是否能返回正确数据)，那么使用 axios 后端代理转发请求。因为 JSONP 本身不能伪造 headers ，反向代理的目的是<strong>伪造 header。</strong></p>\n<p>典型的 JSONP 请求<a href="https://github.com/lbwa/vue-sonar/blob/master/src/api/the-artist.js#L4-L20" target="_blank" rel="noopener noreferrer">点我<OutboundLink/></a></p>\n<h3 id="jsonp-的局限性"><a class="header-anchor" href="#jsonp-的局限性" aria-hidden="true">#</a> JSONP 的局限性</h3>\n<ol>\n<li>\n<p>只支持 GET 请求</p>\n</li>\n<li>\n<p>因为是通过 <code>&lt;script&gt;</code> 的 <code>src</code> 属性来实现跨域的，那么我们是无法验证请求数据的安全性，那么我们必须确保请求的域的安全性</p>\n</li>\n<li>\n<p>必须另外添加计时器来判断是否请求成功</p>\n</li>\n</ol>\n<h2 id="参考"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>\n<p><a href="https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy" target="_blank" rel="noopener noreferrer">MDN Same-Origin Policy<OutboundLink/></a></p>\n<p><a href="https://html.spec.whatwg.org/multipage/origin.html#concept-origin" target="_blank" rel="noopener noreferrer">HTML Standard Concept-origin<OutboundLink/></a></p>\n<p><a href="https://juejin.im/post/5a6320d56fb9a01cb64ee191" target="_blank" rel="noopener noreferrer">我知道的跨域与安全<OutboundLink/></a></p>\n<p><a href="https://segmentfault.com/a/1190000012469713#articleHeader12" target="_blank" rel="noopener noreferrer">ajax 跨域解决方案<OutboundLink/></a></p>\n<p><a href="https://www.zhihu.com/question/265985355" target="_blank" rel="noopener noreferrer">如何解决前后端分离中的 ajax 跨域问题<OutboundLink/></a></p>\n<p><a href="https://www.zhihu.com/question/264546160" target="_blank" rel="noopener noreferrer">常见 jsonp 出现格式错误的原因<OutboundLink/></a></p>\n'}],error:null,serverRendered:!0}</script><script defer src="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js"></script><script defer src="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js"></script><script defer src="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js"></script><script defer src="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js"></script><script defer src="/_nuxt/vendor.13de21511613edf061b2.js"></script><script defer src="/_nuxt/app.5a4fa6b8fcf73db97515.js"></script>