<!doctype html><html data-n-head="lang" data-n-head-ssr lang="zh"><meta data-n-head="true" content="IE=edge,chrome=1" http-equiv='"X-UA-Compatible'><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" name="viewport"><meta data-n-head="true" content="bowen blog, bowen 博客, vuejs, reactjs, ssr, 前端开发, 前端 , web开发, nodejs, github" name="keywords"><meta data-n-head="true" content="一个分享代码经历的地方" name="description" data-hid="description"><meta data-n-head="true" content="yes" name="apple-mobile-web-app-capable"><meta data-n-head="true" content="black" name="apple-mobile-web-app-status-bar-style"><meta data-n-head="true" content="yes" name="mobile-web-app-capable" data-hid="mobile-web-app-capable"><meta data-n-head="true" content="Bowen Blog" name="apple-mobile-web-app-title" data-hid="apple-mobile-web-app-title"><meta data-n-head="true" content="Bowen" name="author" data-hid="author"><meta data-n-head="true" content="#24292e" name="theme-color" data-hid="theme-color"><meta data-n-head="true" content="website" name="og:type" data-hid="og:type" property="og:type"><meta data-n-head="true" content="Bowen Blog" name="og:title" data-hid="og:title" property="og:title"><meta data-n-head="true" content="A place which is used to share programming experiences" name="og:description" data-hid="og:description" property="og:description"><title data-n-head="true">解析 event loops | Bowen Blog</title><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="/_nuxt/manifest.2108b1d4.json" rel="manifest" data-n-head="true"><link href="/_nuxt/icons/icon_64.e20A200w20w.png" rel="shortcut icon" data-n-head="true"><link href="/_nuxt/icons/icon_512.e20A200w20w.png" rel="apple-touch-icon" data-n-head="true" sizes="512x512"><link href="https://set.sh/blog/writings/event-loop/" rel="alternate" data-n-head="true" hreflang="zh"><link href="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js" rel="preload" as="script"><link href="/_nuxt/vendor.13de21511613edf061b2.js" rel="preload" as="script"><link href="/_nuxt/app.5a4fa6b8fcf73db97515.js" rel="preload" as="script"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="preload" as="style"><link href="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js" rel="preload" as="script"><link href="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/tags/_id/index.edb9dbabb1b9c2ef81f2.js" rel="prefetch"><link href="/_nuxt/pages/index.1d0ac68e309be0e86168.js" rel="prefetch"><link href="/_nuxt/pages/blog/tags/index.2659d358b69abdfd34bf.js" rel="prefetch"><link href="/_nuxt/pages/blog/projects/index.3ff8e031c3cb4f25eaed.js" rel="prefetch"><link href="/_nuxt/pages/blog/writings/index.b016af22016e152b7231.js" rel="prefetch"><link href="/_nuxt/layouts/home.dd55e95df1c2109ebde6.js" rel="prefetch"><link href="/_nuxt/layouts/default.89ffa224d3d7769e4fbb.js" rel="prefetch"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="stylesheet"><body data-n-head=""><div id="__nuxt" data-server-rendered="true"><div class="nuxt-progress" style="width:0%;height:2px;background-color:#3eaf7c;opacity:0"></div><div id="__layout"><section class="blog sf__parent__clearfix" data-v-cac63c14><header class="header __position components-animation" data-v-13c46026 data-v-cac63c14><nav class="mobile-navigator" data-v-13c46026 data-v-d4cae7a6><label class="label-line" data-v-d4cae7a6><span class="__position label-line line-top" data-v-d4cae7a6><span class="__position line-crust line-crust-top" data-v-d4cae7a6></span></span><span class="__position label-line line-bottom" data-v-d4cae7a6><span class="__position line-crust line-crust-bottom" data-v-d4cae7a6></span></span></label></nav><nav class="navigator __position grid" data-v-13c46026 role="navigation"><a href="/" class="navigator-link hover-animation grid-cell" data-v-13c46026>HOME</a><a href="/blog/writings/" class="navigator-link hover-animation grid-cell" data-v-13c46026>WRITINGS</a><a href="/blog/projects/" class="navigator-link hover-animation grid-cell" data-v-13c46026>PROJECTS</a><a href="/blog/tags/" class="navigator-link hover-animation grid-cell" data-v-13c46026>TAGS</a><a href="https://github.com/lbwa" rel="noopener" target="_blank" class="navigator-link hover-animation grid-cell" data-v-13c46026>GITHUB</a></nav><div class="background-helper __position" data-v-13c46026></div></header><main class="articles-container wrapper sf__reference__layout" data-v-cac63c14 role="main"><article class="articles-main"><div class="article-header"><h1 class="article-title">解析 event loops</h1><span class="article-author">Bowen</span><span class="article-date">2018 MAR 08</span><div class="article-tags"><a href="/blog/tags/前端开发" class="article-tag">前端开发</a><a href="/blog/tags/javascript" class="article-tag">JavaScript</a><a href="/blog/tags/事件循环" class="article-tag">事件循环</a></div></div><div class="article-content"><h2 id="事件循环定义"><a href="#事件循环定义" class="header-anchor" aria-hidden="true">#</a> 事件循环定义</h2><p>单线程的实现方式就是事件循环（<code>event loop</code>）。<p>存在两种 <code>event loops</code>（[W3C][event loops]），即一种在 <code>browsing context</code> 下的事件循环，一种是在 <code>web workers</code> 下的循环。本文讨论在 <code>browsing context</code> 下的事件循环。<p>依据标准中对进程模型的流程描述（<a href="https://www.w3.org/TR/html5/webappapis.html#event-loops-processing-model" rel="noopener noreferrer" target="_blank">来源<outboundlink></a>）可得出，一个事件循环始终以一个宏任务（如有）开始，待 <code>execution context stack</code> <em><strong>为空</strong></em> 时将执行 <code>perform a microtask checkpoint</code>，即执行 <code>microtask queue</code> 中的 <code>microtasks</code>。待 <code>microtask queue</code> 清空后，将进入渲染进程，此刻浏览器应该判断是否有必要进入 <code>repaint</code> 流程。经历渲染步骤之后，一个事件循环结束。<h2 id="任务源"><a href="#任务源" class="header-anchor" aria-hidden="true">#</a> 任务源</h2><ul><li><p>宏任务（macrotask）：<ol><li><p>script<ul><li><p>整体代码（<a href="https://www.ecma-international.org/ecma-262/#script-record" rel="noopener noreferrer" target="_blank">来源<outboundlink></a>），即代码执行的基准执行上下文（<a href="/blog/writings/execution-context/">拓展阅读</a>）<li><p>该宏任务的目的在于，将整体代码段（或理解为模块）推入执行上下文栈（<code>execution context stack</code>）中。<ul><li><p>执行上下文栈初始会设置 <code>script</code> 为 <code>当前正在运行执行上下文</code>（<code>running execution context</code>），这期间可能因执行而创建新的执行上下文，那么就会依据模块内的代码不断的设置 <strong>当前正在运行执行上下文</strong>（<code>running execution context</code>），这样模块内的代码就会依次得以执行（此处主要是<a href="/blog/writings/execution-context/">执行上下文</a> 中 <code>Running execution context 的更替</code> 的实际应用）。<li><p>比如设置一些事件监听程序，一些声明，执行一些初始任务。在执行完成该任务时，会建立词法作用域等一系列相关运行参数。</ul></ul><li><p>setTimeout，setInterval，setImmediate（服务端 API）<li><p>I/O<ul><li><p>可拓展至 Web API（<a href="https://www.w3.org/TR/html5/webappapis.html#generic-task-sources" rel="noopener noreferrer" target="_blank">来源<outboundlink></a>）：<ol><li><p>DOM 操作<li><p>网络任务<ul><li>Ajax 请求</ul><li><p>history traversal<ul><li>history.back()</ul><li><p>用户交互<ul><li><p>其中包括常见 DOM2（<code>addEventListener</code>）和 DOM0（<code>onHandle</code>）级<strong>事件监听回调函数</strong>。如 <code>click</code> 事件回调函数等。<li><p>特别地，事件需要冒泡到 <code>document</code> 对象之后并且事件回调执行<strong>完成后</strong>，才算该宏任务执行完成。否则一直存在于执行上下文栈中，等待事件冒泡并事件回调完成（来源：Jake Archibald blog - <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" rel="noopener noreferrer" target="_blank">level 1 boss fight<outboundlink></a>）。</ul></ol></ul></ol><ul><li><strong>UI rendering</strong></ul><li><p>微任务（microtask）:<ol><li><p>process.nextTick（<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#process-nexttick" rel="noopener noreferrer" target="_blank">Node.js<outboundlink></a>）<li><p>Promise 原型方法（即 <code>then</code>、<code>catch</code>、<code>finally</code>）中被调用的回调函数<li><p>MutationObserver（<a href="https://dom.spec.whatwg.org/#queue-a-mutation-record" rel="noopener noreferrer" target="_blank">DOM Standard<outboundlink></a>）<ul><li>用于监听节点是否发生变化</ul><li><p>Object.observe(已废弃)</ol><li><p><strong>特别注明</strong>：在 <code>ECMAScript</code> 中称 <code>microtask</code> 为 <code>jobs</code>（<a href="http://www.ecma-international.org/ecma-262/#sec-performpromisethen" rel="noopener noreferrer" target="_blank">来源<outboundlink></a>，其中 <a href="http://www.ecma-international.org/ecma-262/#sec-enqueuejob" rel="noopener noreferrer" target="_blank">EnqueueJob<outboundlink></a>即指添加一个 <code>microtask</code>）。</ul><p><code>macrotask</code> 和 <code>microtask</code> 中的每一项都称之为一个 <strong>任务源</strong>。<p>以上分类中，每一项执行时均占用<code>当前正在运行执行上下文</code>（<code>running execution context</code>）（线程）。如，可理解为浏览器渲染线程与 JS 执行共用一个线程。<p><strong>依据标准拓展</strong>：<ul><li><p>在 <code>W3C</code> 或 <code>WHATWG</code> 中除非特别指明，否则 <code>task</code> 即是指 <code>macrotask</code>。<li><p>根据 <code>W3C</code>（<a href="https://www.w3.org/TR/html5/webappapis.html#microtask" rel="noopener noreferrer" target="_blank">来源<outboundlink></a>）关于 <code>microtask</code> 的描述，只有两种微任务类型：单独的回调函数微任务（solitary callback microtasks），复合微任务（compound microtasks）。那么即在 <code>W3C</code> 规范中<strong>所有</strong>的<strong>单独的回调函数</strong>都是<strong>微任务</strong>类型。<ul><li><p>solitary callback：Promise 原型的原型方法，即 <code>then</code>、<code>catch</code>、<code>finally</code> 能够调用单独的回调函数的方法。<li><p>compound microtask：<ol><li><p>MutationObserver（<a href="https://dom.spec.whatwg.org/#queue-a-mutation-record" rel="noopener noreferrer" target="_blank">DOM Standard - 4.3.2 步骤 5<outboundlink></a>）<li><p>process.nextTick（Only for <a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#process-nexttick" rel="noopener noreferrer" target="_blank">Node.js<outboundlink></a>）<ul><li><blockquote><p>all callbacks passed to process.nextTick() will be resolved before the event loop continues.</blockquote></ul></ol></ul><li><p>特别指明，<code>Web API</code> （event loops 章节在标准中是属于 Web API 大类）是属于宏任务类型，如 <code>Ajax</code> 属于 <code>I/O</code>（来源：<a href="https://www.w3.org/TR/html5/webappapis.html#task-queues" rel="noopener noreferrer" target="_blank">using a resource<outboundlink></a>），但 <code>Ajax</code> 调用的 <code>Promise</code> 类型回调函数都是微任务类型。</ul><h2 id="任务队列-task-queue"><a href="#任务队列-task-queue" class="header-anchor" aria-hidden="true">#</a> 任务队列 task queue</h2><p>任务队列分为 <code>宏任务队列</code> 和 <code>微任务队列</code>。一个事件循环中可能有一个或多个任务队列。因为在执行一个宏任务时，可能产生微任务调用，即产生新的微任务队列。<p><strong>相同类型</strong>的任务源的任务被调用时进入相同的任务队列，反之进入不同的任务队列。<h3 id="标准（w3c-and-whatwg）中的队列模型"><a href="#标准（w3c-and-whatwg）中的队列模型" class="header-anchor" aria-hidden="true">#</a> 标准（W3C and WHATWG）中的队列模型</h3><p><strong>注</strong>：<ul><li><p>依据标准<a href="https://www.w3.org/TR/html5/webappapis.html#microtask" rel="noopener noreferrer" target="_blank">描述<outboundlink></a>，除非特别指明是 <code>microtask queue</code>，那么我们一般常说的任务队列（<code>task queue</code>）都是指 <code>宏任务队列</code>（<code>macrotask queue</code>）。<li><p>每个事件循环都有一个 <code>当前执行中的任务</code>（<code>currently running task</code>），用于轮询队列中的任务（<code>handle reentrancy</code>）。<li><p>每个事件循环都有一个 <code>已执行 microtask 检查点标志</code>（<code>performing a microtask checkpoint flag</code>）（初始值一定为 false）表示已经执行了 <code>microtask</code> 检查点，用于阻止执行 <code>microtask checkpoint</code> 算法的可重入调用。<ol><li><p>可重入调用（<a href="https://en.wikipedia.org/wiki/Reentrancy_(computing)" rel="noopener noreferrer" target="_blank">reentrant invocation<outboundlink></a>）是指，算法在执行过程中意外中断时，在当前调用未完成的情况下被再次从头开始执行。一旦可重入执行完成，上一次被中断的调用将会恢复执行。<li><p>设置该检查点的原因是：<ul><li>执行微任务时，可能会调用其他回调函数，当其他回调函数时，并在弹出执行上下文栈时，会断言当前执行上下文栈是否为空，若为空时，那么就会再一次执行 <code>microtask checkpoint</code>（来源：<a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint" rel="noopener noreferrer" target="_blank">perform a microtask checkpoint - step 2.3<outboundlink></a>、<a href="https://html.spec.whatwg.org/multipage/webappapis.html#clean-up-after-running-script" rel="noopener noreferrer" target="_blank">clean up after running script<outboundlink></a>），若没有设置检查点执行标志的话就会再次进入 <code>microtask queue</code> 重复执行 <code>microtask</code>。</ul></ol></ul><p>（<a href="https://www.w3.org/TR/html5/webappapis.html#event-loops-processing-model" rel="noopener noreferrer" target="_blank">来源<outboundlink></a>）<ol><li><p>在 <code>browsing context</code> 事件循环的情况下（与第 8 步并列），选择当前 <code>task queue</code> 中<strong>最早</strong>加入的 task。如果没有任务被选中（即当前 <code>task queue</code> 为空），那么直接跳转到第 6 步 <code>Microtasks</code><ul><li>如 <code>Ajax</code> 请求返回数据时，若当前 <code>task queue</code> 为空时，将直接跳转执行回调函数微任务。</ul><li><p>设置当前事件循环的 <code>当前执行中的任务</code> 为第 1 步被选出的 task。<li><p><code>Run</code>：执行当前被选出的 task（即 task 进入最上层<a href="/blog/writings/execution-context/">执行上下文栈</a> <code>execution context stack</code>）。<li><p>重置当前事件循环的 <code>当前执行中的任务</code> 为默认值 null。<li><p>从当前的 <code>task queue</code> 中移除在第 3 步执行过的任务。<li><p><code>Microtasks</code>：执行 <code>microtask</code> 检查点。<ul><li><p>当 <code>已执行 microtask 检查点标志</code> 为 false 时：<ol><li><p>设置 <code>已执行 microtask 检查点标志</code> 为 true。<li><p><code>操作（handling) microtask 队列</code>：在当前 <code>microtask queue</code> 为空时，跳转到步骤 <code>Done</code> 之后。<li><p>选中 <code>microtask queue</code> 中最早加入的 <code>microtask</code>。<li><p>设置当前事件循环的 <code>当前执行中的任务</code> 值为上一步选中的 <code>microtask</code>。<li><p><code>Run</code>：执行选中的 <code>microtask</code>（进入最上层<a href="/blog/writings/execution-context/">执行上下文栈</a>（来源1：<a href="https://html.spec.whatwg.org/#enqueuejob(queuename,-job,-arguments):queue-a-microtask" rel="noopener noreferrer" target="_blank">HTML Standard EnqueueJob 7.6<outboundlink></a>、来源2：<a href="http://www.ecma-international.org/ecma-262/#sec-enqueuejob" rel="noopener noreferrer" target="_blank">ECMAScript EnqueueJob 步骤4<outboundlink></a>））。<li><p>重置置当前事件循环的 <code>当前执行中的任务</code> 值为 null。<li><p>从 <code>microtask queue</code> 中移除第 5 步 <code>Run</code> 被执行的 <code>microtask</code>，回到第 3 步 <code>操作（handling) microtask 队列</code>。<ul><li><strong>重点</strong>：为在一个事件循环中，总是要<strong>清空</strong>当前事件循环中的微任务队列<strong>才会进行重渲染</strong>（<code>Vue.js</code> 的 DOM 更新原理）。</ul><li><p><code>Done</code>：对于每一个 <code>responsible event loop</code> 是当前事件循环的环境设置对象（<code>environment setting object</code>），向它（环境设置对象）告知关于 <code>rejected</code> 状态的 <code>Promise</code> 对象的信息。<ul><li><p>个人理解为触发浏览器 <code>uncaught</code> 事件，并抛出 <code>unhandled promise rejections</code> 错误（<a href="https://www.w3.org/TR/html5/webappapis.html#notify-about-rejected-promises" rel="noopener noreferrer" target="_blank">W3C<outboundlink></a>）。<li><p>此步骤主要是向开发者告知存在未被捕获的 <code>rejected</code> 状态的 <code>Promise</code>。</ul><li><p>执行并清空 <code>Indexed Database</code>（用于本地存储数据的 API） 的修改请求。<li><p>重置 <code>已执行 microtask 检查点标志</code> 为 false。</ol><li><p>当一个复合微任务（<code>compound microtask</code>）执行时，客户端必须去执行一系列的复合微任务的<code>子任务</code>（subtask）<ol><li><p>设置 parent 为当前事件循环的 <code>当前执行中的任务</code>。<li><p>设置 <code>子任务</code> 为一个由一系列给定步骤组成的新 microtask。<li><p>设置 <code>当前执行中的任务</code> 为 <code>子任务</code>。这种微任务的任务源是微任务类型的任务源。这是一个复合微任务的 <code>子任务</code>。<li><p>执行 <code>子任务</code>（进入<a href="/blog/writings/execution-context/">执行上下文栈</a>）。<li><p>重置当前事件循环的 <code>当前执行中的任务</code> 为 parent。</ol></ul><li><p>更新 DOM 渲染。<ul><li>一个宏任务 task <strong>至此</strong>整体执行结束（包含调用，执行，重渲染），也是一个<strong>事件循环结束</strong>。</ul><li><p>（与第 1 步并列）如果当前的事件循环是 <code>web works</code> 的事件循环，并且在当前事件循环中的 <code>task queue</code> 为空，并且 <code>WorkerGlobalScope</code> 对象的 <code>closing</code> 为 true，那么将摧毁当前事件循环，并取消以上的事件循环步骤，并恢复执行一个 <code>web worker</code> 的步骤。<li><p>回到第 1 步执行下一个事件循环。</ol><h3 id="示例"><a href="#示例" class="header-anchor" aria-hidden="true">#</a> 示例</h3><p>以一个示例讲解事件循环：<pre class="language-js" v-pre><code><span class="token comment">// script</span>
<span class="token comment">// 1</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'I am from script beginning'</span><span class="token punctuation">)</span>

<span class="token comment">// 2</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> <span class="token comment">// 该匿名函数称为匿名函数a</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'I am from setTimeout'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>

<span class="token comment">// 3</span>
<span class="token keyword">const</span> ins <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'I am from internal part'</span><span class="token punctuation">)</span>
  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">// 4</span>
ins
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'I am from 1st ins.then()'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'I am from 2nd ins.then()'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token comment">// 5</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'I am from script bottom'</span><span class="token punctuation">)</span>
</code></pre><p>以上整个代码段即是，<code>macro-task</code> 中的 <code>script</code> 任务源。<p>执行原理（依据 Chrome 66 的 V8 实现）如下：<ol><li><p>整个代码段 <code>script</code> 进入执行上下文栈（亦称调用栈，<code>call stack</code>（<a href="/blog/writings/execution-context/">来源</a>）），执行 1 处代码调用 <code>console.log</code> 函数，该函数进入调用栈，之前 <code>script</code> 执行上下文执行暂停（冻结），转交执行权给 <code>console.log</code>。<code>console.log</code>成为<a href="/blog/writings/execution-context/">当前执行中的执行上下文</a>（<code>running execution context</code>）。<code>console.log</code> 执行完成立即弹出调用栈，<code>script</code> 恢复执行。<li><p><code>setTimeout</code> 是一个任务分发器，该函数本身会立即执行，延迟执行的是其中传入的参数（匿名函数 a）。<code>script</code> 暂停执行，内部建立一个 1 秒计时器。<code>script</code> 恢复执行接下来的代码。1 秒后，再将匿名函数 a 插入宏任务队列（根据宏任务队列是否有之前加入的宏任务，可能不会立即执行）。<li><p>声明恒定变量 <code>ins</code>，并初始化为 <code>Promise</code> 实例。特别地，<code>Promise</code> 内部代码会在本轮事件循环立即执行。那么此时， <code>script</code> 冻结，开始执行 <code>console.log</code>，<code>console.log</code> 弹出调用栈后，<code>resolve()</code> 进入调用栈，将 <code>Promise</code> 状态 <code>resolved</code>，并之后弹出调用栈，此时恢复 script 执行。<li><p>因为第 3 步，已经在本轮宏任务完成前 <code>resolved</code> ，否则，将跳过第 4 步向本轮事件循环的微任务队列添加回调函数（<a href="https://promisesaplus.com/" rel="noopener noreferrer" target="_blank">来源<outboundlink></a>）。调用 <code>ins</code> 的 <code>then</code> 方法，将第一个 <code>then</code> 中回调添加到 <code>微任务队列</code>，继续执行，将第二个 <code>then</code> 中回调添加到 <code>微任务队列</code>。<li><p>如同 1 时的执行原理。<li><p><code>script</code> 宏任务执行完成，弹出执行上下文栈。此时，微任务队列中有两个 <code>then</code> 加入的回调函数等待执行。另外，若距 2 超过 1 秒钟，那么宏任务队列中有一个匿名函数 a 等待执行，否则，此时宏任务队列为空。<li><p>在当前宏任务执行完成并弹出调用栈后，开始<strong>清空</strong>因宏任务执行而产生的微任务队列。首先执行 <code>console.log('I am from 1st ins.then()')</code>，之后执行 <code>console.log('I am from 2nd ins.then()')</code>。<li><p>微任务队列清空后，开始调用下一宏任务（即进入下一个事件循环）或等待下一宏任务加入任务队列。此时，在 2 中计时 1 秒后，加入匿名函数 a 至宏任务队列，此时，因之前宏任务 script 执行完成而清空，那么将匿名函数 a 加入调用栈执行，输出 <code>I am from setTimeout</code>。</ol><p><strong>注</strong>：<code>JavaScript</code> 中在某一函数内部调用另一函数时，会暂停（冻结）当前函数的执行，并将当前函数的执行权转移给新的被调用的函数（具体解析见<a href="/blog/writings/execution-context/">拓展阅读</a>）。<p>示例总结：<ol><li><p><strong>在一个代码段（或理解为一个模块）中</strong>，所有的代码都是基于一个 <code>script</code> 宏任务进行的。<li><p>在当前宏任务执行完成后，<strong>必须</strong>要清空因执行宏任务而产生的<code>微任务队列</code>。<li><p>只有当前微任务队列清空后，才会调用下一个宏任务队列中的任务。即进入下一个事件循环。<li><p><code>new Promise</code> 时，<code>Promise</code> 参数中的匿名函数是<strong>立即执行</strong>的。被添加进<code>微任务队列</code>的是 <code>then</code> 中的回调函数。<ul><li><strong>特别地</strong>，只有 <code>Promise</code> 中的状态为 <code>resolved</code> 或 <code>rejected</code> 后（<a href="https://promisesaplus.com/#point-26" rel="noopener noreferrer" target="_blank">Promise 标准<outboundlink></a>），才会调用 <code>Promise</code> 的原型方法（即 <a href="https://promisesaplus.com/#point-26" rel="noopener noreferrer" target="_blank">then<outboundlink></a>、<code>catch</code>（因为是 <code>then</code> 的<a href="https://www.ecma-international.org/ecma-262/#sec-promise.prototype.catch" rel="noopener noreferrer" target="_blank">语法糖<outboundlink></a>，所以与 <code>then</code> 同理）、<code>finally</code>（<code>onfinally</code>时<a href="https://tc39.github.io/ecma262/#sec-promise.prototype.finally" rel="noopener noreferrer" target="_blank">触发<outboundlink></a>）），才会将回调函数到添加微任务队列中。</ul><li><p><code>setTimeout</code> 是作为任务分发器的存在，他自身执行会创建一个计时器，只有待计时器结束后，才会将 <code>setTimeout</code> 中的第一参数函数添加至<code>宏任务队列</code>。换一种方式理解，<code>setTimeout</code> 中的函数<strong>一定不是在当前事件循环</strong>中被调用。</ol><p>以下是在客户端（Node.js 可能有不同结果）的输入结果：<pre class="language-markup" v-pre><code>I am from script beginning
I am from internal part
I am from script bottom
I am from 1st ins.then()
I am from 2nd ins.then()
I am from setTimeout
</code></pre><h2 id="事件循环拓展应用-——-异步操作"><a href="#事件循环拓展应用-——-异步操作" class="header-anchor" aria-hidden="true">#</a> 事件循环拓展应用 —— 异步操作</h2><ol><li><p>定时任务：setTimeout，setInterval<li><p>请求数据：Ajax 请求，图片加载<li><p>事件绑定</ol><p>一般地，在 JS 开发过程中，凡是可能造成代码阻塞的地方都可根据实际情况考虑使用异步操作。比如，数据获取等等。<h2 id="参考"><a href="#参考" class="header-anchor" aria-hidden="true">#</a> 参考</h2><p><code>JavaScript 语言精粹(修订版)</code><p><a href="https://www.w3.org/TR/html5/webappapis.html#event-loops" rel="noopener noreferrer" target="_blank">w3c Event loop<outboundlink></a><p><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops" rel="noopener noreferrer" target="_blank">HTML5 Standard<outboundlink></a><p><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues" rel="noopener noreferrer" target="_blank">ECMA Jobs and Job Queues<outboundlink></a><p><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" rel="noopener noreferrer" target="_blank">Tasks, microtasks, queues and schedules<outboundlink></a><p><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" rel="noopener noreferrer" target="_blank">Great talk at JSConf 2014 on the event loop<outboundlink></a></div></article><button data-v-e85d20b2 data-v-e85d20b2 class="floating-btn __position" style="display:none"><svg class="icon-rocket" data-v-e85d20b2 viewBox="0 0 512 512"><path d="M256 421.6c-18.1 0-33.2-6.8-42.9-10.9-5.4-2.3-11.3 1.8-10.9 7.6l3.5 51c.2 3.1 3.8 4.7 6.3 2.8l14.5-11c1.8-1.4 4.5-.9 5.7 1l20.5 32.1c1.5 2.4 5.1 2.4 6.6 0l20.5-32.1c1.2-1.9 3.9-2.4 5.7-1l14.5 11c2.5 1.9 6.1.3 6.3-2.8l3.5-51c.4-5.8-5.5-10-10.9-7.6-9.8 4.1-24.8 10.9-42.9 10.9z" data-v-e85d20b2></path><path d="M397.7 293.1l-48-49.1c0-158-93.2-228-93.2-228s-94.1 70-94.1 228l-48 49.1c-1.8 1.8-2.6 4.5-2.2 7.1L130.6 412c.9 5.7 7.1 8.5 11.8 5.4l67.1-45.4s20.7 20 47.1 20c26.4 0 46.1-20 46.1-20l67.1 45.4c4.6 3.1 10.8.3 11.8-5.4l18.5-111.9c.2-2.6-.6-5.2-2.4-7zM256.5 192c-17 0-30.7-14.3-30.7-32s13.8-32 30.7-32c17 0 30.7 14.3 30.7 32s-13.7 32-30.7 32z" data-v-e85d20b2></path></svg></button></main><footer class="blog-footer sf__main__layout grid col grid-jc-center" data-v-1044ad0a data-v-cac63c14><div class="footer-info" data-v-1044ad0a>Copyright © 2018 <a href="https://github.com/lbwa" rel="noopener" target="_blank" class="author" data-v-1044ad0a>Bowen</a></div></footer><section class="loading-wrapper grid col grid-center grid-jc-center" data-v-cac63c14 style="display:none"><div class="loading"><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div></div><a class="loading-tips">Loading</a></section></section></div></div><script type="text/javascript">window.__NUXT__={layout:"blog",data:[{menu:[{errno:0,to:"writings/dom-location",title:"获取 Element 在 document 中的位置信息",author:"Bowen",date:"2018 SEP 01",tags:["前端开发","CSS"]},{errno:0,to:"writings/spa-and-mpa",title:"SPA 与 MPA 的比较与优化",author:"Bowen",date:"2018 AUG 04",tags:["前端开发","SPA","MPA","skeleton"]},{errno:0,to:"writings/async-function-in-js",title:"Event loops 中的 AsyncFunction",author:"Bowen",date:"2018 JUL 26",tags:["JavaScript","async","事件循环"]},{errno:0,to:"writings/pwa-fundamentals",title:"PWA 基础",author:"Bowen",date:"2018 JUL 07",tags:["前端开发","PWA"]},{errno:0,to:"writings/js-design-pattern",title:"JS 设计模式",author:"Bowen",date:"2018 JUN 12",tags:["前端开发","设计模式"]},{errno:0,to:"writings/http-request",title:"HTTP 协议请求首部",author:"Bowen",date:"2018 JUN 08",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-response",title:"HTTP 协议响应首部",author:"Bowen",date:"2018 JUN 07",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-protocol",title:"HTTP 协议",author:"Bowen",date:"2018 JUN 06",tags:["前端开发","网络请求"]},{errno:0,to:"writings/execution-context",title:"JS 执行上下文",author:"Bowen",date:"2018 MAY 07",tags:["前端开发","JavaScript","执行上下文"]},{errno:0,to:"writings/vue-lifecycle-and-slots",title:"对 Vue 插槽和生命周期的一点思考",author:"Bowen",date:"2018 APR 24",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/learning-vue-unit-test",title:"总结如何进行单元测试",author:"Bowen",date:"2018 APR 21",tags:["前端开发","Vue.js","应用测试"]},{errno:0,to:"writings/cross-domain-solution",title:"客户端跨域解决方案",author:"Bowen",date:"2018 APR 19",tags:["前端开发","网络请求"]},{errno:0,to:"writings/css-bfc",title:"探究 BFC 以及闭合浮动原理",author:"Bowen",date:"2018 MAR 29",tags:["前端开发","CSS"]},{errno:0,to:"writings/vue.js-reusability-and-composition",title:"学习 Vue.js 可复用性和组合",author:"Bowen",date:"2018 MAR 12",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/event-loop",title:"解析 event loops",author:"Bowen",date:"2018 MAR 08",tags:["前端开发","JavaScript","事件循环"]},{errno:0,to:"writings/learning-vuex",title:"学习 vuex 基础",author:"Bowen",date:"2018 MAR 06",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/compare-commonjs-with-esm",title:"比较 CommonJS 与 ES6 Module 语法",author:"Bowen",date:"2018 FEB 27",tags:["前端开发","JavaScript","模块"]},{errno:0,to:"writings/learning-vuejs-essentials",title:"学习 Vue.js 基础",author:"Bowen",date:"2018 FEB 24",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/keyword-this",title:"理解 this 的指向",author:"Bowen",date:"2018 FEB 06",tags:["前端开发","JavaScript"]}]},{title:"解析 event loops",date:"2018 MAR 08",author:"Bowen",tags:["前端开发","JavaScript","事件循环"],content:'<h2 id="事件循环定义"><a class="header-anchor" href="#事件循环定义" aria-hidden="true">#</a> 事件循环定义</h2>\n<p>单线程的实现方式就是事件循环（<code>event loop</code>）。</p>\n<p>存在两种 <code>event loops</code>（[W3C][event loops]），即一种在 <code>browsing context</code> 下的事件循环，一种是在 <code>web workers</code> 下的循环。本文讨论在 <code>browsing context</code> 下的事件循环。</p>\n<p>依据标准中对进程模型的流程描述（<a href="https://www.w3.org/TR/html5/webappapis.html#event-loops-processing-model" target="_blank" rel="noopener noreferrer">来源<OutboundLink/></a>）可得出，一个事件循环始终以一个宏任务（如有）开始，待 <code>execution context stack</code>  <em><strong>为空</strong></em> 时将执行 <code>perform a microtask checkpoint</code>，即执行 <code>microtask queue</code> 中的 <code>microtasks</code>。待 <code>microtask queue</code> 清空后，将进入渲染进程，此刻浏览器应该判断是否有必要进入 <code>repaint</code> 流程。经历渲染步骤之后，一个事件循环结束。</p>\n<h2 id="任务源"><a class="header-anchor" href="#任务源" aria-hidden="true">#</a> 任务源</h2>\n<ul>\n<li>\n<p>宏任务（macrotask）：</p>\n<ol>\n<li>\n<p>script</p>\n<ul>\n<li>\n<p>整体代码（<a href="https://www.ecma-international.org/ecma-262/#script-record" target="_blank" rel="noopener noreferrer">来源<OutboundLink/></a>），即代码执行的基准执行上下文（<a href="/blog/writings/execution-context/">拓展阅读</a>）</p>\n</li>\n<li>\n<p>该宏任务的目的在于，将整体代码段（或理解为模块）推入执行上下文栈（<code>execution context stack</code>）中。</p>\n<ul>\n<li>\n<p>执行上下文栈初始会设置 <code>script</code> 为 <code>当前正在运行执行上下文</code>（<code>running execution context</code>），这期间可能因执行而创建新的执行上下文，那么就会依据模块内的代码不断的设置 <strong>当前正在运行执行上下文</strong>（<code>running execution context</code>），这样模块内的代码就会依次得以执行（此处主要是<a href="/blog/writings/execution-context/">执行上下文</a> 中 <code>Running execution context 的更替</code> 的实际应用）。</p>\n</li>\n<li>\n<p>比如设置一些事件监听程序，一些声明，执行一些初始任务。在执行完成该任务时，会建立词法作用域等一系列相关运行参数。</p>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>setTimeout，setInterval，setImmediate（服务端 API）</p>\n</li>\n<li>\n<p>I/O</p>\n<ul>\n<li>\n<p>可拓展至 Web API（<a href="https://www.w3.org/TR/html5/webappapis.html#generic-task-sources" target="_blank" rel="noopener noreferrer">来源<OutboundLink/></a>）：</p>\n<ol>\n<li>\n<p>DOM 操作</p>\n</li>\n<li>\n<p>网络任务</p>\n<ul>\n<li>Ajax 请求</li>\n</ul>\n</li>\n<li>\n<p>history traversal</p>\n<ul>\n<li>history.back()</li>\n</ul>\n</li>\n<li>\n<p>用户交互</p>\n<ul>\n<li>\n<p>其中包括常见 DOM2（<code>addEventListener</code>）和 DOM0（<code>onHandle</code>）级<strong>事件监听回调函数</strong>。如 <code>click</code> 事件回调函数等。</p>\n</li>\n<li>\n<p>特别地，事件需要冒泡到 <code>document</code> 对象之后并且事件回调执行<strong>完成后</strong>，才算该宏任务执行完成。否则一直存在于执行上下文栈中，等待事件冒泡并事件回调完成（来源：Jake Archibald blog - <a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener noreferrer">level 1 boss fight<OutboundLink/></a>）。</p>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n</ol>\n<ul>\n<li><strong>UI rendering</strong></li>\n</ul>\n</li>\n<li>\n<p>微任务（microtask）:</p>\n<ol>\n<li>\n<p>process.nextTick（<a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#process-nexttick" target="_blank" rel="noopener noreferrer">Node.js<OutboundLink/></a>）</p>\n</li>\n<li>\n<p>Promise 原型方法（即 <code>then</code>、<code>catch</code>、<code>finally</code>）中被调用的回调函数</p>\n</li>\n<li>\n<p>MutationObserver（<a href="https://dom.spec.whatwg.org/#queue-a-mutation-record" target="_blank" rel="noopener noreferrer">DOM Standard<OutboundLink/></a>）</p>\n<ul>\n<li>用于监听节点是否发生变化</li>\n</ul>\n</li>\n<li>\n<p>Object.observe(已废弃)</p>\n</li>\n</ol>\n</li>\n<li>\n<p><strong>特别注明</strong>：在 <code>ECMAScript</code> 中称 <code>microtask</code> 为 <code>jobs</code>（<a href="http://www.ecma-international.org/ecma-262/#sec-performpromisethen" target="_blank" rel="noopener noreferrer">来源<OutboundLink/></a>，其中 <a href="http://www.ecma-international.org/ecma-262/#sec-enqueuejob" target="_blank" rel="noopener noreferrer">EnqueueJob<OutboundLink/></a> 即指添加一个 <code>microtask</code>）。</p>\n</li>\n</ul>\n<p><code>macrotask</code> 和 <code>microtask</code> 中的每一项都称之为一个 <strong>任务源</strong>。</p>\n<p>以上分类中，每一项执行时均占用<code>当前正在运行执行上下文</code>（<code>running execution context</code>）（线程）。如，可理解为浏览器渲染线程与 JS 执行共用一个线程。</p>\n<p><strong>依据标准拓展</strong>：</p>\n<ul>\n<li>\n<p>在 <code>W3C</code> 或 <code>WHATWG</code> 中除非特别指明，否则 <code>task</code> 即是指 <code>macrotask</code>。</p>\n</li>\n<li>\n<p>根据 <code>W3C</code>（<a href="https://www.w3.org/TR/html5/webappapis.html#microtask" target="_blank" rel="noopener noreferrer">来源<OutboundLink/></a>）关于 <code>microtask</code> 的描述，只有两种微任务类型：单独的回调函数微任务（solitary callback microtasks），复合微任务（compound microtasks）。那么即在 <code>W3C</code> 规范中<strong>所有</strong>的<strong>单独的回调函数</strong>都是<strong>微任务</strong>类型。</p>\n<ul>\n<li>\n<p>solitary callback：Promise 原型的原型方法，即 <code>then</code>、<code>catch</code>、<code>finally</code> 能够调用单独的回调函数的方法。</p>\n</li>\n<li>\n<p>compound microtask：</p>\n<ol>\n<li>\n<p>MutationObserver（<a href="https://dom.spec.whatwg.org/#queue-a-mutation-record" target="_blank" rel="noopener noreferrer">DOM Standard - 4.3.2 步骤 5<OutboundLink/></a>）</p>\n</li>\n<li>\n<p>process.nextTick（Only for <a href="https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#process-nexttick" target="_blank" rel="noopener noreferrer">Node.js<OutboundLink/></a>）</p>\n<ul>\n<li>\n<blockquote>\n<p>all callbacks passed to process.nextTick() will be resolved before the event loop continues.</p>\n</blockquote>\n</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>特别指明，<code>Web API</code> （event loops 章节在标准中是属于 Web API 大类）是属于宏任务类型，如 <code>Ajax</code> 属于 <code>I/O</code>（来源：<a href="https://www.w3.org/TR/html5/webappapis.html#task-queues" target="_blank" rel="noopener noreferrer">using a resource<OutboundLink/></a>），但 <code>Ajax</code> 调用的 <code>Promise</code> 类型回调函数都是微任务类型。</p>\n</li>\n</ul>\n<h2 id="任务队列-task-queue"><a class="header-anchor" href="#任务队列-task-queue" aria-hidden="true">#</a> 任务队列 task queue</h2>\n<p>任务队列分为 <code>宏任务队列</code> 和 <code>微任务队列</code>。一个事件循环中可能有一个或多个任务队列。因为在执行一个宏任务时，可能产生微任务调用，即产生新的微任务队列。</p>\n<p><strong>相同类型</strong>的任务源的任务被调用时进入相同的任务队列，反之进入不同的任务队列。</p>\n<h3 id="标准（w3c-and-whatwg）中的队列模型"><a class="header-anchor" href="#标准（w3c-and-whatwg）中的队列模型" aria-hidden="true">#</a> 标准（W3C and WHATWG）中的队列模型</h3>\n<p><strong>注</strong>：</p>\n<ul>\n<li>\n<p>依据标准<a href="https://www.w3.org/TR/html5/webappapis.html#microtask" target="_blank" rel="noopener noreferrer">描述<OutboundLink/></a>，除非特别指明是 <code>microtask queue</code>，那么我们一般常说的任务队列（<code>task queue</code>）都是指 <code>宏任务队列</code>（<code>macrotask queue</code>）。</p>\n</li>\n<li>\n<p>每个事件循环都有一个 <code>当前执行中的任务</code>（<code>currently running task</code>），用于轮询队列中的任务（<code>handle reentrancy</code>）。</p>\n</li>\n<li>\n<p>每个事件循环都有一个 <code>已执行 microtask 检查点标志</code>（<code>performing a microtask checkpoint flag</code>）（初始值一定为 false）表示已经执行了 <code>microtask</code> 检查点，用于阻止执行 <code>microtask checkpoint</code> 算法的可重入调用。</p>\n<ol>\n<li>\n<p>可重入调用（<a href="https://en.wikipedia.org/wiki/Reentrancy_(computing)" target="_blank" rel="noopener noreferrer">reentrant invocation<OutboundLink/></a>）是指，算法在执行过程中意外中断时，在当前调用未完成的情况下被再次从头开始执行。一旦可重入执行完成，上一次被中断的调用将会恢复执行。</p>\n</li>\n<li>\n<p>设置该检查点的原因是：</p>\n<ul>\n<li>执行微任务时，可能会调用其他回调函数，当其他回调函数时，并在弹出执行上下文栈时，会断言当前执行上下文栈是否为空，若为空时，那么就会再一次执行 <code>microtask checkpoint</code>（来源：<a href="https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint" target="_blank" rel="noopener noreferrer">perform a microtask checkpoint - step 2.3<OutboundLink/></a>、<a href="https://html.spec.whatwg.org/multipage/webappapis.html#clean-up-after-running-script" target="_blank" rel="noopener noreferrer">clean up after running script<OutboundLink/></a>），若没有设置检查点执行标志的话就会再次进入 <code>microtask queue</code> 重复执行 <code>microtask</code>。</li>\n</ul>\n</li>\n</ol>\n</li>\n</ul>\n<p>（<a href="https://www.w3.org/TR/html5/webappapis.html#event-loops-processing-model" target="_blank" rel="noopener noreferrer">来源<OutboundLink/></a>）</p>\n<ol>\n<li>\n<p>在 <code>browsing context</code> 事件循环的情况下（与第 8 步并列），选择当前 <code>task queue</code> 中<strong>最早</strong>加入的 task。如果没有任务被选中（即当前 <code>task queue</code> 为空），那么直接跳转到第 6 步 <code>Microtasks</code></p>\n<ul>\n<li>如 <code>Ajax</code> 请求返回数据时，若当前 <code>task queue</code> 为空时，将直接跳转执行回调函数微任务。</li>\n</ul>\n</li>\n<li>\n<p>设置当前事件循环的 <code>当前执行中的任务</code> 为第 1 步被选出的 task。</p>\n</li>\n<li>\n<p><code>Run</code>：执行当前被选出的 task（即 task 进入最上层<a href="/blog/writings/execution-context/">执行上下文栈</a> <code>execution context stack</code>）。</p>\n</li>\n<li>\n<p>重置当前事件循环的 <code>当前执行中的任务</code> 为默认值 null。</p>\n</li>\n<li>\n<p>从当前的 <code>task queue</code> 中移除在第 3 步执行过的任务。</p>\n</li>\n<li>\n<p><code>Microtasks</code>：执行 <code>microtask</code> 检查点。</p>\n<ul>\n<li>\n<p>当 <code>已执行 microtask 检查点标志</code> 为 false 时：</p>\n<ol>\n<li>\n<p>设置 <code>已执行 microtask 检查点标志</code> 为 true。</p>\n</li>\n<li>\n<p><code>操作（handling) microtask 队列</code>：在当前 <code>microtask queue</code> 为空时，跳转到步骤 <code>Done</code> 之后。</p>\n</li>\n<li>\n<p>选中 <code>microtask queue</code> 中最早加入的 <code>microtask</code>。</p>\n</li>\n<li>\n<p>设置当前事件循环的 <code>当前执行中的任务</code> 值为上一步选中的 <code>microtask</code>。</p>\n</li>\n<li>\n<p><code>Run</code>：执行选中的 <code>microtask</code>（进入最上层<a href="/blog/writings/execution-context/">执行上下文栈</a>（来源1：<a href="https://html.spec.whatwg.org/#enqueuejob(queuename,-job,-arguments):queue-a-microtask" target="_blank" rel="noopener noreferrer">HTML Standard EnqueueJob 7.6<OutboundLink/></a>、来源2：<a href="http://www.ecma-international.org/ecma-262/#sec-enqueuejob" target="_blank" rel="noopener noreferrer">ECMAScript EnqueueJob 步骤4<OutboundLink/></a>））。</p>\n</li>\n<li>\n<p>重置置当前事件循环的 <code>当前执行中的任务</code> 值为 null。</p>\n</li>\n<li>\n<p>从 <code>microtask queue</code> 中移除第 5 步 <code>Run</code> 被执行的 <code>microtask</code>，回到第 3 步 <code>操作（handling) microtask 队列</code>。</p>\n<ul>\n<li><strong>重点</strong>：为在一个事件循环中，总是要<strong>清空</strong>当前事件循环中的微任务队列<strong>才会进行重渲染</strong>（<code>Vue.js</code> 的 DOM 更新原理）。</li>\n</ul>\n</li>\n<li>\n<p><code>Done</code>：对于每一个 <code>responsible event loop</code> 是当前事件循环的环境设置对象（<code>environment setting object</code>），向它（环境设置对象）告知关于 <code>rejected</code> 状态的 <code>Promise</code> 对象的信息。</p>\n<ul>\n<li>\n<p>个人理解为触发浏览器 <code>uncaught</code> 事件，并抛出 <code>unhandled promise rejections</code> 错误（<a href="https://www.w3.org/TR/html5/webappapis.html#notify-about-rejected-promises" target="_blank" rel="noopener noreferrer">W3C<OutboundLink/></a>）。</p>\n</li>\n<li>\n<p>此步骤主要是向开发者告知存在未被捕获的 <code>rejected</code> 状态的 <code>Promise</code>。</p>\n</li>\n</ul>\n</li>\n<li>\n<p>执行并清空 <code>Indexed Database</code>（用于本地存储数据的 API） 的修改请求。</p>\n</li>\n<li>\n<p>重置 <code>已执行 microtask 检查点标志</code> 为 false。</p>\n</li>\n</ol>\n</li>\n<li>\n<p>当一个复合微任务（<code>compound microtask</code>）执行时，客户端必须去执行一系列的复合微任务的<code>子任务</code>（subtask）</p>\n<ol>\n<li>\n<p>设置 parent 为当前事件循环的 <code>当前执行中的任务</code>。</p>\n</li>\n<li>\n<p>设置 <code>子任务</code> 为一个由一系列给定步骤组成的新 microtask。</p>\n</li>\n<li>\n<p>设置 <code>当前执行中的任务</code> 为 <code>子任务</code>。这种微任务的任务源是微任务类型的任务源。这是一个复合微任务的 <code>子任务</code>。</p>\n</li>\n<li>\n<p>执行 <code>子任务</code>（进入<a href="/blog/writings/execution-context/">执行上下文栈</a>）。</p>\n</li>\n<li>\n<p>重置当前事件循环的 <code>当前执行中的任务</code> 为 parent。</p>\n</li>\n</ol>\n</li>\n</ul>\n</li>\n<li>\n<p>更新 DOM 渲染。</p>\n<ul>\n<li>一个宏任务 task <strong>至此</strong>整体执行结束（包含调用，执行，重渲染），也是一个<strong>事件循环结束</strong>。</li>\n</ul>\n</li>\n<li>\n<p>（与第 1 步并列）如果当前的事件循环是 <code>web works</code> 的事件循环，并且在当前事件循环中的 <code>task queue</code> 为空，并且 <code>WorkerGlobalScope</code> 对象的 <code>closing</code> 为 true，那么将摧毁当前事件循环，并取消以上的事件循环步骤，并恢复执行一个 <code>web worker</code> 的步骤。</p>\n</li>\n<li>\n<p>回到第 1 步执行下一个事件循环。</p>\n</li>\n</ol>\n<h3 id="示例"><a class="header-anchor" href="#示例" aria-hidden="true">#</a> 示例</h3>\n<p>以一个示例讲解事件循环：</p>\n<pre v-pre class="language-js"><code><span class="token comment">// script</span>\n<span class="token comment">// 1</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'I am from script beginning\'</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 2</span>\n<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span> <span class="token comment">// 该匿名函数称为匿名函数a</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'I am from setTimeout\'</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 3</span>\n<span class="token keyword">const</span> ins <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> reject<span class="token punctuation">)</span> <span class="token operator">=></span> <span class="token punctuation">{</span>\n  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'I am from internal part\'</span><span class="token punctuation">)</span>\n  <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 4</span>\nins\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'I am from 1st ins.then()\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'I am from 2nd ins.then()\'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>\n\n<span class="token comment">// 5</span>\nconsole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'I am from script bottom\'</span><span class="token punctuation">)</span>\n</code></pre>\n<p>以上整个代码段即是，<code>macro-task</code> 中的 <code>script</code> 任务源。</p>\n<p>执行原理（依据 Chrome 66 的 V8 实现）如下：</p>\n<ol>\n<li>\n<p>整个代码段 <code>script</code> 进入执行上下文栈（亦称调用栈，<code>call stack</code>（<a href="/blog/writings/execution-context/">来源</a>）），执行 1 处代码调用 <code>console.log</code> 函数，该函数进入调用栈，之前 <code>script</code> 执行上下文执行暂停（冻结），转交执行权给 <code>console.log</code>。<code>console.log</code>成为<a href="/blog/writings/execution-context/">当前执行中的执行上下文</a>（<code>running execution context</code>）。<code>console.log</code> 执行完成立即弹出调用栈，<code>script</code> 恢复执行。</p>\n</li>\n<li>\n<p><code>setTimeout</code> 是一个任务分发器，该函数本身会立即执行，延迟执行的是其中传入的参数（匿名函数 a）。<code>script</code> 暂停执行，内部建立一个 1 秒计时器。<code>script</code> 恢复执行接下来的代码。1 秒后，再将匿名函数 a 插入宏任务队列（根据宏任务队列是否有之前加入的宏任务，可能不会立即执行）。</p>\n</li>\n<li>\n<p>声明恒定变量 <code>ins</code>，并初始化为 <code>Promise</code> 实例。特别地，<code>Promise</code> 内部代码会在本轮事件循环立即执行。那么此时， <code>script</code> 冻结，开始执行 <code>console.log</code>，<code>console.log</code> 弹出调用栈后，<code>resolve()</code> 进入调用栈，将 <code>Promise</code> 状态 <code>resolved</code>，并之后弹出调用栈，此时恢复 script 执行。</p>\n</li>\n<li>\n<p>因为第 3 步，已经在本轮宏任务完成前 <code>resolved</code> ，否则，将跳过第 4 步向本轮事件循环的微任务队列添加回调函数（<a href="https://promisesaplus.com/" target="_blank" rel="noopener noreferrer">来源<OutboundLink/></a>）。调用 <code>ins</code> 的 <code>then</code> 方法，将第一个 <code>then</code> 中回调添加到 <code>微任务队列</code>，继续执行，将第二个 <code>then</code> 中回调添加到 <code>微任务队列</code>。</p>\n</li>\n<li>\n<p>如同 1 时的执行原理。</p>\n</li>\n<li>\n<p><code>script</code> 宏任务执行完成，弹出执行上下文栈。此时，微任务队列中有两个 <code>then</code> 加入的回调函数等待执行。另外，若距 2 超过 1 秒钟，那么宏任务队列中有一个匿名函数 a 等待执行，否则，此时宏任务队列为空。</p>\n</li>\n<li>\n<p>在当前宏任务执行完成并弹出调用栈后，开始<strong>清空</strong>因宏任务执行而产生的微任务队列。首先执行 <code>console.log(\'I am from 1st ins.then()\')</code>，之后执行 <code>console.log(\'I am from 2nd ins.then()\')</code>。</p>\n</li>\n<li>\n<p>微任务队列清空后，开始调用下一宏任务（即进入下一个事件循环）或等待下一宏任务加入任务队列。此时，在 2 中计时 1 秒后，加入匿名函数 a 至宏任务队列，此时，因之前宏任务 script 执行完成而清空，那么将匿名函数 a 加入调用栈执行，输出 <code>I am from setTimeout</code>。</p>\n</li>\n</ol>\n<p><strong>注</strong>：<code>JavaScript</code> 中在某一函数内部调用另一函数时，会暂停（冻结）当前函数的执行，并将当前函数的执行权转移给新的被调用的函数（具体解析见<a href="/blog/writings/execution-context/">拓展阅读</a>）。</p>\n<p>示例总结：</p>\n<ol>\n<li>\n<p><strong>在一个代码段（或理解为一个模块）中</strong>，所有的代码都是基于一个 <code>script</code> 宏任务进行的。</p>\n</li>\n<li>\n<p>在当前宏任务执行完成后，<strong>必须</strong>要清空因执行宏任务而产生的<code>微任务队列</code>。</p>\n</li>\n<li>\n<p>只有当前微任务队列清空后，才会调用下一个宏任务队列中的任务。即进入下一个事件循环。</p>\n</li>\n<li>\n<p><code>new Promise</code> 时，<code>Promise</code> 参数中的匿名函数是<strong>立即执行</strong>的。被添加进<code>微任务队列</code>的是 <code>then</code> 中的回调函数。</p>\n<ul>\n<li><strong>特别地</strong>，只有 <code>Promise</code> 中的状态为 <code>resolved</code> 或 <code>rejected</code> 后（<a href="https://promisesaplus.com/#point-26" target="_blank" rel="noopener noreferrer">Promise 标准<OutboundLink/></a>），才会调用 <code>Promise</code> 的原型方法（即 <a href="https://promisesaplus.com/#point-26" target="_blank" rel="noopener noreferrer">then<OutboundLink/></a>、<code>catch</code>（因为是 <code>then</code> 的<a href="https://www.ecma-international.org/ecma-262/#sec-promise.prototype.catch" target="_blank" rel="noopener noreferrer">语法糖<OutboundLink/></a>，所以与 <code>then</code> 同理）、<code>finally</code>（<code>onfinally</code>时<a href="https://tc39.github.io/ecma262/#sec-promise.prototype.finally" target="_blank" rel="noopener noreferrer">触发<OutboundLink/></a>）），才会将回调函数到添加微任务队列中。</li>\n</ul>\n</li>\n<li>\n<p><code>setTimeout</code> 是作为任务分发器的存在，他自身执行会创建一个计时器，只有待计时器结束后，才会将 <code>setTimeout</code> 中的第一参数函数添加至<code>宏任务队列</code>。换一种方式理解，<code>setTimeout</code> 中的函数<strong>一定不是在当前事件循环</strong>中被调用。</p>\n</li>\n</ol>\n<p>以下是在客户端（Node.js 可能有不同结果）的输入结果：</p>\n<pre v-pre class="language-markup"><code>I am from script beginning\nI am from internal part\nI am from script bottom\nI am from 1st ins.then()\nI am from 2nd ins.then()\nI am from setTimeout\n</code></pre>\n<h2 id="事件循环拓展应用-——-异步操作"><a class="header-anchor" href="#事件循环拓展应用-——-异步操作" aria-hidden="true">#</a> 事件循环拓展应用 —— 异步操作</h2>\n<ol>\n<li>\n<p>定时任务：setTimeout，setInterval</p>\n</li>\n<li>\n<p>请求数据：Ajax 请求，图片加载</p>\n</li>\n<li>\n<p>事件绑定</p>\n</li>\n</ol>\n<p>一般地，在 JS 开发过程中，凡是可能造成代码阻塞的地方都可根据实际情况考虑使用异步操作。比如，数据获取等等。</p>\n<h2 id="参考"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h2>\n<p><code>JavaScript 语言精粹(修订版)</code></p>\n<p><a href="https://www.w3.org/TR/html5/webappapis.html#event-loops" target="_blank" rel="noopener noreferrer">w3c Event loop<OutboundLink/></a></p>\n<p><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loops" target="_blank" rel="noopener noreferrer">HTML5 Standard<OutboundLink/></a></p>\n<p><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues" target="_blank" rel="noopener noreferrer">ECMA Jobs and Job Queues<OutboundLink/></a></p>\n<p><a href="https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/" target="_blank" rel="noopener noreferrer">Tasks, microtasks, queues and schedules<OutboundLink/></a></p>\n<p><a href="https://www.youtube.com/watch?v=8aGhZQkoFbQ" target="_blank" rel="noopener noreferrer">Great talk at JSConf 2014 on the event loop<OutboundLink/></a></p>\n'}],error:null,serverRendered:!0}</script><script defer src="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js"></script><script defer src="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js"></script><script defer src="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js"></script><script defer src="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js"></script><script defer src="/_nuxt/vendor.13de21511613edf061b2.js"></script><script defer src="/_nuxt/app.5a4fa6b8fcf73db97515.js"></script>