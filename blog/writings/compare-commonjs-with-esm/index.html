<!doctype html><html data-n-head="lang" data-n-head-ssr lang="zh"><meta data-n-head="true" content="IE=edge,chrome=1" http-equiv='"X-UA-Compatible'><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" name="viewport"><meta data-n-head="true" content="bowen blog, bowen 博客, vuejs, reactjs, ssr, 前端开发, 前端 , web开发, nodejs, github" name="keywords"><meta data-n-head="true" content="一个分享代码经历的地方" name="description" data-hid="description"><meta data-n-head="true" content="yes" name="apple-mobile-web-app-capable"><meta data-n-head="true" content="black" name="apple-mobile-web-app-status-bar-style"><meta data-n-head="true" content="yes" name="mobile-web-app-capable" data-hid="mobile-web-app-capable"><meta data-n-head="true" content="Bowen Blog" name="apple-mobile-web-app-title" data-hid="apple-mobile-web-app-title"><meta data-n-head="true" content="Bowen" name="author" data-hid="author"><meta data-n-head="true" content="#24292e" name="theme-color" data-hid="theme-color"><meta data-n-head="true" content="website" name="og:type" data-hid="og:type" property="og:type"><meta data-n-head="true" content="Bowen Blog" name="og:title" data-hid="og:title" property="og:title"><meta data-n-head="true" content="A place which is used to share programming experiences" name="og:description" data-hid="og:description" property="og:description"><title data-n-head="true">比较 CommonJS 与 ES6 Module 语法 | Bowen Blog</title><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="/_nuxt/manifest.2108b1d4.json" rel="manifest" data-n-head="true"><link href="/_nuxt/icons/icon_64.e20A200w20w.png" rel="shortcut icon" data-n-head="true"><link href="/_nuxt/icons/icon_512.e20A200w20w.png" rel="apple-touch-icon" data-n-head="true" sizes="512x512"><link href="https://set.sh/blog/writings/compare-commonjs-with-esm/" rel="alternate" data-n-head="true" hreflang="zh"><link href="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js" rel="preload" as="script"><link href="/_nuxt/vendor.13de21511613edf061b2.js" rel="preload" as="script"><link href="/_nuxt/app.5a4fa6b8fcf73db97515.js" rel="preload" as="script"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="preload" as="style"><link href="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js" rel="preload" as="script"><link href="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/tags/_id/index.edb9dbabb1b9c2ef81f2.js" rel="prefetch"><link href="/_nuxt/pages/index.1d0ac68e309be0e86168.js" rel="prefetch"><link href="/_nuxt/pages/blog/tags/index.2659d358b69abdfd34bf.js" rel="prefetch"><link href="/_nuxt/pages/blog/projects/index.3ff8e031c3cb4f25eaed.js" rel="prefetch"><link href="/_nuxt/pages/blog/writings/index.b016af22016e152b7231.js" rel="prefetch"><link href="/_nuxt/layouts/home.dd55e95df1c2109ebde6.js" rel="prefetch"><link href="/_nuxt/layouts/default.89ffa224d3d7769e4fbb.js" rel="prefetch"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="stylesheet"><body data-n-head=""><div id="__nuxt" data-server-rendered="true"><div class="nuxt-progress" style="width:0%;height:2px;background-color:#3eaf7c;opacity:0"></div><div id="__layout"><section class="blog sf__parent__clearfix" data-v-cac63c14><header class="header __position components-animation" data-v-13c46026 data-v-cac63c14><nav class="mobile-navigator" data-v-13c46026 data-v-d4cae7a6><label class="label-line" data-v-d4cae7a6><span class="__position label-line line-top" data-v-d4cae7a6><span class="__position line-crust line-crust-top" data-v-d4cae7a6></span></span><span class="__position label-line line-bottom" data-v-d4cae7a6><span class="__position line-crust line-crust-bottom" data-v-d4cae7a6></span></span></label></nav><nav class="navigator __position grid" data-v-13c46026 role="navigation"><a href="/" class="navigator-link hover-animation grid-cell" data-v-13c46026>HOME</a><a href="/blog/writings/" class="navigator-link hover-animation grid-cell" data-v-13c46026>WRITINGS</a><a href="/blog/projects/" class="navigator-link hover-animation grid-cell" data-v-13c46026>PROJECTS</a><a href="/blog/tags/" class="navigator-link hover-animation grid-cell" data-v-13c46026>TAGS</a><a href="https://github.com/lbwa" class="navigator-link hover-animation grid-cell" data-v-13c46026 rel="noopener" target="_blank">GITHUB</a></nav><div class="background-helper __position" data-v-13c46026></div></header><main class="articles-container wrapper sf__reference__layout" data-v-cac63c14 role="main"><article class="articles-main"><div class="article-header"><h1 class="article-title">比较 CommonJS 与 ES6 Module 语法</h1><span class="article-author">Bowen</span><span class="article-date">2018 FEB 27</span><div class="article-tags"><a href="/blog/tags/前端开发" class="article-tag">前端开发</a><a href="/blog/tags/javascript" class="article-tag">JavaScript</a><a href="/blog/tags/模块" class="article-tag">模块</a></div></div><div class="article-content"><blockquote><p>在学习<code>Vue.js</code>中模块开发时，遇到一些关于 <code>CommonJS</code> 与<code>ES6</code>模块语法加载机制异同的相关知识欠缺的问题，经过查阅后补全知识缺口。现将自己对二者的异同之处的理解总结复盘如下。</blockquote><h2 id="commonjs-简介"><a href="#commonjs-简介" class="header-anchor" aria-hidden="true">#</a> CommonJS 简介</h2><p>在 CommonJS 中每一个文件都是一个<strong>模块</strong>。<h4 id="定义模块"><a href="#定义模块" class="header-anchor" aria-hidden="true">#</a> 定义模块</h4><p>在每个模块（文件）内，module 变量表示当前模块，module变量的 exports 属性即为当前模块暴露给外部的数据接口，该值为一个对象。<h4 id="加载模块"><a href="#加载模块" class="header-anchor" aria-hidden="true">#</a> 加载模块</h4><p>在 CommonJS 中，加载模块即是调用用<code>module.exports</code>变量的<strong>值的副本</strong>。<p>使用<code>require('模块名或地址')</code>来加载模块。其中参数类型为字符串，默认参数文件类型为<code>.js</code>。<blockquote><p><code>/</code> 表示从根目录开始，是相对于根目录的路径（对于项目来说，这是<a href="https://stackoverflow.com/questions/24028561/relative-path-in-html" rel="noopener noreferrer" target="_blank">绝对路径<outboundlink></a>）。例如，<code>/dist</code>表示<strong>根目录</strong>下的<code>dist</code>文件夹。可类比<code>HTML</code>文档中的<code>&lt;base></code>标签，其所在文档之后的标签中的<code>/</code>表示从<code>&lt;base></code>指定的默认地址（指定了根目录）开始查找。</blockquote><blockquote><p><code>./</code> 表示相对路径，即当前模块所在目录下。</blockquote><blockquote><p><code>../</code> 表示相对路径，即当前模块的上一级父目录。</blockquote><h4 id="入口文件（模块之间的调用是如何开始的）"><a href="#入口文件（模块之间的调用是如何开始的）" class="header-anchor" aria-hidden="true">#</a> 入口文件（模块之间的调用是如何开始的）</h4><p>一般有一个主文件（入口文件），在项目文件夹下的<code>index.html</code>中引入加载该文件，之后在入口文件中会触发加载其他模块。<h4 id="模块缓存-加载机制"><a href="#模块缓存-加载机制" class="header-anchor" aria-hidden="true">#</a> 模块缓存/加载机制</h4><p>CommonJS 模块的重要特性是<strong>加载时执行</strong>，即脚本代码在调用<code>require()</code>加载模块的时候，就会全部执行模块，然后在内存生成一个对象（该对象包含如模块id，该模块输出对象等等一系列信息）。<p>第一次加载某个模块时，Node 会<strong>缓存</strong>该模块的输出值。在加载该模块输出值时调用的是<strong>缓存</strong>中该模块的<code>module.exports</code>值的<strong>副本</strong>。即使再次执行<code>require()</code>，也不会再次执行该模块，而是到<strong>缓存</strong>之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。即<strong>CommonJS模块可多次加载，但只执行一次。</strong><h2 id="commonjs-与-es6-模块的异同"><a href="#commonjs-与-es6-模块的异同" class="header-anchor" aria-hidden="true">#</a> CommonJS 与 ES6 模块的异同</h2><h3 id="共同点"><a href="#共同点" class="header-anchor" aria-hidden="true">#</a> 共同点</h3><h4 id="模块之间同步加载"><a href="#模块之间同步加载" class="header-anchor" aria-hidden="true">#</a> 模块之间同步加载</h4><p>CommonJS 加载模块是同步的，只有当前模块加载完毕，才会开始加载下一个模块。<p>ES6 模块<a href="http://es6.ruanyifeng.com/#docs/module-loader#%E5%8A%A0%E8%BD%BD%E8%A7%84%E5%88%99" rel="noopener noreferrer" target="_blank">加载规则<outboundlink></a>在浏览器中是模块之间是同步的，对于渲染DOM是异步的。即浏览器中<code>&lt;script></code>的<code>type="module"</code>相当于默认开启了<code>&lt;script></code>的<code>defer</code>属性（不阻塞DOM渲染，在渲染完成后执行模块），在 Node 中的 ES6 模块加载机制与在浏览器中的处理方法是<strong>相同</strong>的。<p>二者模块加载的顺序是<strong>按照代码出现的顺序同步加载</strong>的。<h4 id="查找模块"><a href="#查找模块" class="header-anchor" aria-hidden="true">#</a> 查找模块</h4><blockquote><p>目前，Node 的 import 命令只支持加载本地模块（file:协议），不支持加载远程模块。</blockquote><p>如果模块名不含路径，那么 <code>import</code> 命令会去<code>node_modules</code>目录寻找这个模块。<p>在使用<code>vue-cli</code>构建<code>vue</code>单文件组件时，有部分JavaScript文件有以下一行代码：<pre class="language-js" v-pre><code><span class="token comment">// 在构建时，若只有模块名，则将会去 node_modules 目录下寻找vue模块</span>
<span class="token comment">// 当前模块的 Vue 变量将被赋值被加载模块的默认输出对象（即export default {...}）</span>
<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span>
<span class="token comment">// 另一种写法如下</span>
<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">"../node_modules/vue/dist/vue.min.js"</span>
<span class="token comment">// 上面import语句与下句调用require方法，作用相同</span>
<span class="token comment">// 不同之处在于import只能用在模块开头，require方法可用在模块任意位置</span>
<span class="token keyword">const</span> vue <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'vue'</span><span class="token punctuation">)</span>
</code></pre><p>如果模块名包含路径，那么<code>import</code>命令会按照路径去寻找这个名字的脚本文件。<p>如果脚本文件省略了后缀名，比如<code>import './foo'</code>，Node 会依次尝试四个后缀名：<code>./foo.mjs</code>、<code>./foo.js</code>、<code>./foo.json</code>、<code>./foo.node</code>。如果这些脚本文件都不存在，Node 就会去加载<code>./foo/package.json</code>的main字段指定的脚本。如果<code>./foo/package.json</code>不存在或者没有main字段，那么就会依次加载<code>./foo/index.mjs</code>、<code>./foo/index.js</code>、<code>./foo/index.json</code>、<code>./foo/index.node</code>。如果以上四个文件还是都不存在，就会抛出错误。<p>在webpack设置模块（<code>webpack.config.js</code>）中的输出对象（<code>module.exports = {...}</code>）中的路径查找（如对象中的output选项），<code>__dirname</code>（最前是两个下划线，如同ES6中<code>__proto__</code>属性）表示当前模块文件所在的文件夹路径，<code>__filename</code>表示当前模块文件所在的文件夹路径加文件名。<blockquote><p>拓展：Node原生提供一些核心模块：http、fs、os、path、url、querystring等，Node在加载核心模块时，不需要传入路径，因为<code>Node.js</code>已经将核心模块的文件代码编译到了二进制可执行文件中，核心模块在Node中加载的优先级是最高的。</blockquote><h4 id="作用域"><a href="#作用域" class="header-anchor" aria-hidden="true">#</a> 作用域</h4><p>他们每个模块都具有自己独立的作用域，模块中的代码是在模块内部的作用域执行的。模块中的顶层变量外部是不可见的。<h3 id="不同点"><a href="#不同点" class="header-anchor" aria-hidden="true">#</a> 不同点</h3><h4 id="对被加载模块的输出值的引用方式不同"><a href="#对被加载模块的输出值的引用方式不同" class="header-anchor" aria-hidden="true">#</a> 对被加载模块的输出值的引用方式不同</h4><blockquote><p>CommonJS 模块输入的是被加载模块<strong>输出值的副本</strong>，ES6 模块输入的是被加载模块<strong>输出值的引用</strong>。</blockquote><p>具体解释为 CommonJS 输入的是 Node 缓存中被加载模块的输出值的副本，那么在被加载模块中值的变化将<strong>不会影响</strong>到输入值。此时，模块的引入值与被加载模块的输出值已经没有直接的联系。<blockquote><p>拓展：将CommonJS被加载模块的输出值设为输出一个<strong>取值函数</strong>，而不是一个静态值，那么此时，该输出值可起到动态引用被加载模块内部变量的作用。这与ES6 模块的输出效果相同。</blockquote><p>ES6 模块中<strong>不会缓存</strong>第一次加载模块的结果，而是动态地去被加载的模块取值。当前模块引入变量总是<strong>绑定</strong>在其所在模块（被加载模块）。模块引入的变量是<strong>只读</strong>的，且本质为一个被加载模块的输出值的<strong>引用</strong>。<h4 id="二者的运行机制的差异"><a href="#二者的运行机制的差异" class="header-anchor" aria-hidden="true">#</a> 二者的运行机制的差异</h4><blockquote><p>CommonJS 模块是运行是加载，ES6 模块是编译时的输出接口。</blockquote><p>ES6 模块在遇到加载命令<code>import</code>就会生成一个<strong>只读引用</strong>，等到脚本真正执行至取值语句时，再根据这个只读引用，到被加载的那个模块中取值。即<strong>使用值时才取值，否则只建立数据引用</strong>。<p>CommonJS 模块的加载机制详见前文<a href="/blog/writings/compare-commonjs-with-esm/#%E6%A8%A1%E5%9D%97%E7%BC%93%E5%AD%98-%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6">模块缓存/加载机制</a><h3 id="参考"><a href="#参考" class="header-anchor" aria-hidden="true">#</a> 参考</h3><p><a href="http://es6.ruanyifeng.com/#docs/module-loader#%E5%8A%A0%E8%BD%BD%E8%A7%84%E5%88%99" rel="noopener noreferrer" target="_blank">ECMAScript 6 入门<outboundlink></a></div></article><button data-v-e85d20b2 data-v-e85d20b2 class="floating-btn __position" style="display:none"><svg class="icon-rocket" data-v-e85d20b2 viewBox="0 0 512 512"><path d="M256 421.6c-18.1 0-33.2-6.8-42.9-10.9-5.4-2.3-11.3 1.8-10.9 7.6l3.5 51c.2 3.1 3.8 4.7 6.3 2.8l14.5-11c1.8-1.4 4.5-.9 5.7 1l20.5 32.1c1.5 2.4 5.1 2.4 6.6 0l20.5-32.1c1.2-1.9 3.9-2.4 5.7-1l14.5 11c2.5 1.9 6.1.3 6.3-2.8l3.5-51c.4-5.8-5.5-10-10.9-7.6-9.8 4.1-24.8 10.9-42.9 10.9z" data-v-e85d20b2></path><path d="M397.7 293.1l-48-49.1c0-158-93.2-228-93.2-228s-94.1 70-94.1 228l-48 49.1c-1.8 1.8-2.6 4.5-2.2 7.1L130.6 412c.9 5.7 7.1 8.5 11.8 5.4l67.1-45.4s20.7 20 47.1 20c26.4 0 46.1-20 46.1-20l67.1 45.4c4.6 3.1 10.8.3 11.8-5.4l18.5-111.9c.2-2.6-.6-5.2-2.4-7zM256.5 192c-17 0-30.7-14.3-30.7-32s13.8-32 30.7-32c17 0 30.7 14.3 30.7 32s-13.7 32-30.7 32z" data-v-e85d20b2></path></svg></button></main><footer class="blog-footer sf__main__layout grid col grid-jc-center" data-v-1044ad0a data-v-cac63c14><div class="footer-info" data-v-1044ad0a>Copyright © 2018 <a href="https://github.com/lbwa" class="author" rel="noopener" target="_blank" data-v-1044ad0a>Bowen</a></div></footer><section class="loading-wrapper grid col grid-center grid-jc-center" data-v-cac63c14 style="display:none"><div class="loading"><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div></div><a class="loading-tips">Loading</a></section></section></div></div><script type="text/javascript">window.__NUXT__={layout:"blog",data:[{menu:[{errno:0,to:"writings/dom-location",title:"获取 Element 在 document 中的位置信息",author:"Bowen",date:"2018 SEP 01",tags:["前端开发","CSS"]},{errno:0,to:"writings/spa-and-mpa",title:"SPA 与 MPA 的比较与优化",author:"Bowen",date:"2018 AUG 04",tags:["前端开发","SPA","MPA","skeleton"]},{errno:0,to:"writings/async-function-in-js",title:"Event loops 中的 AsyncFunction",author:"Bowen",date:"2018 JUL 26",tags:["JavaScript","async","事件循环"]},{errno:0,to:"writings/pwa-fundamentals",title:"PWA 基础",author:"Bowen",date:"2018 JUL 07",tags:["前端开发","PWA"]},{errno:0,to:"writings/js-design-pattern",title:"JS 设计模式",author:"Bowen",date:"2018 JUN 12",tags:["前端开发","设计模式"]},{errno:0,to:"writings/http-request",title:"HTTP 协议请求首部",author:"Bowen",date:"2018 JUN 08",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-response",title:"HTTP 协议响应首部",author:"Bowen",date:"2018 JUN 07",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-protocol",title:"HTTP 协议",author:"Bowen",date:"2018 JUN 06",tags:["前端开发","网络请求"]},{errno:0,to:"writings/execution-context",title:"JS 执行上下文",author:"Bowen",date:"2018 MAY 07",tags:["前端开发","JavaScript","执行上下文"]},{errno:0,to:"writings/vue-lifecycle-and-slots",title:"对 Vue 插槽和生命周期的一点思考",author:"Bowen",date:"2018 APR 24",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/learning-vue-unit-test",title:"总结如何进行单元测试",author:"Bowen",date:"2018 APR 21",tags:["前端开发","Vue.js","应用测试"]},{errno:0,to:"writings/cross-domain-solution",title:"客户端跨域解决方案",author:"Bowen",date:"2018 APR 19",tags:["前端开发","网络请求"]},{errno:0,to:"writings/css-bfc",title:"探究 BFC 以及闭合浮动原理",author:"Bowen",date:"2018 MAR 29",tags:["前端开发","CSS"]},{errno:0,to:"writings/vue.js-reusability-and-composition",title:"学习 Vue.js 可复用性和组合",author:"Bowen",date:"2018 MAR 12",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/event-loop",title:"解析 event loops",author:"Bowen",date:"2018 MAR 08",tags:["前端开发","JavaScript","事件循环"]},{errno:0,to:"writings/learning-vuex",title:"学习 vuex 基础",author:"Bowen",date:"2018 MAR 06",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/compare-commonjs-with-esm",title:"比较 CommonJS 与 ES6 Module 语法",author:"Bowen",date:"2018 FEB 27",tags:["前端开发","JavaScript","模块"]},{errno:0,to:"writings/learning-vuejs-essentials",title:"学习 Vue.js 基础",author:"Bowen",date:"2018 FEB 24",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/keyword-this",title:"理解 this 的指向",author:"Bowen",date:"2018 FEB 06",tags:["前端开发","JavaScript"]}]},{title:"比较 CommonJS 与 ES6 Module 语法",date:"2018 FEB 27",author:"Bowen",tags:["前端开发","JavaScript","模块"],content:'<blockquote>\n<p>在学习<code>Vue.js</code>中模块开发时，遇到一些关于 <code>CommonJS</code> 与<code>ES6</code>模块语法加载机制异同的相关知识欠缺的问题，经过查阅后补全知识缺口。现将自己对二者的异同之处的理解总结复盘如下。</p>\n</blockquote>\n<h2 id="commonjs-简介"><a class="header-anchor" href="#commonjs-简介" aria-hidden="true">#</a> CommonJS 简介</h2>\n<p>在 CommonJS 中每一个文件都是一个<strong>模块</strong>。</p>\n<h4 id="定义模块"><a class="header-anchor" href="#定义模块" aria-hidden="true">#</a> 定义模块</h4>\n<p>在每个模块（文件）内，module 变量表示当前模块，module变量的 exports 属性即为当前模块暴露给外部的数据接口，该值为一个对象。</p>\n<h4 id="加载模块"><a class="header-anchor" href="#加载模块" aria-hidden="true">#</a> 加载模块</h4>\n<p>在 CommonJS 中，加载模块即是调用用<code>module.exports</code>变量的<strong>值的副本</strong>。</p>\n<p>使用<code>require(\'模块名或地址\')</code>来加载模块。其中参数类型为字符串，默认参数文件类型为<code>.js</code>。</p>\n<blockquote>\n<p><code>/</code> 表示从根目录开始，是相对于根目录的路径（对于项目来说，这是<a href="https://stackoverflow.com/questions/24028561/relative-path-in-html" target="_blank" rel="noopener noreferrer">绝对路径<OutboundLink/></a>）。例如，<code>/dist</code>表示<strong>根目录</strong>下的<code>dist</code>文件夹。可类比<code>HTML</code>文档中的<code>&lt;base&gt;</code>标签，其所在文档之后的标签中的<code>/</code>表示从<code>&lt;base&gt;</code>指定的默认地址（指定了根目录）开始查找。</p>\n</blockquote>\n<blockquote>\n<p><code>./</code> 表示相对路径，即当前模块所在目录下。</p>\n</blockquote>\n<blockquote>\n<p><code>../</code> 表示相对路径，即当前模块的上一级父目录。</p>\n</blockquote>\n<h4 id="入口文件（模块之间的调用是如何开始的）"><a class="header-anchor" href="#入口文件（模块之间的调用是如何开始的）" aria-hidden="true">#</a> 入口文件（模块之间的调用是如何开始的）</h4>\n<p>一般有一个主文件（入口文件），在项目文件夹下的<code>index.html</code>中引入加载该文件，之后在入口文件中会触发加载其他模块。</p>\n<h4 id="模块缓存-加载机制"><a class="header-anchor" href="#模块缓存-加载机制" aria-hidden="true">#</a> 模块缓存/加载机制</h4>\n<p>CommonJS 模块的重要特性是<strong>加载时执行</strong>，即脚本代码在调用<code>require()</code>加载模块的时候，就会全部执行模块，然后在内存生成一个对象（该对象包含如模块id，该模块输出对象等等一系列信息）。</p>\n<p>第一次加载某个模块时，Node 会<strong>缓存</strong>该模块的输出值。在加载该模块输出值时调用的是<strong>缓存</strong>中该模块的<code>module.exports</code>值的<strong>副本</strong>。即使再次执行<code>require()</code>，也不会再次执行该模块，而是到<strong>缓存</strong>之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。即<strong>CommonJS模块可多次加载，但只执行一次。</strong></p>\n<h2 id="commonjs-与-es6-模块的异同"><a class="header-anchor" href="#commonjs-与-es6-模块的异同" aria-hidden="true">#</a> CommonJS 与 ES6 模块的异同</h2>\n<h3 id="共同点"><a class="header-anchor" href="#共同点" aria-hidden="true">#</a> 共同点</h3>\n<h4 id="模块之间同步加载"><a class="header-anchor" href="#模块之间同步加载" aria-hidden="true">#</a> 模块之间同步加载</h4>\n<p>CommonJS 加载模块是同步的，只有当前模块加载完毕，才会开始加载下一个模块。</p>\n<p>ES6 模块<a href="http://es6.ruanyifeng.com/#docs/module-loader#%E5%8A%A0%E8%BD%BD%E8%A7%84%E5%88%99" target="_blank" rel="noopener noreferrer">加载规则<OutboundLink/></a>在浏览器中是模块之间是同步的，对于渲染DOM是异步的。即浏览器中<code>&lt;script&gt;</code>的<code>type=&quot;module&quot;</code>相当于默认开启了<code>&lt;script&gt;</code>的<code>defer</code>属性（不阻塞DOM渲染，在渲染完成后执行模块），在 Node 中的 ES6 模块加载机制与在浏览器中的处理方法是<strong>相同</strong>的。</p>\n<p>二者模块加载的顺序是<strong>按照代码出现的顺序同步加载</strong>的。</p>\n<h4 id="查找模块"><a class="header-anchor" href="#查找模块" aria-hidden="true">#</a> 查找模块</h4>\n<blockquote>\n<p>目前，Node 的 import 命令只支持加载本地模块（file:协议），不支持加载远程模块。</p>\n</blockquote>\n<p>如果模块名不含路径，那么 <code>import</code> 命令会去<code>node_modules</code>目录寻找这个模块。</p>\n<p>在使用<code>vue-cli</code>构建<code>vue</code>单文件组件时，有部分JavaScript文件有以下一行代码：</p>\n<pre v-pre class="language-js"><code><span class="token comment">// 在构建时，若只有模块名，则将会去 node_modules 目录下寻找vue模块</span>\n<span class="token comment">// 当前模块的 Vue 变量将被赋值被加载模块的默认输出对象（即export default {...}）</span>\n<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">\'vue\'</span>\n<span class="token comment">// 另一种写法如下</span>\n<span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">"../node_modules/vue/dist/vue.min.js"</span>\n<span class="token comment">// 上面import语句与下句调用require方法，作用相同</span>\n<span class="token comment">// 不同之处在于import只能用在模块开头，require方法可用在模块任意位置</span>\n<span class="token keyword">const</span> vue <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">\'vue\'</span><span class="token punctuation">)</span>\n</code></pre>\n<p>如果模块名包含路径，那么<code>import</code>命令会按照路径去寻找这个名字的脚本文件。</p>\n<p>如果脚本文件省略了后缀名，比如<code>import \'./foo\'</code>，Node 会依次尝试四个后缀名：<code>./foo.mjs</code>、<code>./foo.js</code>、<code>./foo.json</code>、<code>./foo.node</code>。如果这些脚本文件都不存在，Node 就会去加载<code>./foo/package.json</code>的main字段指定的脚本。如果<code>./foo/package.json</code>不存在或者没有main字段，那么就会依次加载<code>./foo/index.mjs</code>、<code>./foo/index.js</code>、<code>./foo/index.json</code>、<code>./foo/index.node</code>。如果以上四个文件还是都不存在，就会抛出错误。</p>\n<p>在webpack设置模块（<code>webpack.config.js</code>）中的输出对象（<code>module.exports = {...}</code>）中的路径查找（如对象中的output选项），<code>__dirname</code>（最前是两个下划线，如同ES6中<code>__proto__</code>属性）表示当前模块文件所在的文件夹路径，<code>__filename</code>表示当前模块文件所在的文件夹路径加文件名。</p>\n<blockquote>\n<p>拓展：Node原生提供一些核心模块：http、fs、os、path、url、querystring等，Node在加载核心模块时，不需要传入路径，因为<code>Node.js</code>已经将核心模块的文件代码编译到了二进制可执行文件中，核心模块在Node中加载的优先级是最高的。</p>\n</blockquote>\n<h4 id="作用域"><a class="header-anchor" href="#作用域" aria-hidden="true">#</a> 作用域</h4>\n<p>他们每个模块都具有自己独立的作用域，模块中的代码是在模块内部的作用域执行的。模块中的顶层变量外部是不可见的。</p>\n<h3 id="不同点"><a class="header-anchor" href="#不同点" aria-hidden="true">#</a> 不同点</h3>\n<h4 id="对被加载模块的输出值的引用方式不同"><a class="header-anchor" href="#对被加载模块的输出值的引用方式不同" aria-hidden="true">#</a> 对被加载模块的输出值的引用方式不同</h4>\n<blockquote>\n<p>CommonJS 模块输入的是被加载模块<strong>输出值的副本</strong>，ES6 模块输入的是被加载模块<strong>输出值的引用</strong>。</p>\n</blockquote>\n<p>具体解释为 CommonJS 输入的是 Node 缓存中被加载模块的输出值的副本，那么在被加载模块中值的变化将<strong>不会影响</strong>到输入值。此时，模块的引入值与被加载模块的输出值已经没有直接的联系。</p>\n<blockquote>\n<p>拓展：将CommonJS被加载模块的输出值设为输出一个<strong>取值函数</strong>，而不是一个静态值，那么此时，该输出值可起到动态引用被加载模块内部变量的作用。这与ES6 模块的输出效果相同。</p>\n</blockquote>\n<p>ES6 模块中<strong>不会缓存</strong>第一次加载模块的结果，而是动态地去被加载的模块取值。当前模块引入变量总是<strong>绑定</strong>在其所在模块（被加载模块）。模块引入的变量是<strong>只读</strong>的，且本质为一个被加载模块的输出值的<strong>引用</strong>。</p>\n<h4 id="二者的运行机制的差异"><a class="header-anchor" href="#二者的运行机制的差异" aria-hidden="true">#</a> 二者的运行机制的差异</h4>\n<blockquote>\n<p>CommonJS 模块是运行是加载，ES6 模块是编译时的输出接口。</p>\n</blockquote>\n<p>ES6 模块在遇到加载命令<code>import</code>就会生成一个<strong>只读引用</strong>，等到脚本真正执行至取值语句时，再根据这个只读引用，到被加载的那个模块中取值。即<strong>使用值时才取值，否则只建立数据引用</strong>。</p>\n<p>CommonJS 模块的加载机制详见前文<a href="/blog/writings/compare-commonjs-with-esm/#%E6%A8%A1%E5%9D%97%E7%BC%93%E5%AD%98-%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6">模块缓存/加载机制</a></p>\n<h3 id="参考"><a class="header-anchor" href="#参考" aria-hidden="true">#</a> 参考</h3>\n<p><a href="http://es6.ruanyifeng.com/#docs/module-loader#%E5%8A%A0%E8%BD%BD%E8%A7%84%E5%88%99" target="_blank" rel="noopener noreferrer">ECMAScript 6 入门<OutboundLink/></a></p>\n'}],error:null,serverRendered:!0}</script><script defer src="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js"></script><script defer src="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js"></script><script defer src="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js"></script><script defer src="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js"></script><script defer src="/_nuxt/vendor.13de21511613edf061b2.js"></script><script defer src="/_nuxt/app.5a4fa6b8fcf73db97515.js"></script>