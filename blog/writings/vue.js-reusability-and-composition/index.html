<!doctype html><html data-n-head="lang" data-n-head-ssr lang="zh"><meta data-n-head="true" content="IE=edge,chrome=1" http-equiv='"X-UA-Compatible'><meta data-n-head="true" charset="utf-8"><meta data-n-head="true" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" name="viewport"><meta data-n-head="true" content="bowen blog, bowen 博客, vuejs, reactjs, ssr, 前端开发, 前端 , web开发, nodejs, github" name="keywords"><meta data-n-head="true" content="一个分享代码经历的地方" name="description" data-hid="description"><meta data-n-head="true" content="yes" name="apple-mobile-web-app-capable"><meta data-n-head="true" content="black" name="apple-mobile-web-app-status-bar-style"><meta data-n-head="true" content="yes" name="mobile-web-app-capable" data-hid="mobile-web-app-capable"><meta data-n-head="true" content="Bowen Blog" name="apple-mobile-web-app-title" data-hid="apple-mobile-web-app-title"><meta data-n-head="true" content="Bowen" name="author" data-hid="author"><meta data-n-head="true" content="#24292e" name="theme-color" data-hid="theme-color"><meta data-n-head="true" content="website" name="og:type" data-hid="og:type" property="og:type"><meta data-n-head="true" content="Bowen Blog" name="og:title" data-hid="og:title" property="og:title"><meta data-n-head="true" content="A place which is used to share programming experiences" name="og:description" data-hid="og:description" property="og:description"><title data-n-head="true">学习 Vue.js 可复用性和组合 | Bowen Blog</title><link href="/favicon.ico" rel="icon" data-n-head="true" type="image/x-icon"><link href="/_nuxt/manifest.2108b1d4.json" rel="manifest" data-n-head="true"><link href="/_nuxt/icons/icon_64.e20A200w20w.png" rel="shortcut icon" data-n-head="true"><link href="/_nuxt/icons/icon_512.e20A200w20w.png" rel="apple-touch-icon" data-n-head="true" sizes="512x512"><link href="https://set.sh/blog/writings/vue.js-reusability-and-composition/" rel="alternate" data-n-head="true" hreflang="zh"><link href="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js" rel="preload" as="script"><link href="/_nuxt/vendor.13de21511613edf061b2.js" rel="preload" as="script"><link href="/_nuxt/app.5a4fa6b8fcf73db97515.js" rel="preload" as="script"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="preload" as="style"><link href="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js" rel="preload" as="script"><link href="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js" rel="preload" as="script"><link href="/_nuxt/pages/blog/tags/_id/index.edb9dbabb1b9c2ef81f2.js" rel="prefetch"><link href="/_nuxt/pages/index.1d0ac68e309be0e86168.js" rel="prefetch"><link href="/_nuxt/pages/blog/tags/index.2659d358b69abdfd34bf.js" rel="prefetch"><link href="/_nuxt/pages/blog/projects/index.3ff8e031c3cb4f25eaed.js" rel="prefetch"><link href="/_nuxt/pages/blog/writings/index.b016af22016e152b7231.js" rel="prefetch"><link href="/_nuxt/layouts/home.dd55e95df1c2109ebde6.js" rel="prefetch"><link href="/_nuxt/layouts/default.89ffa224d3d7769e4fbb.js" rel="prefetch"><link href="/_nuxt/app.7d838d8b0da655541c316320c8ad8e6f.css" rel="stylesheet"><body data-n-head=""><div id="__nuxt" data-server-rendered="true"><div class="nuxt-progress" style="width:0%;height:2px;background-color:#3eaf7c;opacity:0"></div><div id="__layout"><section class="blog sf__parent__clearfix" data-v-cac63c14><header class="header __position components-animation" data-v-13c46026 data-v-cac63c14><nav class="mobile-navigator" data-v-13c46026 data-v-d4cae7a6><label class="label-line" data-v-d4cae7a6><span class="__position label-line line-top" data-v-d4cae7a6><span class="__position line-crust line-crust-top" data-v-d4cae7a6></span></span><span class="__position label-line line-bottom" data-v-d4cae7a6><span class="__position line-crust line-crust-bottom" data-v-d4cae7a6></span></span></label></nav><nav class="navigator __position grid" data-v-13c46026 role="navigation"><a href="/" class="navigator-link hover-animation grid-cell" data-v-13c46026>HOME</a><a href="/blog/writings/" class="navigator-link hover-animation grid-cell" data-v-13c46026>WRITINGS</a><a href="/blog/projects/" class="navigator-link hover-animation grid-cell" data-v-13c46026>PROJECTS</a><a href="/blog/tags/" class="navigator-link hover-animation grid-cell" data-v-13c46026>TAGS</a><a href="https://github.com/lbwa" class="navigator-link hover-animation grid-cell" data-v-13c46026 rel="noopener" target="_blank">GITHUB</a></nav><div class="background-helper __position" data-v-13c46026></div></header><main class="articles-container wrapper sf__reference__layout" data-v-cac63c14 role="main"><article class="articles-main"><div class="article-header"><h1 class="article-title">学习 Vue.js 可复用性和组合</h1><span class="article-author">Bowen</span><span class="article-date">2018 MAR 12</span><div class="article-tags"><a href="/blog/tags/前端开发" class="article-tag">前端开发</a><a href="/blog/tags/javascript" class="article-tag">JavaScript</a><a href="/blog/tags/vue.js" class="article-tag">Vue.js</a></div></div><div class="article-content"><h2 id="混入"><a href="#混入" class="header-anchor" aria-hidden="true">#</a> 混入</h2><h3 id="基础"><a href="#基础" class="header-anchor" aria-hidden="true">#</a> 基础</h3><p>混入可理解为在一个组件中调用另外一个包含组件选项的<strong>对象</strong>。可类比 Sass 中的 <code>@mixin</code> 混合宏、DOM 中的 <code>DocumentFragment</code> 类型。这里可以得到，混入是为了增强 Vue 中的选项复用性。<p>在创建 Vue 实例时，使用<code>mixins</code>选项来引入混入对象。<pre class="language-js" v-pre><code><span class="token keyword">const</span> CustomMixin <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">created</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>
  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>
    <span class="token function">hello</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'App is running now !'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  mixins<span class="token punctuation">:</span> <span class="token punctuation">[</span>CustomMixin<span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment">// 使用 mixins 选项来引入混入对象</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><h3 id="选项合并"><a href="#选项合并" class="header-anchor" aria-hidden="true">#</a> 选项合并</h3><ol><li>在混入时，各个选项的合并是<strong>浅合并</strong>（如，指向对象的指针就只会复制指针而不是复制对象，并没有开辟新的内存地址），在选项发生冲突时以组件数据优先。<li>同名钩子函数将混合为一个数组，因此<strong>都</strong>将被调用。另外，混入对象的钩子将在组件自身钩子<strong>之前</strong>调用。<li>值为对象的选项，例如 <code>methods</code>, <code>components</code> 和 <code>directives</code>，将被混合为<strong>同一个</strong>对象。两个对象键名冲突时，取组件对象的键值对。</ol><h3 id="全局混入"><a href="#全局混入" class="header-anchor" aria-hidden="true">#</a> 全局混入</h3><p>谨慎使用全局混入，因为一旦混入，将影响到<strong>所有</strong>之后创建的 Vue 实例。<h2 id="自定义指令"><a href="#自定义指令" class="header-anchor" aria-hidden="true">#</a> 自定义指令</h2><p>使用 <code>Vue.directive()</code> 来创建全局自定义指令。在创建 Vue 实例时使用 <code>directive</code> 选项来创建局部自定义指令。<p>格式如下：<pre class="language-js" v-pre><code><span class="token comment">// 注册一个全局自定义指令 `v-focus`</span>
Vue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">'focus'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>   <span class="token comment">// 调用时加前缀 V-</span>
  <span class="token comment">// 当被绑定的元素插入到 DOM 中时</span>
  inserted<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// 聚焦元素</span>
    el<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">// 局部自定义指令</span>
directives<span class="token punctuation">:</span> <span class="token punctuation">{</span>
  focus<span class="token punctuation">:</span> <span class="token punctuation">{</span>   <span class="token comment">// 调用时加前缀 V-</span>
    <span class="token comment">// 指令的定义</span>
    inserted<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      el<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><pre class="language-html" v-pre><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-focus</span><span class="token punctuation">></span></span>
</code></pre><h2 id="渲染函数-jsx"><a href="#渲染函数-jsx" class="header-anchor" aria-hidden="true">#</a> 渲染函数 & JSX</h2><h3 id="基础-2"><a href="#基础-2" class="header-anchor" aria-hidden="true">#</a> 基础</h3><p>渲染函数的作用是<strong>渲染视图</strong>，又称为<code>render 函数</code>。<p>在 <code>vue-cli</code> 的 <code>webpack</code> 模板中的 <code>main.js</code> 中有以下声明：<pre class="language-js" v-pre><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
  el<span class="token punctuation">:</span> <span class="token string">'#app'</span><span class="token punctuation">,</span>
  components<span class="token punctuation">:</span> <span class="token punctuation">{</span> App <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 表示实例中有哪些组件可用</span>
  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`&lt;App/>`</span></span>    <span class="token comment">// 表示要渲染哪些可用组件，这里形如 &lt;App>&lt;/App></span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre><p>以上代码中，<p>components 选项，包含 Vue 实例可用组件的哈希表。即 <code>components</code> 选项表示声明了实例中存在哪些组件。（参考<a href="https://github.com/vuejs-templates/webpack/issues/575" rel="noopener noreferrer" target="_blank">官方 issue<outboundlink></a>、<a href="https://cn.vuejs.org/v2/api/#components" rel="noopener noreferrer" target="_blank">API:components选项<outboundlink></a>）<p>template 选项，表示选项的值<code>一个字符串模板</code>作为 Vue 实例的标识使用。模板将会<strong>替换</strong>挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。即该选项<code>表示要渲染哪些组件</code>。（参考<a href="https://github.com/vuejs-templates/webpack/issues/575" rel="noopener noreferrer" target="_blank">官方 issue<outboundlink></a>、<a href="https://cn.vuejs.org/v2/api/#template" rel="noopener noreferrer" target="_blank">API:template选项<outboundlink></a>）<p>以对 <code>components</code> 和 <code>template</code> 两个选项作用的理解，那么 <code>渲染函数</code> 代替的是 <code>template</code> 选项的作用，达到<strong>定制化渲染</strong>的作用。<h3 id="虚拟-dom"><a href="#虚拟-dom" class="header-anchor" aria-hidden="true">#</a> 虚拟 DOM</h3><p>Vue 通过建立一个<strong>虚拟DOM</strong>对真实的DOM发生的变化保持追踪。在 <code>render 函数</code> 中传入一个 <code>createElement 函数(简写为 h)</code>（<a href="https://github.com/vuejs/babel-plugin-transform-vue-jsx#h-auto-injection" rel="noopener noreferrer" target="_blank">vue-JSX 使用文档<outboundlink></a>、<a href="https://cn.vuejs.org/v2/guide/render-function.html#JSX" rel="noopener noreferrer" target="_blank">Vue 文档<outboundlink></a>）来生成模板。<p><code>createElement 函数</code> 返回的是 <code>虚拟节点 VNode</code>， 它包含的信息会告诉 Vue 页面上需要渲染什么样的节点，以及子节点。<h3 id="createelement-参数"><a href="#createelement-参数" class="header-anchor" aria-hidden="true">#</a> createElement 参数</h3><p><code>createElement</code> 参数至多包含 3 个部分。<p><strong>一个</strong>要创建的元素标签名（类型：字符串/对象/函数返回值）；<p><strong>一个</strong>包含模板相关属性的 data 对象（类型：对象）；<p><strong>一个</strong>子节点（类型：字符串/数组），且这个子节点也是由另外的 <code>createElement 函数</code> 构成。<p>其中，data 对象和子节点为可选参数。<p>格式如下：<pre class="language-js" v-pre><code><span class="token comment">// @returns {VNode}</span>
<span class="token function">createElement</span><span class="token punctuation">(</span>
  <span class="token comment">// {String | Object | Function}</span>
  <span class="token comment">// 一个 HTML 标签字符串，组件选项对象，或者一个返回值</span>
  <span class="token comment">// 类型为 String/Object 的函数，必要参数</span>
  <span class="token string">'div'</span><span class="token punctuation">,</span>

  <span class="token comment">// {Object}</span>
  <span class="token comment">// 一个包含模板相关属性的数据对象</span>
  <span class="token comment">// 这样，可以在 template 中使用这些属性。可选参数。</span>
  <span class="token punctuation">{</span>
    <span class="token comment">// 此处写入数据对象</span>
    <span class="token comment">// https://cn.vuejs.org/v2/guide/render-function.html#深入-data-对象</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span>

  <span class="token comment">// {String | Array}</span>
  <span class="token comment">// 子节点 (VNodes)，由 `createElement()` 构建而成，</span>
  <span class="token comment">// 或使用字符串来生成“文本节点”。可选参数。</span>
  <span class="token punctuation">[</span>
    <span class="token string">'先写一些文字'</span><span class="token punctuation">,</span>
    <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">,</span> <span class="token string">'一则头条'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">createElement</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">,</span> <span class="token punctuation">{</span>
      props<span class="token punctuation">:</span> <span class="token punctuation">{</span>  <span class="token comment">// 组件 props</span>
        someProp<span class="token punctuation">:</span> <span class="token string">'foobar'</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
  <span class="token punctuation">]</span>
<span class="token punctuation">)</span>
</code></pre><h3 id="jsx"><a href="#jsx" class="header-anchor" aria-hidden="true">#</a> JSX</h3><p>JSX 最初出现在 <code>React.js</code> 中。JSX 语法指在 JS 代码中<strong>直接</strong>嵌入 HTML。JSX 的出现颠覆了以往的 MVC 思想，MVC 是侧重视觉上分离，注重 HTML 与 JS 的分离。但局限性就是，当有大量的 JS 和 HTML 模板时，其中错综复杂的逻辑将导致难以维护。<p>React 官方认为应该<strong>侧重于关注组件整体</strong>，应该<strong>从功能上</strong>将各个组件分离开来，组件是和模板紧密关联的，组件模板和组件逻辑分离让问题复杂化。正是基于侧重<code>从功能上分离组件</code>的思维，诞生了 JSX 语法。JSX 把 HTML 模板直接嵌入到 JS 中，侧重的是从功能上将各个组件分离，注重的是组件整体。JS 本身不支持直接包含 HTML 的语法，所以要通过工具将 JSX 编译(在 Vue 中使用<a href="https://github.com/vuejs/babel-plugin-transform-vue-jsx" rel="noopener noreferrer" target="_blank">babel 插件<outboundlink></a>)输出为 JS 代码才能使用。<p>在 Vue 中使用 JSX 可缓解大量调用 <code>render 函数</code>的情况。<p><a href="https://github.com/vuejs/babel-plugin-transform-vue-jsx#usage" rel="noopener noreferrer" target="_blank">Vue-JSX 使用文档<outboundlink></a></div></article><button data-v-e85d20b2 data-v-e85d20b2 class="floating-btn __position" style="display:none"><svg class="icon-rocket" data-v-e85d20b2 viewBox="0 0 512 512"><path d="M256 421.6c-18.1 0-33.2-6.8-42.9-10.9-5.4-2.3-11.3 1.8-10.9 7.6l3.5 51c.2 3.1 3.8 4.7 6.3 2.8l14.5-11c1.8-1.4 4.5-.9 5.7 1l20.5 32.1c1.5 2.4 5.1 2.4 6.6 0l20.5-32.1c1.2-1.9 3.9-2.4 5.7-1l14.5 11c2.5 1.9 6.1.3 6.3-2.8l3.5-51c.4-5.8-5.5-10-10.9-7.6-9.8 4.1-24.8 10.9-42.9 10.9z" data-v-e85d20b2></path><path d="M397.7 293.1l-48-49.1c0-158-93.2-228-93.2-228s-94.1 70-94.1 228l-48 49.1c-1.8 1.8-2.6 4.5-2.2 7.1L130.6 412c.9 5.7 7.1 8.5 11.8 5.4l67.1-45.4s20.7 20 47.1 20c26.4 0 46.1-20 46.1-20l67.1 45.4c4.6 3.1 10.8.3 11.8-5.4l18.5-111.9c.2-2.6-.6-5.2-2.4-7zM256.5 192c-17 0-30.7-14.3-30.7-32s13.8-32 30.7-32c17 0 30.7 14.3 30.7 32s-13.7 32-30.7 32z" data-v-e85d20b2></path></svg></button></main><footer class="blog-footer sf__main__layout grid col grid-jc-center" data-v-1044ad0a data-v-cac63c14><div class="footer-info" data-v-1044ad0a>Copyright © 2018 <a href="https://github.com/lbwa" class="author" rel="noopener" target="_blank" data-v-1044ad0a>Bowen</a></div></footer><section class="loading-wrapper grid col grid-center grid-jc-center" data-v-cac63c14 style="display:none"><div class="loading"><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div><div class="loading-item"></div></div><a class="loading-tips">Loading</a></section></section></div></div><script type="text/javascript">window.__NUXT__={layout:"blog",data:[{menu:[{errno:0,to:"writings/dom-location",title:"获取 Element 在 document 中的位置信息",author:"Bowen",date:"2018 SEP 01",tags:["前端开发","CSS"]},{errno:0,to:"writings/spa-and-mpa",title:"SPA 与 MPA 的比较与优化",author:"Bowen",date:"2018 AUG 04",tags:["前端开发","SPA","MPA","skeleton"]},{errno:0,to:"writings/async-function-in-js",title:"Event loops 中的 AsyncFunction",author:"Bowen",date:"2018 JUL 26",tags:["JavaScript","async","事件循环"]},{errno:0,to:"writings/pwa-fundamentals",title:"PWA 基础",author:"Bowen",date:"2018 JUL 07",tags:["前端开发","PWA"]},{errno:0,to:"writings/js-design-pattern",title:"JS 设计模式",author:"Bowen",date:"2018 JUN 12",tags:["前端开发","设计模式"]},{errno:0,to:"writings/http-request",title:"HTTP 协议请求首部",author:"Bowen",date:"2018 JUN 08",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-response",title:"HTTP 协议响应首部",author:"Bowen",date:"2018 JUN 07",tags:["前端开发","网络请求"]},{errno:0,to:"writings/http-protocol",title:"HTTP 协议",author:"Bowen",date:"2018 JUN 06",tags:["前端开发","网络请求"]},{errno:0,to:"writings/execution-context",title:"JS 执行上下文",author:"Bowen",date:"2018 MAY 07",tags:["前端开发","JavaScript","执行上下文"]},{errno:0,to:"writings/vue-lifecycle-and-slots",title:"对 Vue 插槽和生命周期的一点思考",author:"Bowen",date:"2018 APR 24",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/learning-vue-unit-test",title:"总结如何进行单元测试",author:"Bowen",date:"2018 APR 21",tags:["前端开发","Vue.js","应用测试"]},{errno:0,to:"writings/cross-domain-solution",title:"客户端跨域解决方案",author:"Bowen",date:"2018 APR 19",tags:["前端开发","网络请求"]},{errno:0,to:"writings/css-bfc",title:"探究 BFC 以及闭合浮动原理",author:"Bowen",date:"2018 MAR 29",tags:["前端开发","CSS"]},{errno:0,to:"writings/vue.js-reusability-and-composition",title:"学习 Vue.js 可复用性和组合",author:"Bowen",date:"2018 MAR 12",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/event-loop",title:"解析 event loops",author:"Bowen",date:"2018 MAR 08",tags:["前端开发","JavaScript","事件循环"]},{errno:0,to:"writings/learning-vuex",title:"学习 vuex 基础",author:"Bowen",date:"2018 MAR 06",tags:["前端开发","Vue.js"]},{errno:0,to:"writings/compare-commonjs-with-esm",title:"比较 CommonJS 与 ES6 Module 语法",author:"Bowen",date:"2018 FEB 27",tags:["前端开发","JavaScript","模块"]},{errno:0,to:"writings/learning-vuejs-essentials",title:"学习 Vue.js 基础",author:"Bowen",date:"2018 FEB 24",tags:["前端开发","JavaScript","Vue.js"]},{errno:0,to:"writings/keyword-this",title:"理解 this 的指向",author:"Bowen",date:"2018 FEB 06",tags:["前端开发","JavaScript"]}]},{title:"学习 Vue.js 可复用性和组合",date:"2018 MAR 12",author:"Bowen",tags:["前端开发","JavaScript","Vue.js"],content:'<h2 id="混入"><a class="header-anchor" href="#混入" aria-hidden="true">#</a> 混入</h2>\n<h3 id="基础"><a class="header-anchor" href="#基础" aria-hidden="true">#</a> 基础</h3>\n<p>混入可理解为在一个组件中调用另外一个包含组件选项的<strong>对象</strong>。可类比 Sass 中的 <code>@mixin</code> 混合宏、DOM 中的 <code>DocumentFragment</code> 类型。这里可以得到，混入是为了增强 Vue 中的选项复用性。</p>\n<p>在创建 Vue 实例时，使用<code>mixins</code>选项来引入混入对象。</p>\n<pre v-pre class="language-js"><code><span class="token keyword">const</span> CustomMixin <span class="token operator">=</span> <span class="token punctuation">{</span>\n  <span class="token function">created</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n  methods<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n    <span class="token function">hello</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">\'App is running now !\'</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n\n<span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  el<span class="token punctuation">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n  mixins<span class="token punctuation">:</span> <span class="token punctuation">[</span>CustomMixin<span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token comment">// 使用 mixins 选项来引入混入对象</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<h3 id="选项合并"><a class="header-anchor" href="#选项合并" aria-hidden="true">#</a> 选项合并</h3>\n<ol>\n<li>在混入时，各个选项的合并是<strong>浅合并</strong>（如，指向对象的指针就只会复制指针而不是复制对象，并没有开辟新的内存地址），在选项发生冲突时以组件数据优先。</li>\n<li>同名钩子函数将混合为一个数组，因此<strong>都</strong>将被调用。另外，混入对象的钩子将在组件自身钩子<strong>之前</strong>调用。</li>\n<li>值为对象的选项，例如 <code>methods</code>, <code>components</code> 和 <code>directives</code>，将被混合为<strong>同一个</strong>对象。两个对象键名冲突时，取组件对象的键值对。</li>\n</ol>\n<h3 id="全局混入"><a class="header-anchor" href="#全局混入" aria-hidden="true">#</a> 全局混入</h3>\n<p>谨慎使用全局混入，因为一旦混入，将影响到<strong>所有</strong>之后创建的 Vue 实例。</p>\n<h2 id="自定义指令"><a class="header-anchor" href="#自定义指令" aria-hidden="true">#</a> 自定义指令</h2>\n<p>使用 <code>Vue.directive()</code> 来创建全局自定义指令。在创建 Vue 实例时使用 <code>directive</code> 选项来创建局部自定义指令。</p>\n<p>格式如下：</p>\n<pre v-pre class="language-js"><code><span class="token comment">// 注册一个全局自定义指令 `v-focus`</span>\nVue<span class="token punctuation">.</span><span class="token function">directive</span><span class="token punctuation">(</span><span class="token string">\'focus\'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>   <span class="token comment">// 调用时加前缀 V-</span>\n  <span class="token comment">// 当被绑定的元素插入到 DOM 中时</span>\n  inserted<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n    <span class="token comment">// 聚焦元素</span>\n    el<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n<span class="token comment">// 局部自定义指令</span>\ndirectives<span class="token punctuation">:</span> <span class="token punctuation">{</span>\n  focus<span class="token punctuation">:</span> <span class="token punctuation">{</span>   <span class="token comment">// 调用时加前缀 V-</span>\n    <span class="token comment">// 指令的定义</span>\n    inserted<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>el<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n      el<span class="token punctuation">.</span><span class="token function">focus</span><span class="token punctuation">(</span><span class="token punctuation">)</span>\n    <span class="token punctuation">}</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre>\n<pre v-pre class="language-html"><code><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">v-focus</span><span class="token punctuation">></span></span>\n</code></pre>\n<h2 id="渲染函数-jsx"><a class="header-anchor" href="#渲染函数-jsx" aria-hidden="true">#</a> 渲染函数 &amp; JSX</h2>\n<h3 id="基础-2"><a class="header-anchor" href="#基础-2" aria-hidden="true">#</a> 基础</h3>\n<p>渲染函数的作用是<strong>渲染视图</strong>，又称为<code>render 函数</code>。</p>\n<p>在 <code>vue-cli</code> 的 <code>webpack</code> 模板中的 <code>main.js</code> 中有以下声明：</p>\n<pre v-pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>\n  el<span class="token punctuation">:</span> <span class="token string">\'#app\'</span><span class="token punctuation">,</span>\n  components<span class="token punctuation">:</span> <span class="token punctuation">{</span> App <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment">// 表示实例中有哪些组件可用</span>\n  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`&lt;App/>`</span></span>    <span class="token comment">// 表示要渲染哪些可用组件，这里形如 &lt;App>&lt;/App></span>\n<span class="token punctuation">}</span><span class="token punctuation">)</span>\n</code></pre>\n<p>以上代码中，</p>\n<p>components 选项，包含 Vue 实例可用组件的哈希表。即 <code>components</code> 选项表示声明了实例中存在哪些组件。（参考<a href="https://github.com/vuejs-templates/webpack/issues/575" target="_blank" rel="noopener noreferrer">官方 issue<OutboundLink/></a>、<a href="https://cn.vuejs.org/v2/api/#components" target="_blank" rel="noopener noreferrer">API:components选项<OutboundLink/></a>）</p>\n<p>template 选项，表示选项的值<code>一个字符串模板</code>作为 Vue 实例的标识使用。模板将会<strong>替换</strong>挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。即该选项<code>表示要渲染哪些组件</code>。（参考<a href="https://github.com/vuejs-templates/webpack/issues/575" target="_blank" rel="noopener noreferrer">官方 issue<OutboundLink/></a>、<a href="https://cn.vuejs.org/v2/api/#template" target="_blank" rel="noopener noreferrer">API:template选项<OutboundLink/></a>）</p>\n<p>以对 <code>components</code> 和 <code>template</code> 两个选项作用的理解，那么 <code>渲染函数</code> 代替的是 <code>template</code> 选项的作用，达到<strong>定制化渲染</strong>的作用。</p>\n<h3 id="虚拟-dom"><a class="header-anchor" href="#虚拟-dom" aria-hidden="true">#</a> 虚拟 DOM</h3>\n<p>Vue 通过建立一个<strong>虚拟DOM</strong>对真实的DOM发生的变化保持追踪。在 <code>render 函数</code> 中传入一个 <code>createElement 函数(简写为 h)</code>（<a href="https://github.com/vuejs/babel-plugin-transform-vue-jsx#h-auto-injection" target="_blank" rel="noopener noreferrer">vue-JSX 使用文档<OutboundLink/></a>、<a href="https://cn.vuejs.org/v2/guide/render-function.html#JSX" target="_blank" rel="noopener noreferrer">Vue 文档<OutboundLink/></a>）来生成模板。</p>\n<p><code>createElement 函数</code> 返回的是 <code>虚拟节点 VNode</code>， 它包含的信息会告诉 Vue 页面上需要渲染什么样的节点，以及子节点。</p>\n<h3 id="createelement-参数"><a class="header-anchor" href="#createelement-参数" aria-hidden="true">#</a> createElement 参数</h3>\n<p><code>createElement</code> 参数至多包含 3 个部分。</p>\n<p><strong>一个</strong>要创建的元素标签名（类型：字符串/对象/函数返回值）；</p>\n<p><strong>一个</strong>包含模板相关属性的 data 对象（类型：对象）；</p>\n<p><strong>一个</strong>子节点（类型：字符串/数组），且这个子节点也是由另外的 <code>createElement 函数</code> 构成。</p>\n<p>其中，data 对象和子节点为可选参数。</p>\n<p>格式如下：</p>\n<pre v-pre class="language-js"><code><span class="token comment">// @returns {VNode}</span>\n<span class="token function">createElement</span><span class="token punctuation">(</span>\n  <span class="token comment">// {String | Object | Function}</span>\n  <span class="token comment">// 一个 HTML 标签字符串，组件选项对象，或者一个返回值</span>\n  <span class="token comment">// 类型为 String/Object 的函数，必要参数</span>\n  <span class="token string">\'div\'</span><span class="token punctuation">,</span>\n\n  <span class="token comment">// {Object}</span>\n  <span class="token comment">// 一个包含模板相关属性的数据对象</span>\n  <span class="token comment">// 这样，可以在 template 中使用这些属性。可选参数。</span>\n  <span class="token punctuation">{</span>\n    <span class="token comment">// 此处写入数据对象</span>\n    <span class="token comment">// https://cn.vuejs.org/v2/guide/render-function.html#深入-data-对象</span>\n  <span class="token punctuation">}</span><span class="token punctuation">,</span>\n\n  <span class="token comment">// {String | Array}</span>\n  <span class="token comment">// 子节点 (VNodes)，由 `createElement()` 构建而成，</span>\n  <span class="token comment">// 或使用字符串来生成“文本节点”。可选参数。</span>\n  <span class="token punctuation">[</span>\n    <span class="token string">\'先写一些文字\'</span><span class="token punctuation">,</span>\n    <span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">\'h1\'</span><span class="token punctuation">,</span> <span class="token string">\'一则头条\'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>\n    <span class="token function">createElement</span><span class="token punctuation">(</span>MyComponent<span class="token punctuation">,</span> <span class="token punctuation">{</span>\n      props<span class="token punctuation">:</span> <span class="token punctuation">{</span>  <span class="token comment">// 组件 props</span>\n        someProp<span class="token punctuation">:</span> <span class="token string">\'foobar\'</span>\n      <span class="token punctuation">}</span>\n    <span class="token punctuation">}</span><span class="token punctuation">)</span>\n  <span class="token punctuation">]</span>\n<span class="token punctuation">)</span>\n</code></pre>\n<h3 id="jsx"><a class="header-anchor" href="#jsx" aria-hidden="true">#</a> JSX</h3>\n<p>JSX 最初出现在 <code>React.js</code> 中。JSX 语法指在 JS 代码中<strong>直接</strong>嵌入 HTML。JSX 的出现颠覆了以往的 MVC 思想，MVC 是侧重视觉上分离，注重 HTML 与 JS 的分离。但局限性就是，当有大量的 JS 和 HTML 模板时，其中错综复杂的逻辑将导致难以维护。</p>\n<p>React 官方认为应该<strong>侧重于关注组件整体</strong>，应该<strong>从功能上</strong>将各个组件分离开来，组件是和模板紧密关联的，组件模板和组件逻辑分离让问题复杂化。正是基于侧重<code>从功能上分离组件</code>的思维，诞生了 JSX 语法。JSX 把 HTML 模板直接嵌入到 JS 中，侧重的是从功能上将各个组件分离，注重的是组件整体。JS 本身不支持直接包含 HTML 的语法，所以要通过工具将 JSX 编译(在 Vue 中使用<a href="https://github.com/vuejs/babel-plugin-transform-vue-jsx" target="_blank" rel="noopener noreferrer">babel 插件<OutboundLink/></a>)输出为 JS 代码才能使用。</p>\n<p>在 Vue 中使用 JSX 可缓解大量调用 <code>render 函数</code>的情况。</p>\n<p><a href="https://github.com/vuejs/babel-plugin-transform-vue-jsx#usage" target="_blank" rel="noopener noreferrer">Vue-JSX 使用文档<OutboundLink/></a></p>\n'}],error:null,serverRendered:!0}</script><script defer src="/_nuxt/manifest.e871ed9ec943b3b0a9ad.js"></script><script defer src="/_nuxt/layouts/blog.6efcc6c813d476fa30a1.js"></script><script defer src="/_nuxt/pages/blog.48d3a2ec874d58a119ed.js"></script><script defer src="/_nuxt/pages/blog/writings/_id/index.7e8ea086028ccb843111.js"></script><script defer src="/_nuxt/vendor.13de21511613edf061b2.js"></script><script defer src="/_nuxt/app.5a4fa6b8fcf73db97515.js"></script>